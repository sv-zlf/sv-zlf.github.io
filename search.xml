<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode每日一题 剑指 Offer 30. 包含min函数的栈</title>
      <link href="/post/3996615906.html"/>
      <url>/post/3996615906.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>各函数的调用总次数不超过 20000 次</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用List类来实现min栈的功能：</p><p>push：调用add函数直接插入</p><p>pop：调用remove删除最后一位的数</p><p>top：调用get获取最后一位的数</p><p>min：使用Collections自带的min获取集合的最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    List&lt;Integer&gt; list ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.min(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/">官方题解</a></h2><p><strong>函数设计：</strong><br>push(x) 函数：重点为保持栈B的元素是<code>非严格降序</code>的。</p><ul><li><p>将x压入栈 A （即 A.add(x) ）；</p></li><li><p>若 ① 栈B为空 或 ② x小于等于栈B的栈顶元素，则将x压入栈B （即 B.add(x) ）。</p></li></ul><p>pop() 函数：重点为保持栈 A，B 的元素一致性 。</p><ul><li>执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；</li><li>若 y等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</li></ul><p>top() 函数：直接返回栈A的栈顶元素即可，即返回 A.peek() 。</p><p>min() 函数：直接返回栈B的栈顶元素即可，即返回 B.peek() 。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.add(x);</span><br><span class="line">        <span class="keyword">if</span>(B.empty() || B.peek() &gt;= x)</span><br><span class="line">            B.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))</span><br><span class="line">            B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode每日一题 剑指 Offer 09. 用两个栈实现队列</title>
      <link href="/post/3611967115.html"/>
      <url>/post/3611967115.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead </code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= values &lt;= 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个栈：</p><p>一个只存储队列的值(stack1)</p><p>另外一个用来出队，只进行删除操作(stack2)</p><ul><li>当stack2为空时，将stack1的值入栈</li><li>此时如果stack2还为空，即返回-1</li><li>stack2不为空，使用pop操作，返回栈顶元素，即为队列头部元素</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt; ();</span><br><span class="line">        stack2 =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt; ();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">if</span>(stack2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成Redis</title>
      <link href="/post/4135037769.html"/>
      <url>/post/4135037769.html</url>
      
        <content type="html"><![CDATA[<h3 id="添加Maven依赖"><a href="#添加Maven依赖" class="headerlink" title="添加Maven依赖"></a>添加Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springboot中的redis依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml中配置redis参数"><a href="#application-yml中配置redis参数" class="headerlink" title="application.yml中配置redis参数"></a>application.yml中配置redis参数</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">30000</span>    <span class="comment">#最大阻塞等待时间</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">100</span>    <span class="comment">#最大连接数</span></span><br><span class="line"><span class="attr">max-idle:</span> <span class="number">20</span>       <span class="comment">#最大空闲连接数</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">0</span>        <span class="comment">#最小空闲连接数</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">3000</span>      <span class="comment">#连接超时</span></span><br></pre></td></tr></table></figure><h3 id="redis的配置类"><a href="#redis的配置类" class="headerlink" title="redis的配置类"></a>redis的配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: springbootdemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">//开启注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retemplate相关配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对hash类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HashOperations&lt;String, String, Object&gt; <span class="title function_">hashOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对redis字符串类型数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="title function_">valueOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对链表类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ListOperations&lt;String, Object&gt; <span class="title function_">listOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对无序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SetOperations&lt;String, Object&gt; <span class="title function_">setOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="title function_">zSetOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis的工具类"><a href="#redis的工具类" class="headerlink" title="redis的工具类"></a>redis的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redisTemplate封装</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisUtil</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key,<span class="type">long</span> time)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String ... key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="literal">null</span>&amp;&amp;key.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.length==<span class="number">1</span>)&#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//============================String=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key==<span class="literal">null</span>?<span class="literal">null</span>:redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key,Object value,<span class="type">long</span> time)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//================================Map=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key,String item)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object,Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map, <span class="type">long</span> time)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key,String item,Object value,<span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key,item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item,<span class="type">double</span> by)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//============================set=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key,Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object...values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key,<span class="type">long</span> time,Object...values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span>(time&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object ...values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束  0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key,<span class="type">long</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index,Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key,<span class="type">long</span> count,Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询获取key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set <span class="title function_">keys</span><span class="params">(String pattern)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Redis的消息队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertAndSend</span><span class="params">(String channel, Object message)</span>&#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel,message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//=========BoundListOperations 用法 start============</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *将数据添加到Redis的list中（从右边添加）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireEnum 有效期的枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 待添加的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToListRight</span><span class="params">(String listKey, Status.ExpireEnum expireEnum, Object... values)</span> &#123;</span><br><span class="line">        <span class="comment">//绑定操作</span></span><br><span class="line">        BoundListOperations&lt;String, Object&gt; boundValueOperations = redisTemplate.boundListOps(listKey);</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        boundValueOperations.rightPushAll(values);</span><br><span class="line">        <span class="comment">//设置过期时间</span></span><br><span class="line">        boundValueOperations.expire(expireEnum.getTime(),expireEnum.getTimeUnit());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据起始结束序号遍历Redis中的list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  起始序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  结束序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">rangeList</span><span class="params">(String listKey, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//绑定操作</span></span><br><span class="line">        BoundListOperations&lt;String, Object&gt; boundValueOperations = redisTemplate.boundListOps(listKey);</span><br><span class="line">        <span class="comment">//查询数据</span></span><br><span class="line">        <span class="keyword">return</span> boundValueOperations.range(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出右边的值 --- 并且移除这个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">rifhtPop</span><span class="params">(String listKey)</span>&#123;</span><br><span class="line">        <span class="comment">//绑定操作</span></span><br><span class="line">        BoundListOperations&lt;String, Object&gt; boundValueOperations = redisTemplate.boundListOps(listKey);</span><br><span class="line">        <span class="keyword">return</span> boundValueOperations.rightPop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=========BoundListOperations 用法 End============</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Redis中的Status类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: dgpoms-server-root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间相关枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">ExpireEnum</span>&#123;</span><br><span class="line">        <span class="comment">//未读消息的有效期为30天</span></span><br><span class="line">        UNREAD_MSG(<span class="number">30L</span>, TimeUnit.DAYS)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 过期时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Long time;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">        ExpireEnum(Long time, TimeUnit timeUnit) &#123;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">            <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Long <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TimeUnit <span class="title function_">getTimeUnit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> timeUnit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考文章：</p><p>[1] <a href="https://www.jianshu.com/p/5596c3a4978d">springboot redis 项目实战 完整篇 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见maven依赖</title>
      <link href="/post/3791434479.html"/>
      <url>/post/3791434479.html</url>
      
        <content type="html"><![CDATA[<h3 id="Sping-Boot-Web依赖"><a href="#Sping-Boot-Web依赖" class="headerlink" title="Sping Boot Web依赖"></a>Sping Boot Web依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Test-测试起步依赖"><a href="#Test-测试起步依赖" class="headerlink" title="Test 测试起步依赖"></a>Test 测试起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger依赖导入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mybaits"><a href="#Mybaits" class="headerlink" title="Mybaits"></a>Mybaits</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="commons-lang包"><a href="#commons-lang包" class="headerlink" title="commons-lang包"></a>commons-lang包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Security --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JWT--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger配置</title>
      <link href="/post/162472822.html"/>
      <url>/post/162472822.html</url>
      
        <content type="html"><![CDATA[<h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger依赖导入--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="swagger配置类"><a href="#swagger配置类" class="headerlink" title="swagger配置类"></a>swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ParameterBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.schema.ModelRef;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Parameter;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//开启在线文档</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        添加head参数</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line"><span class="comment">/*        ParameterBuilder tokenPar = new ParameterBuilder();</span></span><br><span class="line"><span class="comment">        List&lt;Parameter&gt; pars = new ArrayList&lt;Parameter&gt;();</span></span><br><span class="line"><span class="comment">        tokenPar.name(&quot;token&quot;).description(&quot;AccessToken令牌&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(false).build();</span></span><br><span class="line"><span class="comment">        pars.add(tokenPar.build());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .pathMapping(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .select() <span class="comment">// 选择那些路径和api会生成document</span></span><br><span class="line">                .apis(RequestHandlerSelectors.any())<span class="comment">// 对所有api进行监控</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.xxx.xxx.controller&quot;</span>))</span><br><span class="line">                .build()</span><br><span class="line">                .globalOperationParameters(pars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;XXXXX&quot;</span>)        <span class="comment">//api文档名字</span></span><br><span class="line">                .description(<span class="string">&quot;XXXXX&quot;</span>)   <span class="comment">//api名字</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.zlfeng.cn/&quot;</span>)  <span class="comment">//附带链接资源</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud学习</title>
      <link href="/post/1251775048.html"/>
      <url>/post/1251775048.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud?"></a>什么是Spring Cloud?</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。 </p><p>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</p><h2 id="REST和RPC的区别"><a href="#REST和RPC的区别" class="headerlink" title="REST和RPC的区别"></a>REST和RPC的区别</h2><p> REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。 </p><p> REST调用系统性能较低，RPC调用效率比REST高。 </p><p> REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。 </p><p> REST可以和Swagger等工具整合，自动输出接口API文档。</p><h2 id="SpringCloud如何实现服务的注册和发现"><a href="#SpringCloud如何实现服务的注册和发现" class="headerlink" title="SpringCloud如何实现服务的注册和发现"></a>SpringCloud如何实现服务的注册和发现</h2><p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p><p> 这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。 </p><p> 调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</p><h2 id="什么是服务熔断和服务降级？"><a href="#什么是服务熔断和服务降级？" class="headerlink" title="什么是服务熔断和服务降级？"></a>什么是服务熔断和服务降级？</h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。</p><p>在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p><p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。<br> Hystrix相关注解：<br> @EnableHystrix：开启熔断<br> @HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p><h2 id="服务网关的作用"><a href="#服务网关的作用" class="headerlink" title="服务网关的作用"></a>服务网关的作用</h2><p>简化客户端调用复杂度，统一处理外部请求。 </p><p>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。 </p><p>多渠道支持，针对不同的客户端提供不同的网关支持。 </p><p>遗留系统的微服务化改造，可以作为新老系统的中转组件。 </p><p>统一处理调用过程中的安全、权限问题。</p><h2 id="Ribbon和Feign区别"><a href="#Ribbon和Feign区别" class="headerlink" title="Ribbon和Feign区别"></a>Ribbon和Feign区别</h2><p>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value&#x3D;”服务名称”) 使用RestTemplate调用远程服务对应的方法；Feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”) </p><p>Ribbon和Feign的区别：</p><p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。 </p><p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。 </p><p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。 </p><p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 </p><p>Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p><h2 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h2><p>Zookeepper保证了CP（C：一致性，P：分区容错性） </p><p>Eureka保证了AP（A：高可用） </p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。 </p><p>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： </p><p>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 </p><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。 </p><p>当网络稳定时，当前实例新的注册信息会被同步到其他节点。 </p><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeepper那样使整个微服务瘫痪。</p><h2 id="Spring-Cloud-配置管理——Config"><a href="#Spring-Cloud-配置管理——Config" class="headerlink" title="Spring Cloud 配置管理——Config"></a>Spring Cloud 配置管理——Config</h2><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>为了能够对项目配置进行统一管理，同时又能在项目运行中修改配置，Spring Cloud Config提出了解决方案。</p><p>Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p><p>简单来说，Spring Cloud Config就是能将各个 应用&#x2F;系统&#x2F;模块的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，真实的情况是依赖于这个配置的应用并不会出现更改，这就是BUS总线的作用。</p><p>简单理解为 Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为 消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 Spring Cloud Bus之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><p><img src="https://s2.loli.net/2022/03/13/U4vzH3GP7ckSdlm.jpg"></p><h2 id="服务链路追踪-Spring-Cloud-Sleuth"><a href="#服务链路追踪-Spring-Cloud-Sleuth" class="headerlink" title="服务链路追踪(Spring Cloud Sleuth)"></a>服务链路追踪(Spring Cloud Sleuth)</h2><p>　微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在，一个请求可能需要调用很多个服务，而内部服务的调用复杂性，决定了问题难以定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题，很快定位。</p><p>参考文章：</p><p>[1] <a href="https://my.oschina.net/langwanghuangshifu/blog/3005195">https://my.oschina.net/langwanghuangshifu/blog/3005195</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Mybaits框架</title>
      <link href="/post/2539103785.html"/>
      <url>/post/2539103785.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mybaits概述"><a href="#Mybaits概述" class="headerlink" title="Mybaits概述"></a>Mybaits概述</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><a href="https://blog.csdn.net/weixin_43184769/article/details/91126687">原理</a></h3><p>当调用Mapper接口方法的时候，Mybatis会使用JDK动态代理返回一个Mapper代理对象，代理对象会拦截接口方法，根据接口的全路径和方法名，定位到sql，使用executor执行sql语句，然后将sql执行结果返回。</p><p>因为mybatis动态代理寻找策略是全限定名+方法名，不涉及参数，所以不支持重载。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li><li>开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>与各种数据库兼容。</li></ol><p>缺点：</p><ol><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li></ol><h3 id="传统的JDBC编程"><a href="#传统的JDBC编程" class="headerlink" title="传统的JDBC编程"></a>传统的JDBC编程</h3><p>JDBC定义了连接数据库的接口规范，每个数据库厂商都会提供具体的实现，JDBC是一种典型的桥接模式。</p><ul><li>获取数据库连接；</li><li>操作Connection，打开Statement对象；</li><li>通过Statement对象执行SQL，返回结果到ResultSet对象；</li><li>关闭数据库资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException  &#123;</span><br><span class="line">        String URL=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/imooc?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">        String USER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String PASSWORD=<span class="string">&quot;tiger&quot;</span>;</span><br><span class="line">        <span class="comment">//1.加载驱动程序</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获得数据库链接</span></span><br><span class="line">        Connection conn=DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span></span><br><span class="line">        Statement st=conn.createStatement();</span><br><span class="line">        ResultSet rs=st.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line">        <span class="comment">//4.处理数据库的返回结果(使用ResultSet类)</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">&quot;user_name&quot;</span>)+<span class="string">&quot; &quot;</span></span><br><span class="line">                          +rs.getString(<span class="string">&quot;user_password&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        st.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hibernate与Mybatis"><a href="#Hibernate与Mybatis" class="headerlink" title="Hibernate与Mybatis"></a>Hibernate与Mybatis</h3><p>Hibernate建立在POJO和数据库表模型的直接映射关系上。通过POJO我们可以直接操作数据库的数据。相对而言，Hibernate对JDBC的封装程度比较高，我们不需要编写SQL，直接通过HQL去操作POJO进而操作数据库的数据。</p><p>Mybatis是半自动映射的orm框架，它需要我们提供POJO，SQL和映射关系，而全表映射的Hibernate只需要提供POJO和映射关系。</p><p>Hibernate编程简单，需要我们提供映射的规则，完全可以通过IDE实现，同时无需编写SQL，开发效率优于Mybatis。此外，它提供缓存、级联、日志等强大的功能，</p><p>Hibernate与Mybatis区别：</p><ol><li>Hibernate是全自动，而Mybatis是半自动。 Hibernate是全表映射，可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而Mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</li><li>Hibernate数据库移植性较好。 Hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库的耦合性，而Mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</li><li>Hibernate拥有完整的日志系统，Mybatis则欠缺一些。 Hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而Mybatis则除了基本记录功能外，功能薄弱很多。</li><li>sql直接优化上，Mybatis要比Hibernate方便很多。 由于Mybatis的sql都是写在xml里，因此优化sql比Hibernate方便很多，解除了sql与代码的耦合。而Hibernate的sql很多都是自动生成的，无法直接维护sql；写sql的灵活度上Hibernate不及Mybatis。</li><li>Mybatis提供xml标签，支持编写动态sql。</li></ol><h3 id="Mybatis组件的生命周期"><a href="#Mybatis组件的生命周期" class="headerlink" title="Mybatis组件的生命周期"></a>Mybatis组件的生命周期</h3><ol><li><p>SqlSessionFactoryBuilder</p><p>作用是生成SqlSessionFactory，构建完毕则作用完结，生命周期只存在于方法的局部。</p></li><li><p>SqlSessionFactory</p><p>创建SqlSession，每次访问数据库都需要通过SqlSessionFactory创建SqlSession。故SqlSessionFactory应存在于Mybatis应用的整个生命周期。</p></li><li><p>SqlSession</p><p>会话，相当于JDBC的Connection对象，生命周期为请求数据库处理事务的过程。</p></li><li><p>Mapper</p><p>作用是发送SQL，返回结果或执行SLQ修改数据库数据，它的生命周期在一个SqlSession事务方法之内。其最大的作用范围和SqlSession相同。</p></li></ol><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>Mybatis数据库事务由SqlSession控制，我们可以通过SqlSession提交或回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRoleTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">        <span class="type">RoleMapper</span> <span class="variable">roleMapper</span> <span class="operator">=</span> sqlSession.getMapper(RoleMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">        role.setId(<span class="number">2L</span>);</span><br><span class="line">        role.setNote(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        role.setRoleName(<span class="string">&quot;teacher&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        roleMapper.insertRole(role);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        sqlSession.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>MyBatis 有三种基本的 Executor 执行器，<code>SimpleExecutor</code> 、 <code>ReuseExecutor</code> 、 <code>BatchExecutor</code> 。</p><p><strong><code>SimpleExecutor</code> ：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong><code>ReuseExecutor</code> ：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code> ：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p><h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><h3 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h3><table><thead><tr><th>元素</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>和Mapper命名空间的组合是唯一的</td><td>命名空间和id组合不唯一，则抛异常</td></tr><tr><td>parameterType</td><td>类的全路径或者别名</td><td>基本数据类型，JavaBean，Map等</td></tr><tr><td>resultType</td><td>基本数据类型或者类的全路径，可使用别名（需符合别名规范）</td><td>允许自动匹配的请况下，结果集将通过JavaBean的规范映射，不能和resultMap同时使用</td></tr><tr><td>resultMap</td><td>自定义映射规则</td><td>Mybatis最复杂的元素，可以配置映射规则、级联、typeHandler等</td></tr></tbody></table><h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>autoMappingBehavior不为NONE时，Mybatis会提供自动映射的功能，只要返回的列名和JavaBean的属性一致，Mybatis就会帮助我们回填这些字段。实际上大部分数据库规范使用下划线分割单词，而Java则是用驼峰命名法，于是需要使用列的别名使得Mybatis能够自动映射，或者在配置文件中开启驼峰命名方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SQL列的别名与pojo的属性一样，则SQL查询的结果会自动映射到pojo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, role_name as roleName, note FROM role WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动映射可以在setting元素中配置autoMappingBehavior属性值设定其策略。包含三个值：</p><ul><li>NONE，取消自动映射</li><li>PARTIAL，只会自动映射，没有定义嵌套结果集映射的结果集</li><li>FULL，会自动映射任意复杂的结果集（无论是否嵌套）</li></ul><p>默认值是PARTIAL，默认情况下可以做到当前对象的映射，使用FULL是嵌套映射，性能会下降。</p><p>如果数据库是规范命名的，即每个单词用下划线分隔，而POJO是驼峰式命名的方式，此时可设置mapUnderscoreToCamelCase为true，这样就可以实现从数据库到POJO的自动映射了。</p><h4 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h4><p>1.使用注解方式传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">findRoleByCondition</span><span class="params">(<span class="meta">@Param(&quot;roleName&quot;)</span> String roleName, <span class="meta">@Param(&quot;note&quot;)</span>String note)</span>;</span><br></pre></td></tr></table></figure><p>RoleMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findRoleByCondition&quot; resultMap=&quot;roleMap&quot;&gt;</span><br><span class="line">    SELECT id, role_name, note FROM role</span><br><span class="line">    WHERE role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">    and note like concat(&#x27;%&#x27;, #&#123;note&#125;, &#x27;%&#x27;)</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>2.使用JavaBean传递参数</p><p>将参数组织成JavaBean，通过getter和setter方法设置参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleParam</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoleName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoleName</span><span class="params">(String roleName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> note;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNote</span><span class="params">(String note)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口RoleMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">findRoleByParams2</span><span class="params">(RoleParam roleParam)</span>;</span><br></pre></td></tr></table></figure><p>RoleMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoleByParams2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tyson.pojo.RoleParam&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, role_name, note FROM role</span><br><span class="line">    WHERE role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">    and note like concat(&#x27;%&#x27;, #&#123;note&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数个数多于5，建议使用JavaBean方式。</p><h4 id="使用resultMap映射结果集"><a href="#使用resultMap映射结果集" class="headerlink" title="使用resultMap映射结果集"></a>使用resultMap映射结果集</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;roleMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义结果类型处理器标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;com.tyson.typeHandler.MyStringTypeHandler&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoleByParams1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, role_name, note FROM role</span><br><span class="line">    WHERE role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">    and note like concat(&#x27;%&#x27;, #&#123;note&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h3><p>执行插入之后会返回一个整数，表示插入的记录数。parameterType 为 role（mybatis-config.xml 定义的别名）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot;&gt;</span><br><span class="line">    INSERT into role(id, role_name, note) VALUES(#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h4 id="主键回填"><a href="#主键回填" class="headerlink" title="主键回填"></a>主键回填</h4><p>设计表的时候有两种主键，一种自增主键，一般为int类型，一种为非自增的主键，例如用uuid等。</p><h5 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h5><p>role表指定id字段为自增字段，对应的Role实体类提供getter和setter方法，便可以使用Mybatis的主键回填功能。通过keyProperty指定主键字段，并使用useGeneratedKeys告诉Mybatis这个主键是否使用数据库内置策略生成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--useGeneratedKeys：默认false，使MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</span></span><br><span class="line"><span class="comment">   keyProperty：默认值unset，用于设置getGeneratedKeys方法或selectKey子元素返回值将赋值到哪个属性中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertRoleUseGeneratedKeys&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">       INSERT into role(role_name, note) VALUES(#&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传入的role无需设置id，Mybatis在插入记录时会自动回填主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertRoleUseGeneratedKeysTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">        <span class="type">RoleMapper</span> <span class="variable">roleMapper</span> <span class="operator">=</span> sqlSession.getMapper(RoleMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">        role.setNote(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        role.setRoleName(<span class="string">&quot;worker&quot;</span>);</span><br><span class="line"></span><br><span class="line">        roleMapper.insertRoleUseGeneratedKeys(role);</span><br><span class="line">        log.info(role.toString());</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        sqlSession.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过selectKey设置主键回填。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--selectKey会将 SELECT LAST_INSERT_ID()的结果放入到传入的pojo的主键;</span></span><br><span class="line"><span class="comment">    keyProperty 对应的pojo中的主键的属性名;</span></span><br><span class="line"><span class="comment">    order设置为BEFORE，先执行selectKey语句（SELECT LAST_INSERT_ID()），然后执行插入语句；</span></span><br><span class="line"><span class="comment">    order设置为AFTER，先执行插入语句，然后执行selectKey语句；</span></span><br><span class="line"><span class="comment">    SELECT LAST_INSERT_ID()：得到刚insert 进去记录的主键值，只适用与自增主键;</span></span><br><span class="line"><span class="comment">    resultType：主键类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT into role(role_name, note) VALUES(#&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="非自增主键"><a href="#非自增主键" class="headerlink" title="非自增主键"></a>非自增主键</h5><p>假设增加如下需求，当表role没有记录时，则插入第一条记录时id设为1，否则取最大的id加2，设置为新的主键，这个时候可以使用selectKey来处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;myInsertRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--order为BEFORE，selectKey语句在insert语句插入之前执行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        select if(max(id) is null, 1, max(id) + 2) as newId from role</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT into role(id, role_name, note) VALUES(#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>selectKey标签的语句会被先执行，然后把查询到的id放到role对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myInsertRoleTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">        <span class="type">RoleMapper</span> <span class="variable">roleMapper</span> <span class="operator">=</span> sqlSession.getMapper(RoleMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">        role.setNote(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        role.setRoleName(<span class="string">&quot;worker&quot;</span>);</span><br><span class="line"></span><br><span class="line">        roleMapper.myInsertRole(role);</span><br><span class="line">        log.info(role.toString());</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        sqlSession.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设主键是VARCHAR类型，以uuid()方式生成主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tyson.mapper.CustomerMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertCustomer&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tyson.pojo.Customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--order为BEFORE，uuid()在insert语句插入之前执行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">            select uuid()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert customer(id, name) values(#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="update和delete元素"><a href="#update和delete元素" class="headerlink" title="update和delete元素"></a>update和delete元素</h3><p>update和delete元素用于更新记录和删除记录。插入和删除记录执行完成会返回一个整数，表示插入或删除几条记录。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">       update role set</span><br><span class="line">       role_name = #&#123;roleName&#125;,</span><br><span class="line">       note = #&#123;note&#125;</span><br><span class="line">       where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">       delete from role where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h3><p>还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p><h3 id="Dao接口的工作原理"><a href="#Dao接口的工作原理" class="headerlink" title="Dao接口的工作原理"></a>Dao接口的工作原理</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ，举例： <code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p><h3 id="Dao接口方法可以重载吗？"><a href="#Dao接口方法可以重载吗？" class="headerlink" title="Dao接口方法可以重载吗？"></a>Dao接口方法可以重载吗？</h3><p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper接口里面方法重载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StuMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">getAllStu</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">getAllStu</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>StuMapper.xml</code> 中利用 Mybatis 的动态 sql 就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getAllStu&quot;</span> resultType=<span class="string">&quot;com.pojo.Student&quot;</span>&gt;</span><br><span class="line">     select * from student</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;id != null&quot;</span>&gt;</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><h3 id="MyBatis-是否可以映射-Enum-枚举类？"><a href="#MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="MyBatis 是否可以映射 Enum 枚举类？"></a>MyBatis 是否可以映射 Enum 枚举类？</h3><p>MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code> ，实现 <code>TypeHandler</code> 的 <code>setParameter()</code> 和 <code>getResult()</code> 接口方法。 <code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code> 和 <code>getResult()</code> 两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>Mybatis的动态SQL主要包括以下几种元素。</p><table><thead><tr><th>元素</th><th>作用</th></tr></thead><tbody><tr><td>if</td><td>单条件分支判断</td></tr><tr><td>choose(when、otherwise)</td><td>相当于Java的switch、case</td></tr><tr><td>foreach</td><td>在in语句等列举条件常用</td></tr><tr><td>trim(where、set)</td><td>用于处理SQL拼装问题</td></tr></tbody></table><h4 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h4><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 。</p><p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><h3 id="if元素"><a href="#if元素" class="headerlink" title="if元素"></a>if元素</h3><p>if元素和test属性联合使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRoleByRoleName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time FROM role where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose元素"><a href="#choose元素" class="headerlink" title="choose元素"></a>choose元素</h3><p>choose、when和otherwise类似于Java的switch、case和default。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoles&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time from role where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and role_name = #&#123;roleName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;note != null and note != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and note = #&#123;note&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and id != 1</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当roleName不为空，则只用roleName作为条件查询；</li><li>当roleName为空，note不为空，则用note作为条件进行查询；</li><li>当roleName和note都为空时，则以 id !&#x3D; 1 作为查询条件</li></ul><h3 id="where元素"><a href="#where元素" class="headerlink" title="where元素"></a>where元素</h3><p>where元素解析时会自动将第一个字段的and去掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoles&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time from role</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;note != null and note != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and note like concat(&#x27;%&#x27;, #&#123;note&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用trim也可以达到同样的效果。prefix代表语句前缀，prefixOverrides代表需要去掉的字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoles&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time from role</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;note != null and note != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and note like concat(&#x27;%&#x27;, #&#123;note&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set元素"><a href="#set元素" class="headerlink" title="set元素"></a>set元素</h3><p>当在 update 语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置 SET 关键字，并剔除追加到条件末尾的任何不相关的逗号。使用 if+set 标签修改后，如果某项为 null 则不进行更新，而是保持数据库原值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    update role</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            role_name = #&#123;roleName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;note != null and note != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            note = #&#123;note&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;regTime != null&quot;</span>&gt;</span></span><br><span class="line">            reg_time = #&#123;regTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach元素"><a href="#foreach元素" class="headerlink" title="foreach元素"></a>foreach元素</h3><p>foreach用于遍历元素，支持数组、List和Set接口的集合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchInsertRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into role(role_name, note, reg_time) values</span><br><span class="line">    <span class="comment">&lt;!--mapper接口参数没有使用@Param指定参数名称，则collection名称默认为list--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;role&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;role.roleName&#125;, #&#123;role.note&#125;, #&#123;role.regTime,javaType=Date, jdbcType=VARCHAR&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRolesInIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time from role</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ids != null&quot;</span>&gt;</span></span><br><span class="line">        where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p><strong>RowBounds分页</strong></p><p>RowBounds分页是Mybatis内置的基本功能，在任何的select语句中都可以使用，它是在SQL语句查询出所有结果之后，对结果进行截断，当SQL语句返回大量结果时，容易造成内存溢出。其适用于返回数据量小的查询。</p><p>RowBounds有两个重要的参数limit和offeset，offeset表示从哪一条记录开始读取，limit表示限制返回的记录数。</p><p>下面通过角色名称模糊查询角色信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用resultMap进行结果映射, 用typeHandler对note字段进行转化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRoleByRoleName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">    select id, role_name, note, reg_time from role where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName != null and roleName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and role_name like concat(&#x27;%&#x27;, #&#123;roleName&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>RoleMapper接口定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tyson.pojo.Role;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.RowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">getRoleByRoleName</span><span class="params">(<span class="meta">@Param(&quot;roleName&quot;)</span> String roleName, RowBounds rowBounds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRoleByRoleNameTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">        <span class="type">RoleMapper</span> <span class="variable">roleMapper</span> <span class="operator">=</span> sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">        List&lt;Role&gt; roles = roleMapper.getRoleByRoleName(<span class="string">&quot;man&quot;</span>, <span class="keyword">new</span> <span class="title class_">RowBounds</span>(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">        roles.forEach(role -&gt; &#123;</span><br><span class="line">            log.info(role.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果返回五条记录。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>#{ } 被解析成预编译语句，预编译之后可以直接执行，不需要重新编译sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//sqlMap 中如下的 sql 语句</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line">//解析成为预编译语句；编译好SQL语句再取值</span><br><span class="line">select * from user where name = ?;</span><br></pre></td></tr></table></figure><p>${ } 仅仅为一个字符串替换，每次执行sql之前需要进行编译，存在 sql 注入问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;</span><br><span class="line">//传递的参数为 &quot;ruhua&quot; 时,解析为如下，然后发送数据库服务器进行编译。取值以后再去编译SQL语句。</span><br><span class="line">select * from user where name = &quot;ruhua&quot;;</span><br></pre></td></tr></table></figure><p>数据库接受到sql语句之后，需要词法和语义解析，优化sql语句，制定执行计划。这需要花费一些时间。如果一条sql语句需要反复执行，每次都进行语法检查和优化，会浪费很多时间。预编译语句就是将sql语句中的<code>值用占位符替代</code>，即将<code>sql语句模板化</code>。一次编译、多次运行，省去了解析优化等过程。</p><p>mybatis是通过PreparedStatement和占位符来实现预编译的。</p><p>mybatis底层使用PreparedStatement，默认情况下，将对所有的 sql 进行预编译，将#{}替换为?，然后将带有占位符?的sql模板发送至mysql服务器，由服务器对此无参数的sql进行编译后，将编译结果缓存，然后直接执行带有真实参数的sql。</p><p>预编译的作用：</p><ol><li>预编译阶段可以优化 sql 的执行。预编译之后的 sql 多数情况下可以直接执行，数据库服务器不需要再次编译，可以提升性能。</li><li>预编译语句对象可以重复利用。把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li><li>防止SQL注入。使用预编译，而其后注入的参数将<code>不会再进行SQL编译</code>。也就是说其后注入进来的参数系统将不会认为它会是一条SQL语句，而默认其是一个参数。</li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>目前流行的缓存服务器有Redis、Ehcache、MangoDB等。缓存是计算机内存保存的数据，在读取数据的时候不用从磁盘读入，具备快速读取的特点，如果缓存命中率高，可以极大提升系统的性能。若缓存命中率低，则使用缓存意义不大，故使用缓存的关键在于存储内容访问的命中率。</p><h3 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h3><p>Mybatis对缓存提供支持，默认情况下只开启一级缓存，一级缓存作用范围为同一个SqlSession。在SQL和参数相同的情况下，我们使用同一个SqlSession对象调用同一个Mapper方法，往往只会执行一次SQL。因为在使用SqlSession第一次查询后，Mybatis会将结果放到缓存中，以后再次查询时，如果没有声明需要刷新，并且缓存没超时的情况下，SqlSession只会取出当前缓存的数据，不会再次发送SQL到数据库。若使用不同的SqlSession，因为不同的SqlSession是相互隔离的，不会使用一级缓存。</p><p>二级缓存作用范围是Mapper（Namespace），可以使缓存在各个SqlSession之间共享。二级缓存默认不开启，需要在mybatis-config.xml开启二级缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通知 MyBatis 框架开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并在相应的Mapper.xml文件添加cache标签，表示对哪个mapper 开启缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>二级缓存要求返回的POJO必须是可序列化的，即要求实现Serializable接口。</p><p>当开启二级缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMybatis%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98.md">https://github.com/Tyson0314/Java-learning/blob/master/%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMybatis%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98.md</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Mybaits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot学习</title>
      <link href="/post/1315677230.html"/>
      <url>/post/1315677230.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习</title>
      <link href="/post/2887444338.html"/>
      <url>/post/2887444338.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h3 id="什么是spring？"><a href="#什么是spring？" class="headerlink" title="什么是spring？"></a>什么是spring？</h3><p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><p>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</p><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）。</p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><h3 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h3><ul><li><strong>轻量</strong>，基本版本大约2MB。</li><li>通过控制反转和依赖注入实现<strong>松耦合</strong>。</li><li>支持<strong>面向切面</strong>的编程，并且把应用业务逻辑和系统服务分开。</li><li>通过切面和模板减少样板式代码。</li><li>方便集成各种优秀框架。内部提供了对各种优秀框架的直接支持（如：Hibernate、MyBatis等）。</li><li>方便程序的测试。Spring支持Junit4，添加注解便可以测试Spring程序。</li></ul><h3 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h3><p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p><p>Spring价值：</p><p>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；<br>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；<br>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</p><h3 id="Spring-由哪些模块组成？"><a href="#Spring-由哪些模块组成？" class="headerlink" title="Spring 由哪些模块组成？"></a>Spring 由哪些模块组成？</h3><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p><img src="https://s2.loli.net/2022/03/21/1QxXot2OFdnDgbJ.png"></p><p><strong>Spring Core</strong></p><p>核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 IoC 依赖注入功能的支持。</p><p><strong>Spring Aspects</strong></p><p>该模块为与 AspectJ 的集成提供支持。</p><p><strong>Spring AOP</strong></p><p>提供了面向切面的编程实现。</p><p><strong>Spring Data Access&#x2F;Integration ：</strong></p><p>Spring Data Access&#x2F;Integration 由 5 个模块组成：</p><ul><li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>spring-tx : 提供对事务的支持。</li><li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li><li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li><li>spring-jms : Java 消息服务。</li></ul><p><strong>Spring Web</strong></p><p>Spring Web 由 4 个模块组成：</p><ul><li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li><li>spring-webmvc ： 提供对 Spring MVC 的实现。</li><li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li></ul><p><strong>Spring Test</strong></p><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="Spring启动过程"><a href="#Spring启动过程" class="headerlink" title="Spring启动过程"></a>Spring启动过程</h3><ol><li>读取web.xml文件。</li><li>创建 ServletContext，为 ioc 容器提供宿主环境。</li><li>触发容器初始化事件，调用 contextLoaderListener.contextInitialized()方法，在这个方法会初始化一个应用上下文WebApplicationContext，即 Spring 的 ioc 容器。ioc 容器初始化完成之后，会被存储到 ServletContext 中。</li><li>初始化web.xml中配置的Servlet。如DispatcherServlet，用于匹配、处理每个servlet请求。</li></ol><h3 id="Spring-用到了哪些设计模式？"><a href="#Spring-用到了哪些设计模式？" class="headerlink" title="Spring 用到了哪些设计模式？"></a>Spring 用到了哪些设计模式？</h3><p>1、<strong>简单工厂模式</strong>：<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>工厂方法模式</strong>：<code>FactoryBean</code>就是典型的工厂方法模式。spring在使用<code>getBean()</code>调用获得该bean时，会自动调用该bean的<code>getObject()</code>方法。每个 Bean 都会对应一个 <code>FactoryBean</code>，如 <code>SqlSessionFactory</code> 对应 <code>SqlSessionFactoryBean</code>。</p><p>3、<strong>单例模式</strong>：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p><p>4、<strong>适配器模式</strong>：SpringMVC中的适配器<code>HandlerAdatper</code>。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p><p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 <code>HandlerAdapter</code> 实现类，当请求过来，SpringMVC会调用<code>getHandler()</code>获取相应的Controller，然后获取该Controller对应的 <code>HandlerAdapter</code>，最后调用<code>HandlerAdapter</code>的<code>handle()</code>方法处理请求，实际上调用的是Controller的<code>handleRequest()</code>。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p><p>常用的处理器适配器：<code>SimpleControllerHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>，<code>AnnotationMethodHandlerAdapter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;<span class="comment">//handler是被适配的对象，这里使用的是对象的适配器模式</span></span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<strong>代理模式</strong>：spring 的 aop 使用了动态代理，有两种方式<code>JdkDynamicAopProxy</code>和<code>Cglib2AopProxy</code>。</p><p>6、<strong>观察者模式</strong>：spring 中 observer 模式常用的地方是 listener 的实现，如<code>ApplicationListener</code>。</p><p>7、<strong>模板模式</strong>： Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等，就使用到了模板模式。</p><h3 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a>Spring框架中有哪些不同类型的事件</h3><p>Spring 提供了以下5种标准的事件：</p><ol><li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li></ol><h2 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h2><h3 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="https://s2.loli.net/2022/03/21/d3PwTSH7WtQo6MY.png"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p><h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><ul><li>IOC 和依赖注入降低了应用的代码量。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使<code>松散耦合</code>得以实现。</li><li>支持加载服务时的饿汉式初始化和懒加载。</li></ul><h3 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h3><p>在Spring创建对象的过程中，把对象依赖的属性注入到对象中。依赖注入主要有两种方式：构造器注入和属性注入。</p><h3 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOC容器初始化过程？"><a href="#IOC容器初始化过程？" class="headerlink" title="IOC容器初始化过程？"></a>IOC容器初始化过程？</h3><ol><li>从XML中读取配置文件。</li><li>将bean标签解析成 BeanDefinition，如解析 property 元素， 并注入到 BeanDefinition 实例中。</li><li>将 BeanDefinition 注册到容器 BeanDefinitionMap 中。</li><li>BeanFactory 根据 BeanDefinition 的定义信息创建实例化和初始化 bean。</li></ol><p>单例bean的初始化以及依赖注入一般都在容器初始化阶段进行，只有懒加载（lazy-init为true）的单例bean是在应用第一次调用getBean()时进行初始化和依赖注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure><p>多例bean 在容器启动时不实例化，即使设置 lazy-init 为 false 也没用，只有调用了getBean()才进行实例化。</p><p><code>loadBeanDefinitions</code>采用了模板模式，具体加载 <code>BeanDefinition</code> 的逻辑由各个子类完成。</p><h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><table><thead><tr><th>构造函数注入</th><th>setter 注入</th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用<strong>构造器参数实现强制依赖，setter方法实现可选依赖</strong>。</p><h2 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h2><h3 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h3><p><strong>面向切面</strong>编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。</p><h3 id="AOP有哪些实现方式？"><a href="#AOP有哪些实现方式？" class="headerlink" title="AOP有哪些实现方式？"></a>AOP有哪些实现方式？</h3><p>AOP有两种实现方式：静态代理和动态代理。</p><p><strong>静态代理</strong></p><p>静态代理：代理类在编译阶段生成，在编译阶段将通知织入Java字节码中，也称<code>编译时增强</code>。AspectJ使用的是静态代理。</p><p>缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。</p><p><strong>动态代理</strong></p><p>动态代理：代理类在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。</p><h3 id="JDK动态代理和CGLIB动态代理的区别？"><a href="#JDK动态代理和CGLIB动态代理的区别？" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别？"></a>JDK动态代理和CGLIB动态代理的区别？</h3><p>Spring AOP中的动态代理主要有两种方式：JDK动态代理和CGLIB动态代理。</p><p><strong>JDK动态代理</strong></p><p>如果目标类实现了接口，Spring AOP会选择使用JDK动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK动态代理的核心是<code>InvocationHandler</code>接口和<code>Proxy</code>类。</p><p>缺点：<strong>目标类必须有实现的接口</strong>。如果某个类没有实现接口，那么这个类就不能用JDK动态代理。</p><p><strong>CGLIB来动态代理</strong></p><p><strong>通过继承实现</strong>。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。</p><p>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为<code>final</code>，那么它是无法使用CGLIB做动态代理的。</p><p>优点：目标类不需要实现特定的接口，更加灵活。</p><p>什么时候采用哪种动态代理？</p><ol><li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</li><li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP</li><li>如果目标对象没有实现了接口，必须采用CGLIB库</li></ol><p><strong>两者的区别</strong>：</p><ol><li>jdk动态代理使用jdk中的类Proxy来创建代理对象，它使用反射技术来实现，不需要导入其他依赖。cglib需要引入相关依赖：<code>asm.jar</code>，它使用字节码增强技术来实现。</li><li>当目标类实现了接口的时候Spring Aop默认使用jdk动态代理方式来增强方法，没有实现接口的时候使用cglib动态代理方式增强方法。</li></ol><h3 id="Spring-AOP相关术语"><a href="#Spring-AOP相关术语" class="headerlink" title="Spring AOP相关术语"></a>Spring AOP相关术语</h3><p>（1）<strong>切面</strong>（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。</p><p>（2）<strong>连接点</strong>（Join point）：指方法，在Spring AOP中，一个连接点总是代表一个方法的执行。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）<strong>通知</strong>（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）<strong>切入点</strong>（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）<strong>引入</strong>（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）<strong>目标对象</strong>（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。</p><p>（7）<strong>织入</strong>（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有以下时间点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul><h3 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知。通知实际上是程序运行时要通过Spring AOP框架来触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ol><li><strong>前置通知</strong>（Before）：在目标方法被调用之前调用通知功能；</li><li><strong>后置通知</strong>（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li><strong>返回通知</strong>（After-returning ）：在目标方法成功执行之后调用通知；</li><li><strong>异常通知</strong>（After-throwing）：在目标方法抛出异常后调用通知；</li><li><strong>环绕通知</strong>（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。</li></ol><h3 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p><p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ul><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ul><p>可以简单地认为, 使用 @Aspect 注解的类就是切面。</p><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="什么是-bean"><a href="#什么是-bean" class="headerlink" title="什么是 bean?"></a>什么是 bean?</h3><p>简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="https://s2.loli.net/2022/03/21/R5Z47G2zx69MUbL.png"></p><p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础。</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><img src="https://s2.loli.net/2022/03/21/Cr5F3ReiwxVo9Kf.png" style="zoom: 80%;" /><p>1.调用bean的构造方法创建Bean</p><p>2.通过反射调用setter方法进行属性的依赖注入</p><p>3.如果Bean实现了<code>BeanNameAware</code>接口，Spring将调用<code>setBeanName</code>()，设置 <code>Bean</code>的name（xml文件中bean标签的id）</p><p>4.如果Bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code>把bean factory设置给Bean</p><p>5.如果Bean实现了<code>ApplicationContextAware</code>接口，Spring容器将调用<code>setApplicationContext()</code>给Bean设置ApplictionContext</p><p>6.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessBeforeInitialization</code>（预初始化）方法，在Bean初始化前对其进行处理</p><p>7.如果Bean实现了<code>InitializingBean</code>接口，Spring将调用它的<code>afterPropertiesSet</code>方法，然后调用xml定义的 init-method 方法，两个方法作用类似，都是在初始化 bean 的时候执行</p><p>8.如果存在<code>BeanPostProcessor</code>，Spring将调用它们的<code>postProcessAfterInitialization</code>（后初始化）方法，在Bean初始化后对其进行处理</p><p>9.Bean初始化完成，供应用使用，直到应用被销毁</p><p>10.如果Bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destory</code>方法，然后调用在xml中定义的 <code>destory-method</code>方法，这两个方法作用类似，都是在Bean实例销毁前执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean-的作用域有哪些"><a href="#bean-的作用域有哪些" class="headerlink" title="bean 的作用域有哪些?"></a>bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例-bean-的线程安全问题"><a href="#单例-bean-的线程安全问题" class="headerlink" title="单例 bean 的线程安全问题"></a>单例 bean 的线程安全问题</h3><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。注解</p><h3 id="BeanFactory和FactoryBean的区别？"><a href="#BeanFactory和FactoryBean的区别？" class="headerlink" title="BeanFactory和FactoryBean的区别？"></a>BeanFactory和FactoryBean的区别？</h3><p><strong>BeanFactory</strong>：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。</p><p><strong>FactoryBean</strong>：通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，直接用xml配置比较麻烦，这时可以考虑用FactoryBean，可以隐藏实例化复杂Bean的细节。</p><p>当配置文件中bean标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是调用FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果想得到FactoryBean必须使用 ‘&amp;’ + beanName 的方式获取。</p><p>Mybatis 提供了 <code>SqlSessionFactoryBean</code>，可以简化 <code>SqlSessionFactory</code>的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">    state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>) || !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">              <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//复杂逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 xml 配置 SqlSessionFactoryBean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tradeSqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;trade&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mapper/trade/*Mapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.bytebeats.mybatis3.domain.trade&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 将会在应用启动时创建 <code>SqlSessionFactory</code>，并使用 <code>sqlSessionFactory</code> 这个名字存储起来。</p><h3 id="Bean注入容器有哪些方式？"><a href="#Bean注入容器有哪些方式？" class="headerlink" title="Bean注入容器有哪些方式？"></a>Bean注入容器有哪些方式？</h3><p>将普通类交给Spring容器管理，通常有以下方法：</p><p>1、使用<code>@Configuration</code>与<code>@Bean</code>注解</p><p>2、使用<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Component</code> 注解标注该类，然后启用<code>@ComponentScan</code>自动扫描</p><p>3、使用<code>@Import</code> 方法。使用@Import注解把bean导入到当前容器中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">/*把用到的资源导入到当前容器中*/</span></span><br><span class="line"><span class="meta">@Import(&#123;Dog.class, Cat.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(App.class, args);</span><br><span class="line">        System.out.println(context.getBean(Dog.class));</span><br><span class="line">        System.out.println(context.getBean(Cat.class));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring自动装配的方式有哪些？"><a href="#Spring自动装配的方式有哪些？" class="headerlink" title="Spring自动装配的方式有哪些？"></a>Spring自动装配的方式有哪些？</h3><p>Spring的自动装配有三种模式：<strong>byType</strong>(根据类型)，<strong>byName</strong>(根据名称)、<strong>constructor</strong>(根据构造函数)。</p><p><strong>byType</strong></p><p>找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</p><p>当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种，此时我们需要为Spring容器提供帮助，指定注入那个Bean实例。可以通过<code>＜bean＞</code>标签的autowire-candidate设置为false来过滤那些不需要注入的实例Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- autowire-candidate=&quot;false&quot; 过滤该类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">autowire-candidate</span>=<span class="string">&quot;false&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- byType 根据类型自动装配userDao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>byName</strong></p><p>将属性名与bean名称进行匹配，如果找到则注入依赖bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>constructor</strong></p><p>存在单个实例则优先按类型进行参数匹配（无论名称是否匹配），当存在多个类型相同实例时，按名称优先匹配，如果没有找到对应名称，则注入失败。</p><h3 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p><p>在启动spring IOC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是基于Java的Spring注解配置"><a href="#什么是基于Java的Spring注解配置" class="headerlink" title="什么是基于Java的Spring注解配置?"></a>什么是基于Java的Spring注解配置?</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StudentBean <span class="title function_">myStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBean</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Component、-Controller、-Repositor和-Service-的区别？"><a href="#Component、-Controller、-Repositor和-Service-的区别？" class="headerlink" title="@Component、@Controller、@Repositor和@Service 的区别？"></a>@Component、@Controller、@Repositor和@Service 的区别？</h3><p>@Component：最普通的组件，可以被注入到spring容器进行管理。</p><p>@Controller：将类标记为 Spring Web MVC 控制器。</p><p>@Service：将类标记为业务层组件。</p><p>@Repository：将类标记为数据访问组件，即DAO组件。</p><h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><h3 id="Autowired和-Resource的区别？"><a href="#Autowired和-Resource的区别？" class="headerlink" title="@Autowired和@Resource的区别？"></a>@Autowired和@Resource的区别？</h3><p>默认情况下@Autowired是按类型匹配的(byType)。如果需要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合。@Autowired 可以传递一个<code>required=false</code>的属性，false指明当userDao实例存在就注入不存就忽略，如果为true，就必须注入，若userDao实例不存在，就抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//标注成员变量</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>@Resource，默认按 byName模式自动注入。@Resource有两个中重要的属性：name和type。Spring容器对于@Resource注解的name属性解析为bean的名字，type属性则解析为bean的类型。因此使用name属性，则按byName模式的自动注入策略，如果使用type属性则按 byType模式自动注入策略。倘若既不指定name也不指定type属性，Spring容器将通过反射技术默认按byName模式注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao  userDao;<span class="comment">//用于成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用于set方法标注</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.userDao= userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器也提供了@Value注入的方式。</p><h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><p>当需要创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，可以使用<code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定应该装配哪个 bean 来消除歧义。</p><h3 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h3><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p><p>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法</p><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="解释对象-x2F-关系映射集成模块"><a href="#解释对象-x2F-关系映射集成模块" class="headerlink" title="解释对象&#x2F;关系映射集成模块"></a>解释对象&#x2F;关系映射集成模块</h3><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h3 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h3><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h3 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h3><ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul><h3 id="Spring-事务实现方式有哪些？"><a href="#Spring-事务实现方式有哪些？" class="headerlink" title="Spring 事务实现方式有哪些？"></a>Spring 事务实现方式有哪些？</h3><p>事务就是一系列的操作原子执行。Spring事务机制主要包括声明式事务和编程式事务。</p><ul><li><strong>编程式事务</strong>：通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li><li><strong>声明式事务</strong>：将事务管理代码从业务方法中分离出来，通过aop进行封装。Spring声明式事务使得我们无需要去处理获得连接、关闭连接、事务提交和回滚等这些操作。使用 <code>@Transactional</code> 注解开启声明式事务。</li></ul><p><code>@Transactional</code>相关属性如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int (in seconds granularity)</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><h3 id="有哪些事务传播行为？"><a href="#有哪些事务传播行为？" class="headerlink" title="有哪些事务传播行为？"></a>有哪些事务传播行为？</h3><p>在TransactionDefinition接口中定义了七个事务传播行为：</p><ol><li><code>PROPAGATION_REQUIRED</code>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。如果嵌套调用的两个方法都加了事务注解，并且运行在相同线程中，则这两个方法使用相同的事务中。如果运行在不同线程中，则会开启新的事务。</li><li><code>PROPAGATION_SUPPORTS</code> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</li><li><code>PROPAGATION_MANDATORY</code> 如果已经存在一个事务，支持当前事务。如果不存在事务，则抛出异常<code>IllegalTransactionStateException</code>。</li><li><code>PROPAGATION_REQUIRES_NEW</code> 总是开启一个新的事务。需要使用JtaTransactionManager作为事务管理器。</li><li><code>PROPAGATION_NOT_SUPPORTED</code> 总是非事务地执行，并挂起任何存在的事务。需要使用JtaTransactionManager作为事务管理器。</li><li><code>PROPAGATION_NEVER</code> 总是非事务地执行，如果存在一个活动事务，则抛出异常。</li><li><code>PROPAGATION_NESTED</code> 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务, 则按PROPAGATION_REQUIRED 属性执行。</li></ol><p><strong>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</strong></p><p>使用<code>PROPAGATION_REQUIRES_NEW</code>时，内层事务与外层事务是两个独立的事务。一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。</p><p>使用<code>PROPAGATION_NESTED</code>时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。</p><h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line"></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Isolation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>下面我依次对每一种事务隔离级别进行介绍：</p><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h3><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><p>参考文章：</p><p>[1] <a href="https://blog.csdn.net/qq_41701956/article/details/116354268">77道Spring面试题以及参考答案（2021年最新版）_Java程序员-张凯的博客-CSDN博客_spring面试题</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/spring-knowledge-and-questions-summary">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/spring-knowledge-and-questions-summary</a></p><p>[3] <a href="https://github.com/Tyson0314/Java-learning/blob/master/%E6%A1%86%E6%9E%B6/Spring%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/%E6%A1%86%E6%9E%B6/Spring%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-Redis</title>
      <link href="/post/3186528232.html"/>
      <url>/post/3186528232.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><p>Redis（<code>Remote Dictionary Server</code>）是一个使用 C 语言编写的，高性能非关系型的键值对数据库。与传统数据库不同的是，Redis 的数据是存在内存中的，所以读写速度非常快，被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</p><h3 id="Redis优缺点？"><a href="#Redis优缺点？" class="headerlink" title="Redis优缺点？"></a>Redis优缺点？</h3><p><strong>优点</strong>：</p><ol><li><strong>基于内存操作</strong>，内存读写速度快。</li><li>Redis是<strong>单线程</strong>的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。</li><li><strong>支持多种数据类型</strong>，包括String、Hash、List、Set、ZSet等。</li><li><strong>支持持久化</strong>。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。</li><li><strong>支持事务</strong>。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li><strong>支持主从复制</strong>。主节点会自动将数据同步到从节点，可以进行读写分离。</li></ol><p><strong>缺点</strong>：</p><ol><li>对结构化查询的支持比较差。</li><li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ol><h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><ul><li><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li><li><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</li><li><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I&#x2F;O上浪费过多的时间。</li><li><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li></ul><h3 id="Redis为何选择单线程"><a href="#Redis为何选择单线程" class="headerlink" title="Redis为何选择单线程"></a>Redis为何选择单线程</h3><ul><li>避免过多的<strong>上下文切换开销</strong>。程序始终运行在进程中单个线程内，没有多线程切换的场景。</li><li><strong>避免同步机制的开销</strong>：如果 Redis选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，增加程序复杂度的同时还会降低性能。</li><li><strong>实现简单，方便维护</strong>：如果 Redis使用多线程模式，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么 Redis 的实现将会变得更加复杂。</li></ul><h3 id="Redis6-0为何引入多线程？"><a href="#Redis6-0为何引入多线程？" class="headerlink" title="Redis6.0为何引入多线程？"></a>Redis6.0为何引入多线程？</h3><p>Redis支持多线程主要有两个原因：</p><ul><li>可以充分利用服务器 CPU 资源，单线程模型的主线程只能利用一个cpu；</li><li>多线程任务可以分摊 Redis 同步 IO 读写的负荷。</li></ul><h3 id="Memcached和Redis的区别？"><a href="#Memcached和Redis的区别？" class="headerlink" title="Memcached和Redis的区别？"></a>Memcached和Redis的区别？</h3><ol><li>Redis 只使用<strong>单核</strong>，而 Memcached 可以使用多核。</li><li>MemCached 数据结构单一，仅用来缓存数据，而 <strong>Redis 支持多种数据类型</strong>。</li><li>MemCached 不支持数据持久化，重启后数据会消失。<strong>Redis 支持数据持久化</strong>。</li><li><strong>Redis 提供主从同步机制和 cluster 集群部署能力</strong>，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。</li><li>Redis 的速度比 Memcached 快很多。</li><li>Redis 使用<strong>单线程的多路 IO 复用模型</strong>，Memcached使用多线程的非阻塞 IO 模型。</li></ol><h3 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="Redis 是如何判断数据是否过期的呢？"></a>Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><img src="https://s2.loli.net/2022/03/19/PselVBf12iXZzE4.png" style="zoom:33%;" /><h3 id="Redis-通讯协议是什么？有什么特点？"><a href="#Redis-通讯协议是什么？有什么特点？" class="headerlink" title="Redis 通讯协议是什么？有什么特点？"></a>Redis 通讯协议是什么？有什么特点？</h3><p> Redis 的通信协议是 Redis Serialization Protocol，简称 RESP。 有如下特性： </p><ul><li>是二进制安全的 </li><li>在 TCP 层 </li><li>基于请求—响应的模式</li></ul><h2 id="数据结构与指令"><a href="#数据结构与指令" class="headerlink" title="数据结构与指令"></a>数据结构与指令</h2><h3 id="Redis-数据类型有哪些？"><a href="#Redis-数据类型有哪些？" class="headerlink" title="Redis 数据类型有哪些？"></a>Redis 数据类型有哪些？</h3><p><strong>基本数据类型</strong>：</p><p>1、<strong>String</strong>：最常用的一种数据类型，String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。</p><blockquote><p>常用命令：set, get, incr, incrby, desr, keys, append, strlen</p></blockquote><p>2、<strong>Hash</strong>：Hash 是一个键值对集合。</p><blockquote><p>常用命令：hset, hget, hmset, hmget, hgetall, hdel, hkeys, hvals</p></blockquote><p>3、<strong>Set</strong>：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。</p><blockquote><p>常用命令：sadd, srem, smembers, scard, sismember, sdiff</p></blockquote><p>4、<strong>List</strong>：有序可重复的集合，底层是依赖双向链表实现的。</p><blockquote><p>常用命令：lpush, rpush, lpop, rpop, lrange, lrem</p></blockquote><p>5、<strong>SortedSet</strong>：有序Set。内部维护了一个<code>score</code>的参数来实现。适用于排行榜和带权重的消息队列等场景。</p><blockquote><p>常用命令：zadd, zrem, zscore, zrange</p></blockquote><p><strong>特殊的数据类型</strong>：</p><p>1、<strong>Bitmap</strong>：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。Bitmap的长度与集合中元素个数无关，而是与基数的上限有关。</p><p>2、<strong>Hyperloglog</strong>。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。</p><p>3、<strong>Geospatial</strong> ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h4><p>SDS定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>C 字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为 O(N) 。</td><td>获取字符串长度的复杂度为 O(1) 。</td></tr><tr><td>API 是不安全的，可能会造成缓冲区溢出。</td><td>API 是安全的，不会造成缓冲区溢出。</td></tr><tr><td>修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td><td>修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。</td></tr><tr><td>只能保存文本数据。</td><td>可以保存文本或者二进制数据。</td></tr><tr><td>可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数。</td><td>可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。</td></tr></tbody></table><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典使用hashtable作为底层实现。键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>ziplist是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。 节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度。有两种编码方式，字节数组编码和整数编码。</p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳表可以看成多层链表，它有如下的性质：</p><ul><li>多层的结构组成，每层是一个有序的链表</li><li>最底层的链表包含所有的元素</li><li>跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)</li></ul><p><img src="https://s2.loli.net/2022/03/19/Nkq2GvzFBcETXDu.png"></p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串对象的编码可以是 int 、 raw 或者 embstr 。</p><ol><li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么会将编码设置为 int 。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li></ol><table><thead><tr><th>值</th><th>编码</th></tr></thead><tbody><tr><td>可以用 <code>long</code> 类型保存的整数。</td><td><code>int</code></td></tr><tr><td>可以用 <code>long double</code> 类型保存的浮点数。</td><td><code>embstr</code> 或者 <code>raw</code></td></tr><tr><td>字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td><td><code>embstr</code> 或者 <code>raw</code></td></tr></tbody></table><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>hash类型内部编码有两种：</p><ol><li>ziplist，压缩列表。当哈希类型元素个数小于512个，并且所有值都小于64字节时，Redis会使用ziplist作为哈希的内部实现。ziplist使用更加紧凑的结构实现多个元素的连续存储，更加节省内存。</li><li>hashtable。当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</li></ol><p>使用 ziplist 作为 hash 的底层实现时，添加元素的时候，同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后。</p><p>使用场景：记录博客点赞数量。<code>hset MAP_BLOG_LIKE_COUNT blogId likeCount</code>，key为MAP_BLOG_LIKE_COUNT，field为博客id，value为点赞数量。</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>列表list类型内部编码有两种：</p><ol><li>ziplist，压缩列表。当列表中的元素个数小于512个，同时列表中每个元素的值都小于64字节时，Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li><li>当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li></ol><p>Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现。</p><p><img src="https://s2.loli.net/2022/03/19/WmfSlNUaopEgzBO.png"></p><p>使用场景：</p><p>消息队列。Redis的lpush+brpop命令组合即可实现阻塞队列。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>集合对象的编码可以是 intset 或者 hashtable 。</p><ol><li>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合（数组）里面。</li><li>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 而字典的值则全部被设置为 NULL 。</li></ol><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>有序集合的编码可以是 ziplist 或者 skiplist 。当有序集合的元素个数小于128，同时每个元素的值都小于64字节时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。否则，使用skiplist作为有序集合的内部实现。</p><ol><li>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序。</li><li>skiplist 编码的有序集合对象使用字典和跳跃表实现。使用字典查找给定成员的分值，时间复杂度为O(1) （跳跃表查找时间复杂度为O(logN)）。使用跳跃表可以对有序集合进行范围型操作。</li></ol><h3 id="设置键的生存时间和过期时间有哪些命令？"><a href="#设置键的生存时间和过期时间有哪些命令？" class="headerlink" title="设置键的生存时间和过期时间有哪些命令？"></a>设置键的生存时间和过期时间有哪些命令？</h3><ul><li><p>EXPIRE 以秒为单位，设置键的生存时间 </p></li><li><p>PEXPIRE 以毫秒为单位，设置键的生存时间 </p></li><li><p>EXPIREAT 以秒为单位，设置键的过期 UNIX 时间戳 </p></li><li><p>PEXPIREAT 以毫秒为单位，设置键的过期 UNIX 时间戳</p></li></ul><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一个<strong>不存在的数据</strong>，由于缓存是不命中时被动写的，如果从DB查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。</p><ol><li><strong>缓存空值</strong>，不会查数据库。</li><li>采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的<code>bitmap</code>中，查询不存在的数据会被这个<code>bitmap</code>拦截掉，从而避免了对<code>DB</code>的查询压力。</li></ol><p>布隆过滤器的原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。查询时，将元素通过散列函数映射之后会得到k个点，如果这些点有任何一个0，则被检元素一定不在，直接返回；如果都是1，则查询元素很可能存在，就会去查询Redis和数据库。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，<strong>导致缓存在某一时刻同时失效</strong>，请求全部转发到DB，DB瞬时压力过重挂掉。</p><p>解决方法：在原有的失效时间基础上<strong>增加一个随机值</strong>，使得过期时间分散一些。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。<strong>缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。</strong></p><p>解决方法：加分布式锁，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待50ms然后重新到缓存取数据，这样便可以避免大量的请求落到数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//缓存值过期</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unique_key</span> <span class="operator">=</span> systemId + <span class="string">&quot;:&quot;</span> + key;</span><br><span class="line">        <span class="comment">//设置30s的超时</span></span><br><span class="line">        <span class="keyword">if</span> (redis.set(unique_key, <span class="number">1</span>, <span class="string">&#x27;NX&#x27;</span>, <span class="string">&#x27;PX&#x27;</span>, <span class="number">30000</span>) == <span class="number">1</span>) &#123;  <span class="comment">//设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(unique_key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他线程已经到数据库取值并回写到缓存了，可以重试获取缓存值</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h3><ul><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ul><h3 id="缓存的更新策略有几种？分别有什么注意事项？"><a href="#缓存的更新策略有几种？分别有什么注意事项？" class="headerlink" title="缓存的更新策略有几种？分别有什么注意事项？"></a>缓存的更新策略有几种？分别有什么注意事项？</h3><p><strong>策略一：先更新数据库，再更新缓存</strong> </p><ul><li><p>这种策略会导致线程安全问题</p><blockquote><p>例如：线程 1 更新了数据库，线程 2 也更新数据库， 这时候由于某种原因，线程 2 首先更新了缓存，线程 1 后续更新。 这样就导致了脏数据的问题。 因为目前数据库中存储的线程 2 更新后的数据，而缓存存储的是线程 1 更新的老数据。 </p></blockquote></li><li><p>更新缓存的复杂度相对较高 </p><blockquote><p>数据写入数据库之后，一般存入缓存的数据都要经过一系列的加工计算，然后写入缓存。 这时候更新缓存相比较于直接删除缓存要比较复杂。</p></blockquote></li></ul><p><strong>策略二：先删除缓存，再更新数据库</strong> </p><p>这种策略可能导致数据不一致的问题。线程 1 写数据删除缓存；这时候有线程 2 查询该缓存，发现不存在，则去访问数据库，得到旧值放入缓存；线程 1 更新数据库。这时候就出现了数据不一致的问题。 如果缓存没有过期时间，这个脏数据一直存在。 </p><p>解决方案：在写数据库成功之后， 再次淘汰缓存一次。 </p><p><strong>策略三：先更新数据库，再删除缓存</strong> </p><p>可能会造成比较短暂的数据不一致。在更新完成数据库， 还没有删除缓存的时刻，如果有缓存数据访问， 就会造成数据不一致的情形。 但这种如果数据同步机制比较科学，一般都会比较快， 不一致的影响比较小。</p><h3 id="可能导致-Redis-阻塞的原因"><a href="#可能导致-Redis-阻塞的原因" class="headerlink" title="可能导致 Redis 阻塞的原因"></a>可能导致 Redis 阻塞的原因</h3><p><strong>内部原因：</strong> </p><ul><li>Redis 的 API 或者指令数据结构使用不合理</li><li>Redis 主机 CPU 负载过高，导致系统崩溃 </li><li>持久化工作资源占用过多</li></ul><p> <strong>外部原因：</strong> </p><ul><li>CPU 竞争 </li><li>内存交换 </li><li>网络问题</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Redis-集群架构模式有哪几种？"><a href="#Redis-集群架构模式有哪几种？" class="headerlink" title="Redis 集群架构模式有哪几种？"></a>Redis 集群架构模式有哪几种？</h3><ul><li>Redis 单节点单机器部署</li><li>Redis 主从节点部署</li><li>Redis Sentinel（哨兵）模式部署</li><li>Redis 集群模式</li></ul><p><strong>使用场景</strong>：</p><p>单机版：很少使用。存在的问题：1、内存容量有限 2、处理能力有限 3、无法高可用。</p><p>主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p><p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p><p>Redis cluster：主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有主节点的容量总和就是Redis cluster可缓存的数据容量。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis的复制功能是支持多个数据库之间的数据同步。主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server //启动Redis实例作为主数据库 </span><br><span class="line">redis-server --port 6380 --slaveof  127.0.0.1 6379  //启动另一个实例作为从数据库 </span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">SLAVEOF NO ONE //停止接收其他数据库的同步并转化为主数据库。</span><br></pre></td></tr></table></figure><p><strong>主从复制的原理？</strong></p><ol><li>当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点；</li><li>如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件；</li><li>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>；</li><li>接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；</li><li>如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。</li></ol><h3 id="哨兵Sentinel"><a href="#哨兵Sentinel" class="headerlink" title="哨兵Sentinel"></a>哨兵Sentinel</h3><p>主从复制存在不能自动故障转移、达不到高可用的问题。哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。</p><p>客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。</p><img src="https://s2.loli.net/2022/03/19/yVgnG5vI7321FLr.png"  /><p><strong>工作原理</strong></p><ul><li>每个<code>Sentinel</code>以每秒钟一次的频率向它所知道的<code>Master</code>，<code>Slave</code>以及其他 <code>Sentinel </code>实例发送一个 <code>PING</code>命令。</li><li>如果一个实例距离最后一次有效回复 <code>PING</code> 命令的时间超过指定值， 则这个实例会被 <code>Sentine</code> 标记为主观下线。</li><li>如果一个<code>Master</code>被标记为主观下线，则正在监视这个<code>Master</code>的所有 <code>Sentinel </code>要以每秒一次的频率确认<code>Master</code>是否真正进入主观下线状态。</li><li>当有足够数量的 <code>Sentinel</code>（大于等于配置文件指定值）在指定的时间范围内确认<code>Master</code>的确进入了主观下线状态， 则<code>Master</code>会被标记为客观下线 。若没有足够数量的 <code>Sentinel </code>同意 <code>Master</code> 已经下线， <code>Master</code> 的客观下线状态就会被解除。 若 <code>Master</code>重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回有效回复， <code>Master</code> 的主观下线状态就会被移除。</li><li>哨兵节点会选举出哨兵 leader，负责故障转移的工作。</li><li>哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。</li></ul><h3 id="Redis-cluster"><a href="#Redis-cluster" class="headerlink" title="Redis cluster"></a>Redis cluster</h3><p>哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而cluster模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。</p><p>Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis cluster采用<strong>虚拟槽分区</strong>，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据。</p><p><img src="https://s2.loli.net/2022/03/19/RJe6XKBDHISCp8j.png"></p><p><strong>哈希槽是如何映射到 Redis 实例上的？</strong></p><ol><li>对键值对的<code>key</code>使用 <code>crc16</code> 算法计算一个结果</li><li>将结果对 16384 取余，得到的值表示 <code>key</code> 对应的哈希槽</li><li>根据该槽信息定位到对应的实例</li></ol><p><strong>优点：</strong></p><ul><li>无中心架构，<strong>支持动态扩</strong>容；</li><li>数据按照<code>slot</code>存储分布在多个节点，节点间数据共享，<strong>可动态调整数据分布</strong>；</li><li><strong>高可用性</strong>。部分节点不可用时，集群仍可用。集群模式能够实现自动故障转移（failover），节点之间通过<code>gossip</code>协议交换状态信息，用投票机制完成<code>Slave</code>到<code>Master</code>的角色转换。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>不支持批量操作</strong>（pipeline）。</li><li>数据通过异步复制，<strong>不保证数据的强一致性</strong>。</li><li><strong>事务操作支持有限</strong>，只支持多<code>key</code>在同一节点上的事务操作，当多个<code>key</code>分布于不同的节点上时无法使用事务功能。</li><li><code>key</code>作为数据分区的最小粒度，不能将一个很大的键值对象如<code>hash</code>、<code>list</code>等映射到不同的节点。</li><li><strong>不支持多数据库空间</strong>，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间。</li></ul><h3 id="哈希分区算法有哪些？"><a href="#哈希分区算法有哪些？" class="headerlink" title="哈希分区算法有哪些？"></a>哈希分区算法有哪些？</h3><p><strong>节点取余分区</strong></p><p>使用特定的数据，如Redis的键或用户ID，对节点数量N取余：hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。 优点是简单性。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。</p><p><strong>一致性哈希分区</strong></p><p>为系统中每个节点分配一个token，范围一般在0~232，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。 这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。</p><p><strong>虚拟槽分区</strong></p><p>所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot&#x3D;CRC16（key）&amp;16383。每一个节点负责维护一部分槽以及槽所映射的键值数据。<strong>Redis Cluser采用虚拟槽分区算法。</strong></p><h3 id="Redis-集群最大节点个数是多少？"><a href="#Redis-集群最大节点个数是多少？" class="headerlink" title="Redis 集群最大节点个数是多少？"></a>Redis 集群最大节点个数是多少？</h3><p>16384 个</p><h3 id="如何优化-Redis-服务的性能？"><a href="#如何优化-Redis-服务的性能？" class="headerlink" title="如何优化 Redis 服务的性能？"></a>如何优化 Redis 服务的性能？</h3><ul><li>Master 节点禁止持久化工作 </li><li>持久化策略要有正确的选择，关键数据可以采用 slave 节点 AOF 备份 </li><li>主从节点部署在同一个局域网内，保证复制速度与稳定性  设置或者增加从库需要考虑主库现有的压力 </li><li>主从复制一定要单向结构，避免使用图状结构</li></ul><h2 id="缓存管理与持久化"><a href="#缓存管理与持久化" class="headerlink" title="缓存管理与持久化"></a>缓存管理与持久化</h2><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止服务宕机导致内存数据丢失。</p><p>Redis支持两种方式的持久化，一种是<code>RDB</code>的方式，一种是<code>AOF</code>的方式。<strong>前者会根据指定的规则定时将内存中的数据存储在硬盘上</strong>，而<strong>后者在每次执行完命令后将命令记录下来</strong>。一般将两者结合使用。</p><h4 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h4><p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p><p><code>bgsave</code>是主流的触发 RDB 持久化的方式，执行过程如下：</p><img src="https://s2.loli.net/2022/03/19/6SaoV92zIrACxLN.png" style="zoom:80%;" /><ul><li>执行<code>BGSAVE</code>命令</li><li>Redis 父进程判断当前<strong>是否存在正在执行的子进程</strong>，如果存在，<code>BGSAVE</code>命令直接返回。</li><li>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。</li><li>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>；</li><li>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</li></ul><p>Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。</p><p>触发 RDB 持久化的方式：</p><ol><li><strong>手动触发</strong>：用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。<code>SAVE</code>命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。<code>BGSAVE</code>命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用<code>BGSAVE</code>命令。</li><li><strong>被动触发</strong>：<ul><li>根据配置规则进行自动快照，如<code>SAVE 100 10</code>，100秒内至少有10个键被修改则进行快照。</li><li>如果从节点执行全量复制操作，主节点会自动执行<code>BGSAVE</code>生成 RDB 文件并发送给从节点。</li><li>默认情况下执行<code>shutdown</code>命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。</li></ul></li></ol><p><strong>优点</strong>：</p><ol><li><strong>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</strong>。</li><li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>RDB方式数据无法做到实时持久化</strong>。因为<code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</li><li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li></ol><h4 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p><p>默认情况下Redis没有开启AOF方式的持久化，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code>。开启AOF方式持久化后每执行一条写命令，Redis就会将该命令写进<code>aof_buf</code>缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>默认情况下系统<strong>每30秒</strong>会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过<code>appendfsync</code>参数设置同步的时机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always //每次写入aof文件都会执行同步，最安全最慢，不建议配置</span><br><span class="line">appendfsync everysec  //既保证性能也保证安全，建议配置</span><br><span class="line">appendfsync no //由操作系统决定何时进行同步操作</span><br></pre></td></tr></table></figure><p>接下来看一下 AOF 持久化执行流程：</p><p><img src="https://s2.loli.net/2022/03/19/FuZWDcvS8jE271b.png"></p><ol><li>所有的写入命令会追加到 AOP 缓冲区中。</li><li>AOF 缓冲区根据对应的策略向硬盘同步。</li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li><li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li></ol><p><strong>优点</strong>：</p><ol><li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li><li>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高。</li></ol><p><strong>缺点</strong>：</p><ol><li>对于同一份文件AOF文件比RDB数据快照要大。</li><li>数据恢复比较慢。</li></ol><h3 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h3><p>通常来说，应该同时使用两种持久化方案，以保证数据安全。</p><ul><li>如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。</li><li>如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。</li><li>如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。</li><li>如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。</li></ul><p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</p><h3 id="过期键的删除策略？"><a href="#过期键的删除策略？" class="headerlink" title="过期键的删除策略？"></a>过期键的删除策略？</h3><p>1、<strong>被动删除</strong>。在访问key时，如果发现key已经过期，那么会将key删除。</p><p>2、<strong>主动删除</strong>。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。</p><p>3、<strong>内存不够时清理</strong>。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。</p><h3 id="内存淘汰策略有哪些？"><a href="#内存淘汰策略有哪些？" class="headerlink" title="内存淘汰策略有哪些？"></a>内存淘汰策略有哪些？</h3><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器正常运行。</p><p><strong>Redisv4.0前提供 6 种数据淘汰策略</strong>：</p><ul><li><strong>volatile-lru</strong>：LRU（<code>Least Recently Used</code>），最近使用。利用LRU算法移除设置了过期时间的key</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的key</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</li><li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错</li></ul><p><strong>Redisv4.0后增加以下两种</strong>：</p><ul><li><strong>volatile-lfu</strong>：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的key。</li></ul><p><strong>内存淘汰策略可以通过配置文件来修改</strong>，相应的配置项是<code>maxmemory-policy</code>，默认配置是<code>noeviction</code>。</p><h3 id="Redis-缓存失效策略有哪些？"><a href="#Redis-缓存失效策略有哪些？" class="headerlink" title="Redis 缓存失效策略有哪些？"></a>Redis 缓存失效策略有哪些？</h3><p><strong>定时删除策略</strong> </p><p>在设置 key 的过期时间的同时，为该 key 创建一个定时器，让定时器在 key 的过期时间来临时，对 key 进行删除。 </p><ul><li><p>优点：保证内存尽快释放。 </p></li><li><p>缺点：若 key 过多，删除这些 key 会占用很多 CPU 时间， 而且每个 key 创建一个定时器，性能影响严重。</p></li></ul><p><strong>惰性删除策略</strong> </p><p>key 过期的时候不删除，每次从数据库获取 key 的时候去检查是否过期，若过期，则删除，返回 null。 </p><ul><li><p>优点：CPU 时间占用比较少。 </p></li><li><p>缺点：若 key 很长时间没有被获取， 将不会被删除，可能造成内存泄露。</p></li></ul><p> <strong>定期删除策略</strong> </p><p>每隔一段时间执行一次删除（在 redis.conf 配置文件设置 hz，1s 刷新的频率）过期 key 操作。 </p><ul><li><p>优点：可以控制删除操作的时长和频率，来减少 CPU 时间占用，可以避免惰性删除时候内存泄漏的问题。 </p></li><li><p>缺点：对内存友好方面，不如定时策略；对 CPU 友好方面，不如惰性策略</p></li></ul><p> <strong>Redis 一般采用：惰性策略 + 定期策略两个相结合。</strong></p><h3 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h3><h4 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h4><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h4 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h4><p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p><p>因此，我们应该尽量避免写入 bigkey！</p><h4 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h4><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p><p><strong>2、分析 RDB 文件</strong></p><p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p>网上有现成的代码&#x2F;工具可以直接拿来使用：</p><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">redis-rdb-tools</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li><a href="https://github.com/weiyanwei412/rdb_bigkeys">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h3><p>相信大家对程序中的锁并不陌生，无论是在并发编程或者Java虚拟机都有学到过。</p><p>锁在程序中的作用主要是同步，就是保证共享资源在同一时刻只能被同一个线程访问。</p><p>分布式锁则是为了保证在分布式场景下，共享资源在同一时刻只能被同一个线程访问，或者说是用来控制分布式系统之间同步访问共享资源。</p><p>作者：路人zhang<br>链接：<a href="https://www.nowcoder.com/discuss/838039?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=00F3D909A06079CB721845698BB46931-1647671372425">https://www.nowcoder.com/discuss/838039?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=00F3D909A06079CB721845698BB46931-1647671372425</a><br>来源：牛客网</p><h3 id="分布式锁具有哪些特性？"><a href="#分布式锁具有哪些特性？" class="headerlink" title="分布式锁具有哪些特性？"></a>分布式锁具有哪些特性？</h3><ul><li>互斥性：在任意时刻，同一条数据只能被一台机器上的一个线程执行 </li><li>高可用性：当部分节点宕机后，客户端仍可以正常地获取锁和释放锁 </li><li>独占性：加锁和解锁必须同一台服务器执行，不能在一个服务器上加锁，在另一个服务器上释放锁 </li><li>防锁超时：如果客户端没有主动释放锁，服务器会在一定时间后自动释放锁， 防止客户端宕机或者网络异常导致宕机</li></ul><h3 id="分布式锁的实现方法？"><a href="#分布式锁的实现方法？" class="headerlink" title="分布式锁的实现方法？"></a>分布式锁的实现方法？</h3><p>基本思路就是要在整个系统中提供一个<strong>全局、唯一</strong>的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p><p>常见的分布式锁实现方案有三种：</p><p><strong>基于关系型数据库</strong>：</p><p><strong>优点</strong>：直接借助数据库容易理解</p><p><strong>缺点</strong>： 在使用关系型数据库实现分布式锁的过程中会出现各种问题，例如数据库单点问题和可重入问题，并且在解决过程中会使得整个方案越来越复杂</p><p><strong>基于Redis</strong>：</p><p><strong>优点：</strong>性能好，实现起来较为方便</p><p><strong>缺点</strong>：</p><ul><li>key的过期时间设置难以确定，如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。 </li><li>Redis的集群部署虽然能解决单点问题，但是并不是强一致性的，锁的不够健壮</li></ul><p><strong>基于zookeeper</strong>：</p><p><strong>优点</strong>：有效地解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题，实现起来较为简单。</p><p><strong>缺点：</strong>性能上不如使用缓存实现分布式锁</p><p>三种方案的对比</p><table><thead><tr><th>方案</th><th>复杂度</th><th>性能</th><th>可靠性</th><th>学习成本</th></tr></thead><tbody><tr><td>基于关系型数据库</td><td>低</td><td>低</td><td>低</td><td>低</td></tr><tr><td>基于Redis</td><td>中</td><td>高</td><td>中</td><td>中</td></tr><tr><td>基于zookeeper</td><td>高</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><h3 id="Redis-怎么实现分布式锁？"><a href="#Redis-怎么实现分布式锁？" class="headerlink" title="Redis 怎么实现分布式锁？"></a>Redis 怎么实现分布式锁？</h3><p><strong>简单方案：</strong> </p><p>最简单的方法是使用 setnx 命令。释放锁的最简单方式是执行 del 指令。 </p><p><strong>问题：</strong> </p><p>锁超时：如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住（死锁），别的线程再也别想进来。<br><strong>优化方案：</strong> </p><p>setnx 没办法设置超时时间，如果利用 expire 来设置超时时间，那么这两步操作不是原子性操作。 </p><p>利用 set 指令增加了可选参数方式来替代 setnx。set 指令可以设置超时时间。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="Redis-事务相关命令有哪些？"><a href="#Redis-事务相关命令有哪些？" class="headerlink" title="Redis 事务相关命令有哪些？"></a>Redis 事务相关命令有哪些？</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;ZLF&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;ZLF&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <a href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令将执行所有命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;ZLF&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; WATCH USER</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">&gt; SET USER <span class="string">&quot;ZLF&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">ZLF</span><br><span class="line">&gt; EXEC</span><br><span class="line">ERR EXEC without MULTI</span><br></pre></td></tr></table></figure><h3 id="Redis-事务的注意点有哪些？"><a href="#Redis-事务的注意点有哪些？" class="headerlink" title="Redis 事务的注意点有哪些？"></a>Redis 事务的注意点有哪些？</h3><ul><li>不支持回滚，如果事务中有错误的操作，无法回滚到处理前的状态，需要开发者处理。</li><li>在执行完当前事务内所有指令前，不会同时执行其他客户端的请求。</li></ul><h3 id="Redis-为什么不支持回滚？"><a href="#Redis-为什么不支持回滚？" class="headerlink" title="Redis 为什么不支持回滚？"></a>Redis 为什么不支持回滚？</h3><ul><li>只有语法错误，Redis 才会执行失败，例如错误类型的赋值， 这就是说从程序层面完全可以捕获以及解决这些问题</li><li>支持回滚需要增加很多工作，不支持的情况下，Redis 可以保持简单、速度快的特性</li></ul><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E6%80%BB%E7%BB%93.md">https://github.com/Tyson0314/Java-learning/blob/master/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E6%80%BB%E7%BB%93.md</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/redis">https://snailclimb.gitee.io/javaguide/#/docs/database/redis</a></p><p>[3] <a href="https://www.nowcoder.com/discuss/629878">https://www.nowcoder.com/discuss/629878</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-MySQL</title>
      <link href="/post/3310093647.html"/>
      <url>/post/3310093647.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="和为关系型数据库？"><a href="#和为关系型数据库？" class="headerlink" title="和为关系型数据库？"></a>和为关系型数据库？</h3><p>顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p><img src="https://s2.loli.net/2022/03/21/hBQZvLTPKINMdGO.png"></p><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><p>MySQL主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。 </li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。</li></ul><p><strong>Server 层基本组件</strong></p><ul><li><strong>连接器：</strong> 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。 </li><li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。 </li><li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。 </li><li><strong>优化器：</strong> 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。 </li><li><strong>执行器：</strong> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</li></ul><h3 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h3><p><strong>第一范式1NF</strong></p><p>确保数据库表字段的原子性。</p><p>比如字段 <code>userInfo</code>: <code>广东省 10086&#39;</code> ，依照第一范式必须拆分成 <code>userInfo</code>: <code>广东省</code> <code>userTel</code>:<code>10086</code>两个字段。</p><p><strong>第二范式2NF</strong></p><p>首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><p>举个例子。假定选课关系表为<code>student_course</code>(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。</p><p>可以拆分成三个表：学生：<code>student</code>(stuent_no, student_name, 年龄)；课程：<code>course</code>(course_name, credit)；选课关系：<code>student_course_relation</code>(student_no, course_name, grade)。</p><p><strong>第三范式3NF</strong></p><p>首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><p>假定学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为”学号”，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。</p><p>可以把学生关系表分为如下两个表：学生：(student_no, student_name, age, academy_id)；学院：(academy_id, academy_telephone)。</p><p><strong>2NF和3NF的区别？</strong></p><ul><li>2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。 </li><li>3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</li></ul><h3 id="查询语句执行流程"><a href="#查询语句执行流程" class="headerlink" title="查询语句执行流程"></a>查询语句执行流程</h3><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p><p>举个例子，查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &gt; 1 and name = &#x27;ZLF&#x27;;</span><br></pre></td></tr></table></figure><ol><li>首先检验权限，没有权限则返回错误； </li><li>MySQL8.0以前会查询缓存，缓存命中则直接返回，没有则执行下一步； </li><li>词法分析和语法分析。提取表名、查询条件，检查语法是否有错误； </li><li>两种执行方案，先查 <code>id &gt; 1</code> 还是 <code>name = &#39;ZLF&#39;</code>，优化器根据自己的优化算法选择执行效率最好的方案； </li><li>校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。</li></ol><h3 id="更新语句执行流程"><a href="#更新语句执行流程" class="headerlink" title="更新语句执行流程"></a>更新语句执行流程</h3><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、<code>redo log</code>（<code>prepare</code>状态）、<code>binlog</code>、<code>redo log</code>（<code>commit</code>状态）</p><p>举个例子，更新语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set name = &#x27;ZLF&#x27; where id = 1;</span><br></pre></td></tr></table></figure><ol><li>先查询到 id 为1的记录，有缓存会使用缓存。 </li><li>拿到查询结果，将 name 更新为大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录<code>redo log</code>，此时<code>redo log</code>进入 <code>prepare</code>状态。 </li><li>执行器收到通知后记录<code>binlog</code>，然后调用引擎接口，提交<code>redo log</code>为<code>commit</code>状态。 </li><li>更新完成。</li></ol><h3 id="exist和in的区别？"><a href="#exist和in的区别？" class="headerlink" title="exist和in的区别？"></a>exist和in的区别？</h3><p><code>exists</code>用于对外表记录做筛选。<code>exists</code>会遍历外表，将外查询表的每一行，代入内查询进行判断。当<code>exists</code>里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果<code>exists</code>里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.* from A awhere exists(select 1 from B b where a.id=b.id)</span><br></pre></td></tr></table></figure><p><code>in</code>是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from Awhere id in(select id from B)</span><br></pre></td></tr></table></figure><p><strong>子查询的表比较大的时候</strong>，使用<code>exists</code>可以有效减少总的循环次数来提升速度；<strong>当外查询的表比较大的时候</strong>，使用<code>in</code>可以有效减少对外查询表循环遍历来提升速度。</p><h3 id="MySQL中int-10-和char-10-的区别？"><a href="#MySQL中int-10-和char-10-的区别？" class="headerlink" title="MySQL中int(10)和char(10)的区别？"></a>MySQL中int(10)和char(10)的区别？</h3><p>int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。</p><h3 id="truncate、delete与drop区别？"><a href="#truncate、delete与drop区别？" class="headerlink" title="truncate、delete与drop区别？"></a>truncate、delete与drop区别？</h3><p><strong>相同点：</strong></p><ol><li><code>truncate</code>和不带<code>where</code>子句的<code>delete</code>、以及<code>drop</code>都会删除表内的数据。</li><li><code>drop</code>、<code>truncate</code>都是<code>DDL</code>语句（数据定义语言），执行后会自动提交。</li></ol><p><strong>不同点：</strong></p><ol><li>truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引； </li><li>一般来说，执行速度: drop &gt; truncate &gt; delete。</li></ol><h3 id="having和where区别？"><a href="#having和where区别？" class="headerlink" title="having和where区别？"></a>having和where区别？</h3><ul><li>二者作用的对象不同，<code>where</code>子句作用于表和视图，<code>having</code>作用于组。</li><li><code>where</code>在数据分组前进行过滤，<code>having</code>在数据分组后进行过滤。</li></ul><h3 id="processlist"><a href="#processlist" class="headerlink" title="processlist"></a>processlist</h3><p><code>show processlist</code> 或 <code>show full processlist</code> 可以查看当前 MySQL 是否有压力，正在运行的<code>SQL</code>，有没有慢<code>SQL</code>正在执行。返回参数如下：</p><ol><li><strong>id</strong>：线程ID，可以用<code>kill id</code>杀死某个线程</li><li><strong>db</strong>：数据库名称</li><li><strong>user</strong>：数据库用户</li><li><strong>host</strong>：数据库实例的IP</li><li><strong>command</strong>：当前执行的命令，比如<code>Sleep</code>，<code>Query</code>，<code>Connect </code>等</li><li><strong>time</strong>：消耗时间，单位秒</li><li>state：执行状态，主要有以下状态：<ul><li>Sleep，线程正在等待客户端发送新的请求</li><li>Locked，线程正在等待锁</li><li>Sending data，正在处理<code>SELECT</code>查询的记录，同时把结果发送给客户端</li><li>Kill，正在执行<code>kill</code>语句，杀死指定线程</li><li>Connect，一个从节点连上了主节点</li><li>Quit，线程正在退出</li><li>Sorting for group，正在为<code>GROUP BY</code>做排序</li><li>Sorting for order，正在为<code>ORDER BY</code>做排序</li></ul></li><li><strong>info</strong>：正在执行的<code>SQL</code>语句</li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h3><p>MySQL中常用的四种存储引擎分别是： <strong>MyISAM</strong>、<strong>InnoDB</strong>、<strong>MEMORY</strong>、<strong>ARCHIVE</strong>。MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。</p><p><strong>InnoDB存储引擎</strong></p><p>InnoDB是MySQL<strong>默认的事务型存储引擎</strong>，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p><p><strong>优点</strong>：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p><p><strong>缺点</strong>：占用的数据空间相对较大。</p><p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p><p><strong>MyISAM存储引擎</strong></p><p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件<code>.MYD</code>和索引文件<code>.MYI</code>。</p><p><strong>优点</strong>：访问速度快。</p><p><strong>缺点</strong>：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p><p><strong>适用场景</strong>：对事务完整性没有要求；表的数据都会只读的。</p><p><strong>MEMORY存储引擎</strong></p><p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p><p>MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。</p><p><strong>优点</strong>：访问速度较快。</p><p><strong>缺点</strong>：</p><ol><li>哈希索引数据不是按照索引值顺序存储，无法用于排序。 </li><li>不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。 </li><li>只支持等值比较，不支持范围查询。 </li><li>当出现哈希冲突时，存储引擎需要遍历链表中所有的行指针，逐行进行比较，直到找到符合条件的行。</li></ol><p><strong>ARCHIVE存储引擎</strong></p><p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p><h3 id="MyISAM和InnoDB的区别？"><a href="#MyISAM和InnoDB的区别？" class="headerlink" title="MyISAM和InnoDB的区别？"></a>MyISAM和InnoDB的区别？</h3><p><strong>是否支持行级锁</strong> : <code>MyISAM</code> 只有表级锁，而<code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</p><p><strong>是否支持事务和崩溃后的安全恢复</strong>： <code>MyISAM</code> 不提供事务支持。而<code>InnoDB</code>提供事务支持，具有事务、回滚和崩溃修复能力。</p><blockquote><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul></blockquote><p><strong>是否支持外键：</strong> <code>MyISAM</code>不支持，而<code>InnoDB</code>支持。</p><p><strong>是否支持MVCC</strong> ：<code>MyISAM</code>不支持，<code>InnoDB</code>支持。应对高并发事务，MVCC比单纯的加锁更高效。</p><p><strong>是否支持聚集索引</strong> ：<code>MyISAM</code>不支持聚集索引，<code>InnoDB</code>支持聚集索引。</p><h3 id="锁机制与-InnoDB-锁算法"><a href="#锁机制与-InnoDB-锁算法" class="headerlink" title="锁机制与 InnoDB 锁算法"></a>锁机制与 InnoDB 锁算法</h3><p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p><ul><li>MyISAM 采用表级锁(table-level locking)。</li><li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li></ul><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li></ul><h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><p>MVCC(<code>Multiversion concurrency control</code>) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过<code>read view</code>和版本链找到对应版本的数据。</p><p>作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。</p><p>MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。</p><ul><li><code>DB_TRX_ID</code>：当前事务id，通过事务id的大小判断事务的时间顺序。 </li><li><code>DB_ROLL_PRT</code>：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成<code>undo log</code>版本链。 </li><li><code>DB_ROLL_ID</code>：主键，如果数据表没有主键，InnoDB会自动生成主键。</li></ul><p>使用事务更新行记录的时候，就会生成版本链，执行过程如下：</p><ol><li>用排他锁锁住该行； </li><li>将该行原本的值拷贝到<code>undo log</code>，作为旧版本用于回滚； </li><li>修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。</li></ol><p><strong>read view</strong></p><p><code>read view</code>可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。</p><p>在<code>read view</code>内部维护一个活跃事务链表，表示生成<code>read view</code>的时候还在活跃的事务。这个链表包含在创建<code>read view</code>之前还未提交的事务，不包含创建<code>read view</code>之后提交的事务。</p><p>不同隔离级别创建read view的时机不同。</p><ul><li>read committed：每次执行select都会创建新的read_view，保证能读取到其他事务已经提交的修改。</li><li>repeatable read：在一个事务范围内，第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。</li></ul><p><strong>总结</strong>：InnoDB 的<code>MVCC</code>是通过 <code>read view</code> 和版本链实现的，版本链保存有历史版本记录，通过<code>read view</code> 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><blockquote><p><strong>不可重复读和幻读区别：</strong></p><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了。</p></blockquote><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="何为索引？有什么作用？"><a href="#何为索引？有什么作用？" class="headerlink" title="何为索引？有什么作用？"></a>何为索引？有什么作用？</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="什么情况下需要建索引？"><a href="#什么情况下需要建索引？" class="headerlink" title="什么情况下需要建索引？"></a>什么情况下需要建索引？</h3><ol><li>经常用于查询的字段 </li><li>经常用于连接的字段建立索引，可以加快连接的速度 </li><li>经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度</li></ol><h3 id="什么情况下不建索引？"><a href="#什么情况下不建索引？" class="headerlink" title="什么情况下不建索引？"></a>什么情况下不建索引？</h3><ol><li><code>where</code>条件中用不到的字段不适合建立索引 </li><li>表记录较少 </li><li>需要经常增删改 </li><li><strong>参与列计算</strong>的列不适合建索引 </li><li><strong>区分度不高</strong>的字段不适合建立索引，如性别等</li></ol><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p><p><strong>B+树索引</strong></p><p>B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ 树中，节点中的 <code>key</code> 从左到右递增排列，如果某个指针的左右相邻 <code>key</code> 分别是 keyi 和 keyi+1，则该指针指向节点的所有 <code>key</code> 大于等于 keyi 且小于等于 keyi+1。</p><p><img src="https://camo.githubusercontent.com/6cf0a25e3d23bb0be8ee3b3f85b46faf648b5c9f80ad205886fa556968a0dc97/68747470733a2f2f67697465652e636f6d2f7479736f6e6461692f696d672f7261772f6d61737465722f422b254536254130253931254537254234254132254535254243253935302e706e67"></p><p>进行查找操作时，首先在根节点进行二分查找，找到<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出<code>key</code>所对应的数据项。</p><p>MySQL 数据库使用最多的索引类型是<code>BTREE</code>索引，底层基于B+树数据结构来实现。</p><p><strong>哈希索引</strong></p><p>哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p><h3 id="Hash索引和B-树索引的区别？"><a href="#Hash索引和B-树索引的区别？" class="headerlink" title="Hash索引和B+树索引的区别？"></a>Hash索引和B+树索引的区别？</h3><ul><li>哈希索引<strong>不支持排序</strong>，因为哈希表是无序的。</li><li>哈希索引<strong>不支持范围查找</strong>。</li><li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li><li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li></ul><h3 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h3><ul><li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li><li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I&#x2F;O支出。</li><li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a><strong>主键索引(Primary Key)</strong></h4><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a><strong>二级索引(辅助索引)</strong></h4><p>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ol><li><p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p></li><li><p><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></p></li><li><p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p><blockquote><p>有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。</p><p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p><p>创建前缀索引的关键在于选择足够长的前缀以<strong>保证较高的索引选择性</strong>。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。</p><p>建立前缀索引的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// email列创建前缀索引</span><br><span class="line">ALTER TABLE table_name ADD KEY(column_name(prefix_length));</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</p></li></ol><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a><strong>聚集索引</strong></h4><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</p><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>聚集索引的优点</strong></p><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><p><strong>聚集索引的缺点</strong></p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。**</p><p><strong>非聚集索引的优点</strong></p><p>非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p><strong>非聚集索引的缺点</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li></ol><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h3 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h3><ul><li>索引列的<strong>区分度越高</strong>，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。</li><li>尽量使用<strong>短索引</strong>，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I&#x2F;O较少，查询速度更快。</li><li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。</li><li>利用<strong>最左前缀原则</strong>。</li></ul><h3 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h3><p>导致索引失效的情况：</p><ul><li>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引</li><li>以%开头的like查询如<code>%abc</code>，无法使用索引；非%开头的like查询如<code>abc%</code>，相当于范围查询，会使用索引</li><li>查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效</li><li>判断索引列是否不等于某个值时</li><li>对索引列进行运算</li><li>查询条件使用<code>or</code>连接，也会导致索引失效</li></ul><h2 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h2><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p><p><img src="https://s2.loli.net/2022/03/21/OeVNi7MdHzcCpqZ.png"></p><p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><img src="https://s2.loli.net/2022/03/21/MdsgqrtpVHynIxD.png"></p><p><strong>innodb_flush_log_at_trx_commit&#x3D;0</strong></p><p><img src="https://s2.loli.net/2022/03/21/QMf8wSZm1K4PdFW.png"></p><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p><p><strong>innodb_flush_log_at_trx_commit&#x3D;1</strong></p><p><img src="https://s2.loli.net/2022/03/21/aOA148XnjTbiwlt.png"></p><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><p><strong>innodb_flush_log_at_trx_commit&#x3D;2</strong></p><p><img src="https://s2.loli.net/2022/03/21/KyCB3qiswHZhjx7.png"></p><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><p><img src="https://s2.loli.net/2022/03/21/x1LpeKIG5hfkyP4.png"></p><blockquote><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p></blockquote><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p><p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><p><img src="https://s2.loli.net/2022/03/21/NHTpalUtXdSZrCM.png"></p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h3 id="bin-log和redo-log有什么区别？"><a href="#bin-log和redo-log有什么区别？" class="headerlink" title="bin log和redo log有什么区别？"></a>bin log和redo log有什么区别？</h3><ol><li><code>bin log</code>会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；<code>redo log</code>只记录innoDB自身的事务日志。</li><li><code>bin log</code>只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有<code>redo log</code>不断写入磁盘。</li><li><code>bin log</code>是逻辑日志，记录的是SQL语句的原始逻辑；<code>redo log</code>是物理日志，记录的是在某个数据页上做了什么修改。</li></ol><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/mysql">https://snailclimb.gitee.io/javaguide/#/docs/database/mysql</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发</title>
      <link href="/post/2441703857.html"/>
      <url>/post/2441703857.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>**初始(NEW)**：线程被构建，还没有调用 start()。</p><p>**运行(RUNNABLE)**：包括操作系统的就绪和运行两种状态。</p><p>**阻塞(BLOCKED)**：一般是被动的，在抢占资源中得不到资源，被动的挂起在内存，等待资源释放将其唤醒。线程被阻塞会释放CPU，不释放内存。</p><p>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</p><p>**终止(TERMINATED)**：表示该线程已经执行完毕。</p><p><img src="https://s2.loli.net/2022/03/16/XNZAb7iBdV21lL3.png"></p><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别?"></a>并发与并行的区别?</h3><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li></ul><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="讲讲线程中断？"><a href="#讲讲线程中断？" class="headerlink" title="讲讲线程中断？"></a>讲讲线程中断？</h3><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑取决于目标线程。</p><p>线程中断三个重要的方法：</p><p><strong>1、java.lang.Thread#interrupt</strong></p><p>调用目标线程的<code>interrupt()</code>方法，给目标线程发一个中断信号，线程被打上中断标记。</p><p><strong>2、java.lang.Thread#isInterrupted()</strong></p><p>判断目标线程是否被中断，不会清除中断标记。</p><p><strong>3、java.lang.Thread#interrupted</strong></p><p>判断目标线程是否被中断，会清除中断标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Java技术栈线程被中断，程序退出。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h3><ul><li>通过扩展<code>Thread</code>类来创建多线程</li><li>通过实现<code>Runnable</code>接口来创建多线程</li><li>实现<code>Callable</code>接口，通过<code>FutureTask</code>接口创建线程。</li><li>使用<code>Executor</code>框架来创建线程池。</li></ul><p><strong>继承 Thread 创建线程</strong>代码如下。run()方法是由jvm创建完操作系统级线程后回调的方法，不可以手动调用，手动调用相当于调用普通方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread1.start();</span><br><span class="line">        mThread2.start();</span><br><span class="line">        myThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runnable 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>可以避免java中的单继承的限制</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类</li></ol><p><strong>Callable 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callable1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步计算的结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务完成，返回结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Executor 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取ExecutorService实例，生产禁用，需要手动创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableDemo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大彬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runnable和Callable有什么区别？"><a href="#Runnable和Callable有什么区别？" class="headerlink" title="Runnable和Callable有什么区别？"></a>Runnable和Callable有什么区别？</h3><ul><li>Callable接口方法是<code>call()</code>，Runnable的方法是<code>run()</code>；</li><li>Callable接口call方法有返回值，支持泛型，Runnable接口run方法无返回值。</li><li>Callable接口<code>call()</code>方法允许抛出异常；而Runnable接口<code>run()</code>方法不能继续上抛异常。</li></ul><h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://s2.loli.net/2022/03/16/7mgxOrW1Q6PHfDv.png"></p><h3 id="线程死锁怎么产生？怎么避免？"><a href="#线程死锁怎么产生？怎么避免？" class="headerlink" title="线程死锁怎么产生？怎么避免？"></a>线程死锁怎么产生？怎么避免？</h3><p><strong>死锁产生的四个必要条件</strong>：</p><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源</li><li>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺</li><li>循环等待：进程之间循环等待着资源</li></ul><p><strong>避免死锁的方法</strong>：</p><ul><li>互斥条件不能破坏，因为加锁就是为了保证互斥</li><li>一次性申请所有的资源，避免线程占有资源而且在等待其他资源</li><li>占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源</li><li>按序申请资源</li></ul><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><ul><li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep() </code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h3 id="线程run和start的区别？"><a href="#线程run和start的区别？" class="headerlink" title="线程run和start的区别？"></a>线程run和start的区别？</h3><ul><li>当程序调用<code>start()</code>方法，将会创建一个新线程去执行<code>run()</code>方法中的代码。<code>run()</code>就像一个普通方法一样，直接调用<code>run()</code>的话，不会创建新线程。</li><li>一个线程的 <code>start()</code> 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常。<code>run()</code> 方法则没有限制。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池：一个管理线程的池子。</p><h3 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h3><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。统一管理线程，避免系统创建大量同类线程而导致消耗完内存。</li></ul><h3 id="线程池执行原理？"><a href="#线程池执行原理？" class="headerlink" title="线程池执行原理？"></a>线程池执行原理？</h3><p><img src="https://s2.loli.net/2022/03/16/JPO5hXagxrS2poG.png"></p><ol><li>当线程池里存活的线程数小于核心线程数<code>corePoolSize</code>时，这时对于一个新提交的任务，线程池会创建一个线程去处理任务。当线程池里面存活的线程数小于等于核心线程数<code>corePoolSize</code>时，线程池里面的线程会一直存活着，就算空闲时间超过了<code>keepAliveTime</code>，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>了，这是对于一个新提交的任务，会被放进任务队列<code>workQueue</code>排队等待执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>了，并且任务队列也满了，假设<code>maximumPoolSize&gt;corePoolSize</code>，这时如果再来新的任务，线程池就会继续创建新的线程来处理新的任务，知道线程数达到<code>maximumPoolSize</code>，就不会再创建了。</li><li>如果当前的线程数达到了<code>maximumPoolSize</code>，并且任务队列也满了，如果还有新的任务过来，那就直接采用拒绝策略进行处理。默认的拒绝策略是抛出一个<code>RejectedExecutionException</code>异常。</li></ol><h3 id="线程池参数有哪些？"><a href="#线程池参数有哪些？" class="headerlink" title="线程池参数有哪些？"></a>线程池参数有哪些？</h3><p>ThreadPoolExecutor 的通用构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span>;</span><br></pre></td></tr></table></figure><p>1、<code>corePoolSize</code>：当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列。当线程池中存活的线程数总是大于 corePoolSize 时，应该考虑调大 corePoolSize。</p><p>2、<code>maximumPoolSize</code>：当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务。非核心线程类似于临时借来的资源，这些线程在空闲时间超过 keepAliveTime 之后，就应该退出，避免资源浪费。</p><p>3、<code>BlockingQueue</code>：存储等待运行的任务。</p><p>4、<code>keepAliveTime</code>：<strong>非核心线程</strong>空闲后，保持存活的时间，此参数只对非核心线程有效。设置为0，表示多余的空闲线程会被立即终止。</p><p>5、<code>TimeUnit</code>：时间单位</p><p>6、<code>ThreadFactory</code>：每当线程池创建一个新的线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新线程就会调用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadFactory</span><span class="params">(String poolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAppThread</span>(runnable, poolName);<span class="comment">//将线程池名字传递给构造函数，用于区分不同线程池的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、<code>RejectedExecutionHandler</code>：当队列和线程池都满了的时候，根据拒绝策略处理新任务。</p><p>AbortPolicy：默认的策略，直接抛出RejectedExecutionException<br>DiscardPolicy：不处理，直接丢弃<br>DiscardOldestPolicy：将等待队列队首的任务丢弃，并执行当前任务<br>CallerRunsPolicy：由调用线程处理该任务</p><h3 id="线程池大小怎么设置？"><a href="#线程池大小怎么设置？" class="headerlink" title="线程池大小怎么设置？"></a>线程池大小怎么设置？</h3><p>如果线程池线程数量太小，当有大量请求需要处理，系统响应比较慢，会影响用户体验，甚至会出现任务队列大量堆积任务导致OOM。</p><p>如果线程池线程数量过大，大量线程可能会同时抢占 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了执行效率。</p><p>**CPU 密集型任务(N+1)**： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为<code> N（CPU 核心数）+1</code>，多出来的一个线程是为了防止某些原因导致的线程阻塞（如IO操作，线程sleep，等待锁）而带来的影响。一旦某个线程被阻塞，释放了CPU资源，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p>**I&#x2F;O 密集型任务(2N)**： 系统的大部分时间都在处理 IO 操作，此时线程可能会被阻塞，释放CPU资源，这时就可以将 CPU 交出给其它线程使用。因此在 IO 密集型任务的应用中，可以多配置一些线程，具体的计算方法：<code>最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (IO耗时/CPU耗时))</code>，一般可设置为2N。</p><h3 id="线程池的类型有哪些？适用场景？"><a href="#线程池的类型有哪些？适用场景？" class="headerlink" title="线程池的类型有哪些？适用场景？"></a>线程池的类型有哪些？适用场景？</h3><p>常见的线程池有 <code>FixedThreadPool</code>、<code>SingleThreadExecutor</code>、<code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>。这几个都是 <code>ExecutorService</code> 线程池实例。</p><p><strong>FixedThreadPool</strong></p><p>固定线程数的线程池。任何时间点，最多只有 nThreads 个线程处于活动状态执行任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无界队列 LinkedBlockingQueue（队列容量为 Integer.MAX_VALUE），运行中的线程池不会拒绝任务，即不会调用RejectedExecutionHandler.rejectedExecution()方法。</p><p>maxThreadPoolSize 是无效参数，故将它的值设置为与 coreThreadPoolSize 一致。</p><p>keepAliveTime 也是无效参数，设置为0L，因为此线程池里所有线程都是核心线程，核心线程不会被回收（除非设置了executor.allowCoreThreadTimeOut(true)）。</p><p>适用场景：适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。需要注意的是，FixedThreadPool 不会拒绝任务，<strong>在任务比较多的时候会导致 OOM。</strong></p><p><strong>SingleThreadExecutor</strong></p><p>只有一个线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutionService newSingleThreadExecutor() &#123;</span><br><span class="line">return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无界队列 LinkedBlockingQueue。线程池只有一个运行的线程，新来的任务放入工作队列，线程处理完任务就循环从队列里获取任务执行。保证顺序的执行各个任务。</p><p>适用场景：适用于串行执行任务的场景，一个任务一个任务地执行。<strong>在任务比较多的时候也是会导致 OOM。</strong></p><p><strong>CachedThreadPool</strong></p><p>根据需要创建新线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主线程提交任务的速度高于线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><p>使用没有容量的SynchronousQueue作为线程池工作队列，当线程池有空闲线程时，<code>SynchronousQueue.offer(Runnable task)</code>提交的任务会被空闲线程处理，否则会创建新的线程处理任务。</p><p>适用场景：用于并发执行大量短期的小任务。<code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，<strong>可能会创建大量线程，从而导致 OOM。</strong></p><p><strong>ScheduledThreadPoolExecutor</strong></p><p>在给定的延迟后运行任务，或者定期执行任务。在实际项目中基本不会被用到，因为有其他方案选择比如<code>quartz</code>。</p><p>使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，时间早的任务先被执行(即<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果time相同则先提交的任务会被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p><p>执行周期任务步骤：</p><ol><li>线程从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>执行这个 <code>ScheduledFutureTask</code>；</li><li>修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><p><img src="https://s2.loli.net/2022/03/16/mzgWtji1vUyD8k7.png"></p><p>适用场景：周期性执行任务的场景，需要限制线程数量的场景。</p><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><h3 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="headerlink" title="synchronized的用法有哪些?"></a>synchronized的用法有哪些?</h3><ol><li><strong>修饰普通方法</strong>：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法</strong>：作用于当前类，进入同步代码前要获得当前类对象的锁，synchronized关键字加到static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</li><li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ol><h3 id="synchronized的作用有哪些？"><a href="#synchronized的作用有哪些？" class="headerlink" title="synchronized的作用有哪些？"></a>synchronized的作用有哪些？</h3><p><strong>原子性</strong>：确保线程互斥的访问同步代码；</p><p><strong>可见性</strong>：保证共享变量的修改能够及时可见；</p><p><strong>有序性</strong>：有效解决重排序问题。</p><h3 id="synchronized底层实现原理？"><a href="#synchronized底层实现原理？" class="headerlink" title="synchronized底层实现原理？"></a>synchronized底层实现原理？</h3><p>synchronized 同步代码块的实现是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <code>monitor</code>的持有权（monitor对象存在于每个Java对象的对象头中， synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）。</p><p>其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 <code>monitorexit</code> 指令后，将锁计数器设为0 ，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</p><p>synchronized 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><ol><li>使用synchronized关键字实现同步，线程执行完同步代码块会<strong>自动释放锁</strong>，而ReentrantLock需要手动释放锁。</li><li>synchronized是<strong>非公平锁</strong>，ReentrantLock可以设置为公平锁。</li><li>ReentrantLock上等待获取锁的线程是<strong>可中断的</strong>，线程可以放弃等待锁。而synchonized会无限期等待下去。</li><li>ReentrantLock <strong>可以设置超时获取锁</strong>。在指定的截止时间之前获取锁，如果截止时间到了还没有获取到锁，则返回。</li><li>ReentrantLock 的 tryLock() 方法<strong>可以尝试非阻塞的获取锁</strong>，调用该方法后立刻返回，如果能够获取则返回true，否则返回false。</li></ol><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p><code>volatile</code>是轻量级的同步机制，<code>volatile</code>保证变量对所有线程的可见性，不保证原子性。</p><ol><li>当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条<code>LOCK</code>前缀的指令，将该变量所在缓存行的数据写回系统内存。</li><li>由于缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。</li></ol><blockquote><p>来看看缓存一致性协议是什么。</p><p><strong>缓存一致性协议</strong>：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，就会从内存重新读取。</p></blockquote><p><code>volatile</code>关键字的两个作用：</p><ol><li>保证了不同线程对共享变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行<strong>指令重排序</strong>。</li></ol><blockquote><p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。Java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止处理器重排序。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。对一个volatile字段进行写操作，Java内存模型将在写操作后插入一个写屏障指令，这个指令会把之前的写入值都刷新到内存。</p></blockquote><h3 id="volatile和synchronized的区别是什么？"><a href="#volatile和synchronized的区别是什么？" class="headerlink" title="volatile和synchronized的区别是什么？"></a>volatile和synchronized的区别是什么？</h3><ol><li><code>volatile</code>只能使用在变量上；而<code>synchronized</code>可以在类，变量，方法和代码块上。</li><li><code>volatile</code>至保证可见性；<code>synchronized</code>保证原子性与可见性。</li><li><code>volatile</code>禁用指令重排序；<code>synchronized</code>不会。</li><li><code>volatile</code>不会造成阻塞；<code>synchronized</code>会。</li></ol><h3 id="ReentrantLock-是如何实现可重入性的"><a href="#ReentrantLock-是如何实现可重入性的" class="headerlink" title="ReentrantLock 是如何实现可重入性的?"></a>ReentrantLock 是如何实现可重入性的?</h3><p><code>ReentrantLock</code>内部自定义了同步器sync，在加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，检查当前维护的那个线程ID和当前请求的线程ID是否 一致，如果一致，同步状态加1，表示锁被当前线程获取了多次。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>线程本地变量。当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。</p><img src="https://s2.loli.net/2022/03/16/RjYXxNMvWeC6VEp.jpg" style="zoom:67%;" /><p>调用<code>threadLocal.set()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.set(this, value)</code>，this是<code>threadLocal</code>本身。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>get()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.getEntry(this)</code>，返回<code>value</code>。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threadLocals</code>的类型<code>ThreadLocalMap</code>的键为<code>ThreadLocal</code>对象，因为每个线程中可有多个<code>threadLocal</code>变量，如<code>longLocal</code>和<code>stringLocal</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span> &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">threadLocalDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        threadLocalDemo.set();</span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocalDemo.set();</span><br><span class="line">            System.out.println(threadLocalDemo.get());</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>并不是用来解决共享资源的多线程访问问题，因为每个线程中的资源只是副本，不会共享。因此<code>ThreadLocal</code>适合作为线程上下文变量，简化线程内传参。</p><h3 id="ThreadLocal内存泄漏的原因？"><a href="#ThreadLocal内存泄漏的原因？" class="headerlink" title="ThreadLocal内存泄漏的原因？"></a>ThreadLocal内存泄漏的原因？</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal使用场景有哪些？"><a href="#ThreadLocal使用场景有哪些？" class="headerlink" title="ThreadLocal使用场景有哪些？"></a>ThreadLocal使用场景有哪些？</h3><p><code>ThreadLocal</code>适用场景：每个线程需要有自己单独的实例，且需要在多个方法中共享实例，即同时满足实例在线程间的隔离与方法间的共享，这种情况适合使用<code>ThreadLocal</code>。比如Java web应用中，每个线程有自己单独的<code>Session</code>实例，就可以使用<code>ThreadLocal</code>来实现。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h3><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><img src="https://s2.loli.net/2022/03/16/p3sQZ1Biv2bTndJ.png"></p><p>AQS使用一个<code>volatile</code>的int类型的成员变量<code>state</code>来表示同步状态，通过CAS修改同步状态的值。当线程调用 lock 方法时 ，如果 <code>state</code>&#x3D;0，说明没有任何线程占有共享资源的锁，可以获得锁并将 <code>state</code>加1。如果 <code>state</code>不为0，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如<code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>按照<strong>线程访问顺序</strong>获取对象锁。<code>synchronized</code>是非公平锁，<code>Lock</code>默认是非公平锁，可以设置为公平锁，公平锁会影响性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享式与独占式锁"><a href="#共享式与独占式锁" class="headerlink" title="共享式与独占式锁"></a>共享式与独占式锁</h3><p>共享式与独占式的最主要<strong>区别</strong>在于：同一时刻独占式只能有<strong>一个线程</strong>获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>悲观锁，<strong>每次访问资源都会加锁</strong>，执行完同步代码释放锁，<code>synchronized</code>和<code>ReentrantLock</code>属于悲观锁。</p><p>乐观锁，不会锁定资源，所有的线程都能访问并修改同一个资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。乐观锁最常见的实现就是<code>CAS</code>。</p><p>适用场景：</p><ul><li>悲观锁适合<strong>写操作多</strong>的场景。</li><li>乐观锁适合<strong>读操作多</strong>的场景，不加锁可以提升读操作的性能。</li></ul><h3 id="乐观锁有什么问题"><a href="#乐观锁有什么问题" class="headerlink" title="乐观锁有什么问题?"></a>乐观锁有什么问题?</h3><p>乐观锁避免了悲观锁独占对象的问题，提高了并发性能，但它也有缺点:</p><ul><li>乐观锁只能保证<strong>一个共享变量</strong>的原子操作。</li><li>长时间自旋可能导致<strong>开销大</strong>。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。</li><li><strong>ABA问题</strong>。CAS的原理是通过比对内存值与预期值是否一样而判断内存值是否被改过，但是会有以下问题：假如内存值原来是A， 后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变。可以引入版本号解决这个问题，每次变量更新都把版本号加一。</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p>CAS全称<code>Compare And Swap</code>，比较与交换，是乐观锁的主要实现方式。CAS在不使用锁的情况下实现多线程之间的变量同步。<code>ReentrantLock</code>内部的AQS和原子类内部都使用了CAS。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值V。</li><li>进行比较的值A。</li><li>要写入的新值B。</li></ul><p>只有当V的值等于A时，才会使用原子方式用新值B来更新V的值，否则会继续重试直到成功更新值。</p><p>以<code>AtomicInteger</code>为例，<code>AtomicInteger</code>的<code>getAndIncrement()</code>方法底层就是CAS实现，关键代码是 <code>compareAndSwapInt(obj, offset, expect, update)</code>，其含义就是，如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果不相等，那就会继续重试直到成功更新值。</p><h3 id="CAS存在的问题？"><a href="#CAS存在的问题？" class="headerlink" title="CAS存在的问题？"></a>CAS存在的问题？</h3><ol><li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从<code>A－B－A</code>变成了<code>1A－2B－3A</code>。</p><p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。</p></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>CountDownLatch</code> 的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier(同步屏障)，用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数parties指让多少个线程或者任务等待至某个状态；参数barrierAction为当这些线程都达到某个状态时会执行的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">        cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h3><p>CyclicBarrier 和 CountDownLatch 都能够实现线程之间的等待。</p><p>CountDownLatch用于某个线程等待其他线程<strong>执行完任务</strong>再执行。CyclicBarrier用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可用于处理更为复杂的业务场景。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore类似于锁，它用于控制同时访问特定资源的线程数量，控制并发线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Worker</span>(s, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Semaphore s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.acquire();</span><br><span class="line">            System.out.println(<span class="string">&quot;worker&quot;</span> + num +  <span class="string">&quot; using the machine&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;worker&quot;</span> + num +  <span class="string">&quot; finished the task&quot;</span>);</span><br><span class="line">            s.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>AtomicInteger 类常用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) 保证原子操作，从而避免加锁的高开销。</p><h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>AtomicIntegerArray 类常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：带有版本号的引用类型原子类。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li></ul><p>参考文章：</p><p>[1] <a href="https://snailclimb.gitee.io/javaguide/#/?id=%E5%B9%B6%E5%8F%91">JavaGuide (gitee.io)</a></p><p>[2] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/post/72389457.html"/>
      <url>/post/72389457.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见的Java集合"><a href="#常见的Java集合" class="headerlink" title="常见的Java集合"></a>常见的Java集合</h2><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src="https://s2.loli.net/2022/03/15/DKvo3mzbB2ljd14.png"></p><h2 id="List-Set-Queue-Map-四者的区别？"><a href="#List-Set-Queue-Map-四者的区别？" class="headerlink" title="List, Set, Queue, Map 四者的区别？"></a>List, Set, Queue, Map 四者的区别？</h2><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-的扩容机制？"><a href="#ArrayList-的扩容机制？" class="headerlink" title="ArrayList 的扩容机制？"></a>ArrayList 的扩容机制？</h3><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍</strong>。以JDK1.8为例说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将e添加到数组末尾</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次在新增一个元素时，需要判断这个list的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 容量不足则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//检查容量是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="怎么在遍历-ArrayList-时移除一个元素？"><a href="#怎么在遍历-ArrayList-时移除一个元素？" class="headerlink" title="怎么在遍历 ArrayList 时移除一个元素？"></a>怎么在遍历 ArrayList 时移除一个元素？</h3><p>foreach删除会导致快速失败问题，可以使用迭代器的 remove() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">itr</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(itr.next().equals(<span class="string">&quot;jay&quot;</span>) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h3><ul><li><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</p></li><li><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</p></li><li><p><code>ArrayList</code>在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</p></li><li><p><code>Vector</code>属于线程安全级别的，但是大多数情况下不使用Vector，因为操作Vector效率比较低。</p></li></ul><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h3><ol><li>ArrayList基于动态数组实现；LinkedList基于链表实现。 </li><li>对于随机index访问的get和set方法，ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。 </li><li>新增和删除元素，LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li><li>ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全</strong>的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>HashMap 使用数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的， 链表长度大于8（TREEIFY_THRESHOLD）时，会把链表转换为红黑树，红黑树节点个数小于6（UNTREEIFY_THRESHOLD）时才转化为链表，防止频繁的转化。</p><h3 id="解决hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决hash冲突的办法有哪些？HashMap用的哪种？"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h3><p>解决Hash冲突方法有:开放定址法、再哈希法、链地址法。HashMap中采用的是 链地址法 。</p><ul><li>开放定址法基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code> </li><li>再哈希法提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。 </li><li>链地址法将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li></ul><h3 id="HashMap扩容过程？"><a href="#HashMap扩容过程？" class="headerlink" title="HashMap扩容过程？"></a>HashMap扩容过程？</h3><p>1.8扩容机制：当元素个数大于threshold时，会进行扩容，使用2倍容量的数组代替原有数组。采用尾插入的方式将原数组元素拷贝到新数组。1.8扩容之后链表元素相对位置没有变化，而1.7扩容之后链表元素会倒置。</p><p>1.7链表新节点采用的是头插法，这样在线程一扩容迁移元素时，会将元素顺序改变，导致两个线程中出现元素的相互指向而形成循环链表，1.8采用了尾插法，避免了这种情况的发生。</p><p>原数组的元素在重新计算hash之后，因为数组容量n变为2倍，那么n-1的mask范围在高位多1bit。在元素拷贝过程不需要重新计算元素在数组中的位置，只需要看看原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成“原索引+oldCap”（根据<code>e.hash &amp; (oldCap - 1) == 0</code>判断） 。这样可以省去重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程会均匀的把之前的冲突的节点分散到新的bucket。</p><h3 id="红黑树的特点？"><a href="#红黑树的特点？" class="headerlink" title="红黑树的特点？"></a>红黑树的特点？</h3><ul><li>每个节点或者是黑色，或者是红色。 </li><li>根节点是黑色。 </li><li>每个叶子节点（NIL）是黑色。 </li><li>如果一个节点是红色的，则它的子节点必须是黑色的。 </li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><h3 id="为什么使用红黑树而不使用AVL树？"><a href="#为什么使用红黑树而不使用AVL树？" class="headerlink" title="为什么使用红黑树而不使用AVL树？"></a>为什么使用红黑树而不使用AVL树？</h3><p>ConcurrentHashMap 在put的时候会加锁，使用红黑树插入速度更快，可以减少等待锁释放的时间。红黑树是对AVL树的优化，只要求部分平衡，用非严格的平衡来换取增删节点时候旋转次数的降低，提高了插入和删除的性能。</p><h3 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h3><p>一般用<code>Integer</code>、<code>String</code>这种不可变类当 HashMap 当 key。String类比较常用。</p><ul><li>因为 String 是不可变的，所以在它创建的时候<code>hashcode</code>就被缓存了，不需要重新计算。这就是 HashMap 中的key经常使用字符串的原因。</li><li>获取对象的时候要用到 <code>equals()</code> 和 <code>hashCode()</code> 方法，而Integer、String这些类都已经重写了 <code>hashCode()</code> 以及 <code>equals()</code> 方法，不需要自己去重写这两个方法。</li></ul><h3 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h3><ul><li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。</li><li>在JDK1.8中，在多线程环境下，会发生<strong>数据覆盖</strong>的情况。</li></ul><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th align="center"><code>HashMap</code></th><th align="center"><code>HashSet</code></th></tr></thead><tbody><tr><td align="center">实现了 <code>Map</code> 接口</td><td align="center">实现 <code>Set</code> 接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向 map 中添加元素</td><td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="https://s2.loli.net/2022/03/16/E1JwO3sNZro9nSq.png"></p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力，默认是按 key 的升序排序。</p><h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>Hashtable:</strong></p><p><img src="https://s2.loli.net/2022/03/16/LMvRnZb1rfTPW4h.png"></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><p><img src="https://s2.loli.net/2022/03/16/HZCjMynR63smVtN.png"></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><p><img src="https://s2.loli.net/2022/03/16/XfJDszeat9L7kqw.png"></p><h3 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h3><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）;</li><li>Streams API 遍历（JDK 1.8+）。</li></ol><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol><h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h2 id="什么是fail-fast？"><a href="#什么是fail-fast？" class="headerlink" title="什么是fail fast？"></a>什么是fail fast？</h2><p>fast-fail是Java集合的一种错误机制。当多个线程对同一个集合进行操作时，就有可能会产生fast-fail事件。例如：当线程a正通过iterator遍历集合时，另一个线程b修改了集合的内容，此时modCount（记录集合操作过程的修改次数）会加1，不等于expectedModCount，那么线程a访问集合的时候，就会抛出ConcurrentModificationException，产生fast-fail事件。边遍历边修改集合也会产生fast-fail事件。</p><p>解决方法：</p><ul><li>使用Colletions.synchronizedList方法或在修改集合内容的地方加上synchronized。这样的话，增删集合内容的同步锁会阻塞遍历操作，影响性能。</li><li>使用CopyOnWriteArrayList来替换ArrayList。在对CopyOnWriteArrayList进行修改操作的时候，会拷贝一个新的数组，对新的数组进行操作，操作完成后再把引用移到新的数组。</li></ul><h2 id="什么是fail-safe？"><a href="#什么是fail-safe？" class="headerlink" title="什么是fail safe？"></a>什么是fail safe？</h2><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><p><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p><strong>缺点</strong>：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h2 id="哪些集合类是线程安全的？哪些不安全？"><a href="#哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="哪些集合类是线程安全的？哪些不安全？"></a>哪些集合类是线程安全的？哪些不安全？</h2><p>线性安全的集合类：</p><ul><li>Vector：比ArrayList多了同步机制。</li><li>Hashtable。</li><li>ConcurrentHashMap：是一种高效并且线程安全的集合。</li><li>Stack：栈，也是线程安全的，继承于Vector。</li></ul><p>线性不安全的集合类：</p><ul><li>Hashmap</li><li>Arraylist</li><li>LinkedList</li><li>HashSet</li><li>TreeSet</li><li>TreeMap</li></ul><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap:</strong> 线程安全的 HashMap</li><li><strong>CopyOnWriteArrayList:</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li><li><strong>ConcurrentLinkedQueue:</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li><strong>BlockingQueue:</strong> 阻塞队列接口，JDK 内部通过链表、数组等方式实现了这个接口。非常适合用于作为数据共享的通道。</li><li><strong>ConcurrentSkipListMap:</strong> 跳表的实现。使用跳表的数据结构进行快速查找。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>多线程环境下，使用Hashmap进行put操作会引起死循环，应该使用支持多线程的 ConcurrentHashMap。</p><p>JDK1.8 ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构采用数组+链表&#x2F;红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，相比1.7锁定HashEntry数组，锁粒度更小，支持更高的并发量。当链表长度过长时，Node会转换成TreeNode，提高查找速度。</p><h4 id="put执行流程？"><a href="#put执行流程？" class="headerlink" title="put执行流程？"></a>put执行流程？</h4><p>在put的时候需要锁住Segment，保证并发安全。调用get的时候不加锁，因为node数组成员val和指针next是用volatile修饰的，更改后的值会立刻刷新到主存中，保证了可见性，node数组table也用volatile修饰，保证在运行过程对其他线程具有可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 操作流程：</p><ol><li>如果table没有初始化就先进行初始化过程</li><li>使用hash算法计算key的位置</li><li>如果这个位置为空则直接CAS插入，如果不为空的话，则取出这个节点来</li><li>如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</li><li>如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作，这里有两种情况，一种是链表形式就直接遍历到尾端插入或者覆盖掉相同的key，一种是红黑树就按照红黑树结构插入</li><li>链表的数量大于阈值8，就会转换成红黑树的结构或者进行扩容（table长度小于64）</li><li>添加成功后会检查是否需要扩容</li></ol><h4 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h4><p>数组扩容transfer方法中会设置一个步长，表示一个线程处理的数组长度，最小值是16。在一个步长范围内只有一个线程会对其进行复制移动操作。</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>写时复制。当我们往容器添加元素时，不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。这样做的好处就是可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); //add方法需要加锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1); //复制新数组</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements); //原容器的引用指向新容器</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。</p><p><code>CopyOnWriteArrayList</code>中add方法添加的时候是需要加锁的，保证同步，避免了多线程写的时候复制出多个副本。读的时候不需要加锁，如果读的时候有其他线程正在向<code>CopyOnWriteArrayList</code>添加数据，还是可以读到旧的数据。</p><p><strong>缺点：</strong></p><ul><li>内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。</li><li>CopyOnWrite容器不能保证数据的实时一致性，可能读取到旧数据。</li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>非阻塞队列。高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，通过 CAS 操作实现。</p><p>如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。适合在对性能要求相对较高，同时有多个线程对队列进行读写的场景。</p><p><strong>非阻塞队列中的几种主要方法：</strong> <code>add(E e)</code>: 将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常； <code>remove()</code>：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常； <code>offer(E e)</code>：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false； <code>poll()</code>：移除并获取队首元素，若成功，则返回队首元素；否则返回null； <code>peek()</code>：获取队首元素，若成功，则返回队首元素；否则返回null</p><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是<code>java.util.concurrent</code>包下重要的数据结构，<code>BlockingQueue</code>提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于<code>BlockingQueue</code>实现的。<code>BlockingQueue</code> 适合用于作为数据共享的通道。</p><p>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</p><p>阻塞队列和一般的队列的区别就在于：</p><ol><li>多线程支持，多个线程可以安全的访问队列</li><li>阻塞操作，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满</li></ol><p><strong>方法</strong></p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><p><strong>原理</strong></p><p>JDK使用通知模式实现阻塞队列。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p>ArrayBlockingQueue使用Condition来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 队列为空时，阻塞当前消费者</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     notEmpty.signal(); <span class="comment">// 队列不为空时，通知消费者获取元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/843288">https://www.nowcoder.com/discuss/843288</a></p><p>[2] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[3] <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/java-collection-questions-02">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/post/1365080245.html"/>
      <url>/post/1365080245.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>JVM内存结构分为5大区域，<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>、<strong>方法区</strong>。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>局部变量表是用于存放方法参数和方法内的局部变量。</p><p>每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，在方法调用过程中，会进行动态链接，将这个符号引用转化为直接引用。</p><ul><li>部分符号引用在类加载阶段的时候就转化为直接引用，这种转化就是静态链接 </li><li>部分符号引用在运行期间转化为直接引用，这种转化就是动态链接</li></ul><p>Java 虚拟机栈也是线程<strong>私有</strong>的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><p>可以通过<code>-Xss</code>参数来指定每个线程的虚拟机栈内存大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M</span><br></pre></td></tr></table></figure><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆用于存放对象实例，是垃圾收集器管理的主要区域，因此也被称作<code>GC</code>堆。堆可以细分为：新生代（<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间）和老年代。</p><p>通过 <code>-Xms</code>设定程序启动时占用内存大小，通过<code>-Xmx</code>设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出<code>OutOfMemory</code>异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>对方法区进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>。</p><p><strong>永久代</strong></p><p>方法区是 JVM 的规范，而永久代<code>PermGen</code>是方法区的一种实现方式，并且只有 <code>HotSpot</code> 有永久代。对于其他类型的虚拟机，如<code>JRockit</code>没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的场景比较容易出现永久代的内存溢出。</p><p><strong>元空间</strong></p><p>JDK 1.8 的时候，<code>HotSpot</code>的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。</p><p>为什么要将永久代替换为元空间呢?</p><p>永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>NIO的Buffer提供了DirectBuffer，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。</p><p>直接内存的读写操作比堆内存快，可以提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。</p><h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><ul><li>堆的<strong>物理地址分配</strong>是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</li><li>堆存放的是<strong>对象的实例和数组</strong>；栈存放的是<strong>局部变量，操作数栈，返回结果</strong>等。</li><li>堆是<strong>线程共享</strong>的；栈是<strong>线程私有</strong>的。</li></ul><h3 id="什么情况下会发生栈溢出？"><a href="#什么情况下会发生栈溢出？" class="headerlink" title="什么情况下会发生栈溢出？"></a>什么情况下会发生栈溢出？</h3><ul><li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出<code>StackOverFlowError</code>异常。这种情况通常是因为方法递归没终止条件。 </li><li>新建线程的时候没有足够的内存去创建对应的虚拟机栈，虚拟机会抛出<code>OutOfMemoryError</code>异常。比如线程启动过多就会出现这种情况。</li></ul><h2 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="https://s2.loli.net/2022/03/14/LPsfMauw3Q6dAkm.png"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池中定位</strong>到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://s2.loli.net/2022/03/14/xioUgrwnPjV1sz5.png"></p><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p><h4 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h4><p>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><img src="https://s2.loli.net/2022/03/14/FoHXNka4wS7upbU.png" style="zoom: 50%;" /><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><img src="https://s2.loli.net/2022/03/14/cgGJynRxq9o7fC5.png" style="zoom:50%;" /><p>总结：使用句柄最大的好处就是reference中存储的是稳定句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="GC是什么？为什么要GC？"><a href="#GC是什么？为什么要GC？" class="headerlink" title="GC是什么？为什么要GC？"></a>GC是什么？为什么要GC？</h3><p>GC（<code>Garbage Collection</code>），垃圾回收，是Java与C++的主要区别之一。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清理机制。对JVM中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><h3 id="Minor-GC-和-Full-GC的区别？"><a href="#Minor-GC-和-Full-GC的区别？" class="headerlink" title="Minor GC 和 Full GC的区别？"></a>Minor GC 和 Full GC的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code>会频繁执行，执行的速度一般也会比较快。</li><li><strong>Full GC</strong>：回收老年代和新生代，老年代的对象存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</li></ul><h3 id="Full-GC-的触发条件？"><a href="#Full-GC-的触发条件？" class="headerlink" title="Full GC 的触发条件？"></a>Full GC 的触发条件？</h3><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p><p><strong>调用 System.gc()</strong></p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p><strong>老年代空间不足</strong></p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p><strong>空间分配担保失败</strong></p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><p><strong>JDK 1.7 及以前的永久代空间不足</strong></p><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code></p><h3 id="内存的分配策略"><a href="#内存的分配策略" class="headerlink" title="内存的分配策略"></a>内存的分配策略</h3><p><strong>对象优先在 Eden 分配</strong></p><p>大多数情况下，对象在新生代 <code>Eden</code> 上分配，当 <code>Eden</code> 空间不够时，触发 <code>Minor GC</code>。</p><p><strong>大对象直接进入老年代</strong></p><p>大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 <code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配。</p><p><strong>长期存活的对象进入老年代</strong></p><p>通过参数 <code>-XX:MaxTenuringThreshold</code> 可以设置对象进入老年代的年龄阈值。对象在<code>Survivor</code>区每经过一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p><p><strong>动态对象年龄判定</strong></p><p>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 <code>MaxTenuringThreshold</code> 年龄阈值。</p><p><strong>空间分配担保</strong></p><p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值为不允许担保失败，那么就要进行一次 <code>Full GC</code>。</p><h3 id="如何判断对象死亡？"><a href="#如何判断对象死亡？" class="headerlink" title="如何判断对象死亡？"></a>如何判断对象死亡？</h3><p>对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：<strong>引用计数法</strong>和<strong>可达性分析</strong>。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p>这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，<code>obj1</code> 和 <code>obj2</code> 互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">obj1.instance = obj2;</span><br><span class="line">obj2.instance = obj1;</span><br><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>通过<code>GC Root</code>对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到<code>GC Root</code>没有任何的引用链相连时，说明这个对象是不可用的。</p><p><img src="https://s2.loli.net/2022/03/14/PZqXl1I6BF9EQjW.png"></p><p>可作为 <strong>GC Roots 的对象</strong>包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类?"></a>如何判断一个类是无用的类?</h3><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>首先利用可达性去遍历内存，把存活对象和垃圾对象进行标记。标记结束后统一将所有标记的对象回收掉。这种垃圾回收算法效率较低，并且会<strong>产生大量不连续的空间碎片</strong>。</p><img src="https://s2.loli.net/2022/03/14/xQ8X3CecNltYKfA.png" style="zoom:80%;" /><h4 id="复制清除算法"><a href="#复制清除算法" class="headerlink" title="复制清除算法"></a>复制清除算法</h4><p>半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程仍然与<code>标记-清除</code>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><img src="https://s2.loli.net/2022/03/14/vzUFNKVo89pdxZO.png" style="zoom:80%;" /><h4 id="分类收集算法"><a href="#分类收集算法" class="headerlink" title="分类收集算法"></a>分类收集算法</h4><p>根据各个年代的特点采用最适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用复制算法</li><li>老年代使用标记清除算法或者标记整理算法</li></ul><p>在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记-清理或者标记-整理算法进行垃圾回收。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器主要分为以下几种：<code>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1</code>。</p><p>这7种垃圾收集器的特点：</p><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代&#x2F;老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU环境下的Client模式</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或B&#x2F;S系统服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>both</td><td>标记-整理+复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换CMS</td></tr></tbody></table><p><strong>Serial 收集器</strong></p><p><strong>单线程收集器</strong>，使用一个垃圾收集线程去进行垃圾回收，在进行垃圾回收的时候必须暂停其他所有的工作线程（ <code>Stop The World</code> ），直到它收集结束。</p><p>特点：简单高效；内存消耗小；没有线程交互的开销，单线程收集效率高；需暂停所有的工作线程，用户体验不好。</p><p><strong>ParNew 收集器</strong></p><p><code>Serial</code>收集器的<strong>多线程版本</strong>，除了使用多线程进行垃圾收集外，其他行为、参数与 <code>Serial</code> 收集器基本一致。</p><p><strong>Parallel Scavenge 收集器</strong></p><p><strong>新生代收集器</strong>，基于<strong>复制清除算法</strong>实现的收集器。特点是<strong>吞吐量优先</strong>，能够并行收集的多线程收集器，允许多个垃圾回收线程同时运行，降低垃圾收集时间，提高吞吐量。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值（<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>）。<code>Parallel Scavenge</code> 收集器关注点是<strong>吞吐量，高效率的利用 CPU 资源</strong>。<code>CMS</code> 垃圾收集器关注点更多的是<strong>用户线程的停顿时间</strong>。</p><p><code>Parallel Scavenge</code>收集器提供了两个参数用于<strong>精确控制吞吐量</strong>，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</p><ul><li><code>-XX：MaxGCPauseMillis</code>参数的值是一个大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过用户设定值。</li><li><code>-XX：GCTimeRatio</code>参数的值大于0小于100，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</li></ul><p><strong>Serial Old 收集器</strong></p><p><code>Serial</code> 收集器的老年代版本，单线程收集器，使用<strong>标记整理算法</strong>。</p><p><strong>Parallel Old 收集器</strong></p><p><code>Parallel Scavenge</code> 收集器的老年代版本。多线程垃圾收集，使用<strong>标记整理算法</strong>。</p><p><strong>CMS 收集器</strong></p><p><code>Concurrent Mark Sweep</code> ，并发标记清除，追求获取<strong>最短停顿时间</strong>，实现了让<strong>垃圾收集线程与用户线程基本上同时工作</strong>。</p><p><code>CMS</code> 垃圾回收基于<strong>标记清除算法</strong>实现，整个过程分为四个步骤：</p><ul><li>初始标记： 暂停所有用户线程（<code>Stop The World</code>），记录直接与 <code>GC Roots</code> 直接相连的对象 。</li><li>并发标记：从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程。</li><li>重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。</li><li>并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。</li></ul><p>在整个过程中，耗时最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程都可以与用户线程一起工作，所以从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</p><p><strong>优点</strong>：并发收集，停顿时间短。</p><p><strong>缺点</strong>：</p><ul><li>标记清除算法导致收集结束有<strong>大量空间碎片</strong>。</li><li><strong>产生浮动垃圾</strong>，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在标记过程之后，<code>CMS</code>无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；</li></ul><p><strong>G1收集器</strong></p><p>G1垃圾收集器的目标是在不同应用场景中<strong>追求高吞吐量和低停顿之间的最佳平衡</strong>。</p><p>G1将整个堆分成相同大小的分区（<code>Region</code>），有四种不同类型的分区：<code>Eden、Survivor、Old和Humongous</code>。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定。<code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。</p><h4 id="CMS收集器和G1收集器的区别？"><a href="#CMS收集器和G1收集器的区别？" class="headerlink" title="CMS收集器和G1收集器的区别？"></a>CMS收集器和G1收集器的区别？</h4><p><strong>使用范围不一样</strong></p><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 </li><li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li></ul><p><strong>STW的时间</strong></p><ul><li>CMS收集器以最小的停顿时间为目标的收集器。 </li><li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</li></ul><p><strong>垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 </li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><p><strong>垃圾回收过程不一样</strong></p><h2 id="类相关知识"><a href="#类相关知识" class="headerlink" title="类相关知识"></a>类相关知识</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>Class 文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//类文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//类的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类的索引</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数如下：</p><p><strong>魔数</strong>：<code>class</code>文件标志。</p><p><strong>文件版本</strong>：高版本的 Java 虚拟机可以执行低版本编译器生成的类文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的类文件。</p><p><strong>常量池</strong>：存放字面量和符号引用。字面量类似于 Java 的常量，如字符串，声明为<code>final</code>的常量值等。符号引用包含三类：类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。</p><p><strong>访问标志</strong>：识别类或者接口的访问信息，比如这个<code>Class</code>是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型等等。</p><p><strong>当前类的索引</strong>：类索引用于确定这个类的全限定名。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>一个类的完整生命周期如下：</p><p><img src="https://s2.loli.net/2022/03/14/dBRNrygsQpSk65P.png"></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><strong>加载</strong></p><ol><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区类信息的访问入口</li></ol><p><strong>验证</strong></p><p>确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p><strong>准备</strong></p><p>为类变量分配内存并设置类变量初始值的阶段。</p><p><strong>解析</strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p><p><strong>初始化</strong></p><p>开始执行类中定义的<code>Java</code>代码，初始化阶段是调用类构造器的过程。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ul><li><strong>启动类加载器</strong>：用来加载 Java 核心类库，无法被 Java 程序直接引用。</li><li><strong>扩展类加载器</strong>：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>：它根据应用的类路径来加载 Java 类。可通过<code>ClassLoader.getSystemClassLoader()</code>获取它。</li><li><strong>自定义类加载器</strong>：通过继承<code>java.lang.ClassLoader</code>类的方式实现。</li></ul><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求<strong>委派</strong>给父类加载器去完成，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p><img src="https://s2.loli.net/2022/03/14/Op9Yfw56ankmB3o.png"></p><h4 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h4><p>双亲委派模型的好处：可以防止内存中出现多份同样的字节码。如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个<code>java.lang.Object</code>的同名类并放在<code>ClassPath</code>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的<code>Object</code>类，那么类之间的比较结果及类的唯一性将无法保证。</p><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[2] <a href="https://javaguide.cn/java/jvm">https://javaguide.cn/java/jvm</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/post/4159564061.html"/>
      <url>/post/4159564061.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p><strong>面向过程</strong>：</p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展。</li></ul><p><strong>面向对象</strong>：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li><li>缺点：性能比面向过程低。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>封装</strong></p><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 </p><p><strong>继承</strong></p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 </p><p><strong>多态性</strong></p><p>它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</p><ul><li>编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。 </li><li>运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-中的八种基本数据类型"><a href="#Java-中的八种基本数据类型" class="headerlink" title="Java 中的八种基本数据类型"></a>Java 中的八种基本数据类型</h3><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><h3 id="Java语言关键字有哪些？"><a href="#Java语言关键字有哪些？" class="headerlink" title="Java语言关键字有哪些？"></a>Java语言关键字有哪些？</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="final、finally、finalize的区别？"><a href="#final、finally、finalize的区别？" class="headerlink" title="final、finally、finalize的区别？"></a>final、finally、finalize的区别？</h3><p>final 用于修饰变量、方法和类。</p><ul><li>final 变量：被修饰的变量不可变，不可变分为<code>引用不可变</code>和<code>对象不可变</code>，final 指的是<code>引用不可变</code>，final 修饰的变量必须初始化，通常称被修饰的变量为<code>常量</code>。 </li><li>final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。 </li><li>final 类：被修饰的类不能被继承，所有方法不能被重写。</li></ul><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p><h3 id="访问修饰符public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 </li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong> </li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法 </li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="对象相等的判断"><a href="#对象相等的判断" class="headerlink" title="对象相等的判断"></a>对象相等的判断</h2><h3 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p><strong>equals()</strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法</p><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 hashCode值必须是相等。也就是说如果 equals&#96;方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><p>如果重写 equals()时没有重写 hashCode()方法的话就可能会导致 equals方法判断是相等的两个对象，hashCode值却不相等。</p><h3 id="java-创建对象有哪几种方式？"><a href="#java-创建对象有哪几种方式？" class="headerlink" title="java 创建对象有哪几种方式？"></a>java 创建对象有哪几种方式？</h3><p>java中提供了以下四种创建对象的方式:</p><ul><li>new创建新对象 </li><li>通过反射机制 </li><li>采用clone机制 </li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><h3 id="String-StringBuffer-StringBuilder-的区别是什么？"><a href="#String-StringBuffer-StringBuilder-的区别是什么？" class="headerlink" title="String,StringBuffer, StringBuilder 的区别是什么？"></a>String,StringBuffer, StringBuilder 的区别是什么？</h3><p>1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。<strong>对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.</strong></p><p>String类利用了final修饰的char类型数组存储字符，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure><p>2.是否多线程安全。</p><p>String中的对象是不可变的，也就可以理解为常量，显然线程安全。</p><p>StringBuilder是非线程安全的。</p><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><p>1.便于实现字符串池（String pool）</p><p>在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p><p>2.使多线程安全</p><p>在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。</p><p>3.避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p><p>4.加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p><p>总体来说，String不可变的原因要包括<strong>设计考虑</strong>，<strong>效率优化</strong>，以及<strong>安全性</strong>这三大方面。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><blockquote><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></blockquote><h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h3><ul><li>Integer是int的包装类；int是基本数据类型； </li><li>Integer变量必须实例化后才能使用；int变量不需要； </li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； </li><li>Integer的默认值是null；int的默认值是0。</li></ul><h3 id="两个new生成的Integer变量的对比"><a href="#两个new生成的Integer变量的对比" class="headerlink" title="两个new生成的Integer变量的对比"></a>两个new生成的Integer变量的对比</h3><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Integer变量和int变量的对比"><a href="#Integer变量和int变量的对比" class="headerlink" title="Integer变量和int变量的对比"></a>Integer变量和int变量的对比</h3><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c=<span class="number">10000</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="非new生成的Integer变量和new-Integer-生成变量的对比"><a href="#非new生成的Integer变量和new-Integer-生成变量的对比" class="headerlink" title="非new生成的Integer变量和new Integer()生成变量的对比"></a>非new生成的Integer变量和new Integer()生成变量的对比</h3><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c= <span class="number">10000</span>;</span><br><span class="line">System.out.println(b == c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="两个非new生成的Integer对象的对比"><a href="#两个非new生成的Integer对象的对比" class="headerlink" title="两个非new生成的Integer对象的对比"></a>两个非new生成的Integer对象的对比</h3><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ul><li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。</li></ul><h3 id="反射使用的步骤？"><a href="#反射使用的步骤？" class="headerlink" title="反射使用的步骤？"></a>反射使用的步骤？</h3><ol><li>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ol><li><strong>对象序列化可以实现分布式对象。</strong></li></ol><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><p>​    2. <strong>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong> </p><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p><ol start="3"><li><strong>序列化可以将内存中的类写入文件或数据库中。</strong></li></ol><p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p><p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p><ol start="4"><li><strong>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ol><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><h3 id="序列化实现的方式有哪些？"><a href="#序列化实现的方式有哪些？" class="headerlink" title="序列化实现的方式有哪些？"></a>序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p>两种序列化的对比:</p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="什么是serialVersionUID？"><a href="#什么是serialVersionUID？" class="headerlink" title="什么是serialVersionUID？"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性</p><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h3><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。 </li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li></ul><h3 id="非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？"><a href="#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？" class="headerlink" title="非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？"></a>非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h3><p>非受检查异常：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：<code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等。</p><p>受检查异常：是Exception 中除 <code>RuntimeException</code> 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p><p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p><h3 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h3 id="Java常见异常有哪些？"><a href="#Java常见异常有哪些？" class="headerlink" title="Java常见异常有哪些？"></a>Java常见异常有哪些？</h3><ul><li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 </li><li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. </li><li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 </li><li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 </li><li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 </li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 </li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。 </li><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 </li><li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 </li><li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 </li><li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 </li><li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 </li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 </li><li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 </li><li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="常用的通配符有哪些？"><a href="#常用的通配符有哪些？" class="headerlink" title="常用的通配符有哪些？"></a>常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的IO-流分为几种？"><a href="#Java的IO-流分为几种？" class="headerlink" title="Java的IO 流分为几种？"></a>Java的IO 流分为几种？</h3><ul><li>按照流的方向：输入流（inputStream）和输出流（outputStream）； </li><li>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）； </li><li>按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。</li></ul><h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><ul><li>读写的时候字节流是按字节读写，字符流按字符读写。 </li><li>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。 </li><li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 </li><li>只是读写文件，和文件内容无关时，一般选择字节流。</li></ul><h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 </p><img src="https://s2.loli.net/2022/03/13/6YqGgnEKibOeA3W.png" style="zoom:67%;" /><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。 </p><img src="https://s2.loli.net/2022/03/13/BUk9fdSj63tl4OA.png" style="zoom:67%;" /><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p><img src="https://s2.loli.net/2022/03/13/V76rpuQP2SXk81f.png" style="zoom:67%;" /><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/853116">Java基础八股文连环80问_笔经面经_牛客网 (nowcoder.com)</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序连接阿里云实战</title>
      <link href="/post/1096404487.html"/>
      <url>/post/1096404487.html</url>
      
        <content type="html"><![CDATA[<p>本次实验有两个物联网设备接入阿里云物联网平台，具体的数据转发流程如下所示：</p><ul><li>温湿度传感器：设备上传数据→物联网平台接收→规则引擎转发→小程序接收到数据</li><li>台灯：小程序发送指令→物联网平台接收→规则引擎转发→台灯接收指令</li></ul><p>其中，规则引擎的作用是进行数据的转发，要进行设备之间的通信，并不是直接进行点对点的通信，而是进行中间平台的转发，下图基本上解释了这个过程。</p><p><img src="https://s2.loli.net/2022/03/17/SLKeIj9QJYhfRx1.png"></p><p>微信小程序进行温湿度传感器数值的接受与解析，同时具有上传控制台灯指令的功能，下面对小程序的开发进行详细介绍。</p><h3 id="创建工程并导入第三方库"><a href="#创建工程并导入第三方库" class="headerlink" title="创建工程并导入第三方库"></a>创建工程并导入第三方库</h3><p>如上述的入门小程序开发所示，创建示例工程；在此基础上添加第三方库，才能进行mqtt的数据转发。</p><ul><li>mqtt.js：<a href="https://unpkg.com/mqtt/dist/mqtt.min.js%EF%BC%8C%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%EF%BC%8C%E5%8F%B3%E9%94%AE%E5%8F%A6%E5%AD%98%E4%B8%BA%E5%8D%B3%E5%8F%AF">https://unpkg.com/mqtt/dist/mqtt.min.js，点击进入，右键另存为即可</a></li><li>hex_hmac_sha1.js：<a href="https://github.com/xihu-fm/aliyun-iot-client-sdk%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E5%B0%86%E5%AF%B9%E5%BA%94%E7%9A%84js%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%E5%8D%B3%E5%8F%AF">https://github.com/xihu-fm/aliyun-iot-client-sdk，下载完将对应的js文件提取出来即可</a></li></ul><p>然后将这两个放在工程目录里的utils下，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/gzqQGOST2bVuCmJ.png"></p><h3 id="WXML界面设计"><a href="#WXML界面设计" class="headerlink" title="WXML界面设计"></a>WXML界面设计</h3><p>本实例实现需要输入框用于输入用户三元组，文本信息的显示以及用户的操作（设备上线、设备下线、开灯、关灯），所以在index.json中添加本次实例构建所需要的组件依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-field&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/field/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-divider&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/divider/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-slider&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/slider/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/icon/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-row&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/row/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-col&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/col/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加三个输入框用于填写设备的三元组信息，其wxml代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-cell-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;productKey&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;productKey:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;deviceName&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;deviceName:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;deviceSecret&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;deviceSecret:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-cell-group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其在小程序中显示效果如图下所示：</p><p><img src="https://s2.loli.net/2022/03/17/ITuQmFvHYtaEVk6.png"></p><p>添加Slider滑块用于显示当前的温湿度信息，同时设置disable防止误触修改获取到的信息，其wxml代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>湿度：<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-slider</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;shidu&#125;&#125;&quot;</span> <span class="attr">use-button-slot</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;custom-button&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;shidu&#125;&#125;%</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-slider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>温度：<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-slider</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;wendu&#125;&#125;&quot;</span> <span class="attr">use-button-slot</span> <span class="attr">disabled</span> <span class="attr">bar-height</span>=<span class="string">&quot;4px&quot;</span> <span class="attr">active-color</span>=<span class="string">&quot;#ee0a24&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;custom-button&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;wendu&#125;&#125;°C</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-slider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>温度、湿度为0时无显示效果，所以将初始值设为50，其效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qPukUM62xdHSjLp.png"></p><p>接下来设置四个按钮，用于设备上线、设备下线、开灯、关灯；其wxml代码如下所示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;5&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;turn_on&quot;</span>&gt;</span>开灯<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;online&quot;</span>&gt;</span>设备上线<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line">&lt;van-buttontype=&quot;danger&quot; bind:click=&quot;offline&quot;&gt;设备下线<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;5&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;turn_off&quot;</span>&gt;</span>关灯<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其显示效果如图下所示：</p><p><img src="https://s2.loli.net/2022/03/17/a7LUwdOWkyP23t6.png"></p><h3 id="JS功能实现"><a href="#JS功能实现" class="headerlink" title="JS功能实现"></a>JS功能实现</h3><p>定义全局变量，导入工具类，设置设备三元组信息（将*替换为自己的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client;</span><br><span class="line"><span class="keyword">var</span> mqtt=<span class="built_in">require</span>(<span class="string">&#x27;../../utils/mqtt.min.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> crypto=<span class="built_in">require</span>(<span class="string">&#x27;../../utils/hex_hmac_sha1.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> deviceConfig=&#123;</span><br><span class="line"><span class="attr">productKey</span>:<span class="string">&quot;**********&quot;</span>,</span><br><span class="line"><span class="attr">deviceName</span>:<span class="string">&quot; **********&quot;</span>,</span><br><span class="line"><span class="attr">deviceSecret</span>:<span class="string">&quot;**********&quot;</span>,</span><br><span class="line"><span class="attr">regionId</span>:<span class="string">&quot; **********&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置data，用于与前端页面交互，共设置6个参数。“productKey”、“deviceName”、“deviceSecret”直接初始化定义为“deviceConfig”内的属性，也可以通过客户端输入修改；“wendu”、“shidu”两个个字段分别代表温度、湿度数值；其具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">productKey</span>:deviceConfig.<span class="property">productKey</span>,</span><br><span class="line"><span class="attr">deviceName</span>:deviceConfig.<span class="property">deviceName</span>,</span><br><span class="line"><span class="attr">deviceSecret</span>:deviceConfig.<span class="property">deviceSecret</span>,</span><br><span class="line"><span class="attr">wendu</span>:<span class="number">50</span>,</span><br><span class="line"><span class="attr">shidu</span>:<span class="number">50</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>对基本的参数定义后，实现mqtt协议的基础工具类：</p><p>IoT平台mqtt连接参数初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initMqttOptions</span>(<span class="params">deviceConfig</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> params=&#123;</span><br><span class="line"><span class="attr">productKey</span>:deviceConfig.<span class="property">productKey</span>,</span><br><span class="line"><span class="attr">deviceName</span>:deviceConfig.<span class="property">deviceName</span>,</span><br><span class="line"><span class="attr">timestamp</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">clientId</span>:<span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substr</span>(<span class="number">2</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CONNECT参数</span></span><br><span class="line"><span class="keyword">const</span> options=&#123;</span><br><span class="line"><span class="attr">keepalive</span>:<span class="number">60</span>,         <span class="comment">//60s</span></span><br><span class="line"><span class="attr">clean</span>:<span class="literal">true</span>,           <span class="comment">//cleanSession不保持持久会话</span></span><br><span class="line"><span class="attr">protocolVersion</span>:<span class="number">4</span>   <span class="comment">//MQTTv3.1.1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.生成clientId，username，password</span></span><br><span class="line">options.<span class="property">password</span>=<span class="variable language_">this</span>.<span class="title function_">signHmacSha1</span>(params, deviceConfig.<span class="property">deviceSecret</span>);</span><br><span class="line">options.<span class="property">clientId</span>=<span class="string">`<span class="subst">$&#123;params.clientId&#125;</span>|securemode=2,signmethod=hmacsha1,timestamp=<span class="subst">$&#123;params.timestamp&#125;</span>|`</span>;</span><br><span class="line">options.<span class="property">username</span>=<span class="string">`<span class="subst">$&#123;params.deviceName&#125;</span>&amp;<span class="subst">$&#123;params.productKey&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">return</span> options;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>生成基于HmacSha1的password，参考文档：<a href="https://help.aliyun.com/document_detail/73742.html">https://help.aliyun.com/document_detail/73742.html</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">signHmacSha1(params<span class="punctuation">,</span>deviceSecret)<span class="punctuation">&#123;</span></span><br><span class="line">let keys=Object.keys(params).sort();</span><br><span class="line"><span class="comment">//按字典序排序</span></span><br><span class="line">Keys=keys.sort();</span><br><span class="line">const list=<span class="punctuation">[</span><span class="punctuation">]</span>;</span><br><span class="line">keys.map((key)=&gt;<span class="punctuation">&#123;</span></span><br><span class="line">list.push(`$<span class="punctuation">&#123;</span>key<span class="punctuation">&#125;</span>$<span class="punctuation">&#123;</span>params<span class="punctuation">[</span>key<span class="punctuation">]</span><span class="punctuation">&#125;</span>`);</span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br><span class="line">const contentStr=list.join(&#x27;&#x27;);</span><br><span class="line">return crypto.hex_hmac_sha1(deviceSecret<span class="punctuation">,</span>contentStr);</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后实现对按钮的绑定功能事件的实现：</p><p>设备上线：对设备三元组信息进行初始化，使用三元组连接阿里云，并通过“client.on（）”进行监听，将获取到的温湿度数值绑定“wendu”、“shidu”变量，最后在小程序中显示，其实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">online</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">varthat=<span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> options=<span class="variable language_">this</span>.<span class="title function_">initMqttOptions</span>(deviceConfig);</span><br><span class="line"><span class="comment">//连接阿里云</span></span><br><span class="line">client=mqtt.<span class="title function_">connect</span>(<span class="string">&#x27;wxs://&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;.iot-as-mqtt.cn-shanghai.aliyuncs.com&#x27;</span>,options)</span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接服务器成功&#x27;</span>)</span><br><span class="line"><span class="comment">//订阅主题(这里的主题可能会不一样，具体请查看后台设备Topic列表或使用自定义主题)</span></span><br><span class="line">client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/sys/&#x27;</span>+<span class="string">`<span class="subst">$&#123;deviceConfig.productKey&#125;</span>`</span>+<span class="string">&#x27;/&#x27;</span>+<span class="string">`<span class="subst">$&#123;deviceConfig.deviceName&#125;</span>`</span>+<span class="string">&#x27;/thing/service/property/set&#x27;</span>,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!err)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;订阅成功！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接收消息监听</span></span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">topic,message</span>)&#123;</span><br><span class="line">message=message.<span class="title function_">toString</span>()</span><br><span class="line">message=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(message)</span><br><span class="line"><span class="comment">//将接收到的字符串进行Json格式转换</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">that.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">wendu</span>:message[<span class="string">&#x27;items&#x27;</span>][<span class="string">&#x27;temp&#x27;</span>][<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line"><span class="attr">shidu</span>:message[<span class="string">&#x27;items&#x27;</span>][<span class="string">&#x27;hum&#x27;</span>][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>设备下线：将“client”连接关闭，并将“wendu”、“shidu”的值初始化为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">offline</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//client连接断开,关闭连接</span></span><br><span class="line">client.<span class="title function_">end</span>()</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">wendu</span>:<span class="number">0</span>,</span><br><span class="line"><span class="attr">shidu</span>:<span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设备断开连接&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开灯：定义发布链接，设置“Lightswitch”字段为1，通过发布函数将信息提交给阿里云</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turn_on</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> topics=<span class="string">&#x27;/sys/&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;/&#x27;</span>+deviceConfig.<span class="property">deviceName</span>+<span class="string">&#x27;/thing/event/property/post&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> payloadJson=&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="string">&quot;Lightswitch&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;thing.event.property.post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">client.<span class="title function_">publish</span>(topics,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payloadJson))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>关灯：与开灯基本没有区别，将“Lightswitch”字段设置为0即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turn_off</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> topics=<span class="string">&#x27;/sys/&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;/&#x27;</span>+deviceConfig.<span class="property">deviceName</span>+<span class="string">&#x27;/thing/event/property/post&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> payloadJson=&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="string">&quot;Lightswitch&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;thing.event.property.post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">client.<span class="title function_">publish</span>(topics,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payloadJson))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="实验整体流程"><a href="#实验整体流程" class="headerlink" title="实验整体流程"></a>实验整体流程</h3><p>在阿里云物联网平台添加三个设备（台灯、温湿度传感器、微信小程序），设置规则引擎（用于信息流转），将设备开启连接上云，同时微信小程序开启设备实现数据的监听，一段时间后收到云上的数据，在页面显示温湿度数值；同时可以点击开灯、关灯按钮实现对于台灯的控制</p><p><img src="https://s2.loli.net/2022/03/17/WN2e9JKgUZ7AcsH.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vant组件开发使用</title>
      <link href="/post/2204700370.html"/>
      <url>/post/2204700370.html</url>
      
        <content type="html"><![CDATA[<p>Vant是有赞前端团队开源的移动端组件库，于2016年开源，已持续维护4年时间。Vant对内承载了有赞所有核心业务，对外服务十多万开发者，是业界主流的移动端组件库之一。</p><p>目前Vant官方提供了Vue版本和<a href="http://vant-contrib.gitee.io/vant-weapp">微信小程序版本</a>，并由社区团队维护React版本。</p><h2 id="Vant组件安装"><a href="#Vant组件安装" class="headerlink" title="Vant组件安装"></a>Vant组件安装</h2><h3 id="通过npm方式安装"><a href="#通过npm方式安装" class="headerlink" title="通过npm方式安装"></a><strong>通过npm方式安装</strong></h3><p>先去node.js官网（<a href="https://nodejs.org/en/download/%EF%BC%89%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%EF%BC%8C%E6%9E%84%E5%BB%BAnpm%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%9C%A8cmd%E4%B8%AD%E6%89%A7%E8%A1%8C%60npm">https://nodejs.org/en/download/）下载安装，构建npm命令，在cmd中执行`npm</a> -v&#96;，如下图所示，即完成安装：</p><p><img src="https://s2.loli.net/2022/03/17/2yw4g1jXNLVGsZD.png"></p><p>进入小程序的项目中，如图打开小程序的项目路径的终端，在终端输入：<code>npm init</code>，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qnmO2p9LByAFkeQ.png"></p><p>紧接着在终端继续输入：<code>npm i @vant/weapp -S –production</code>，用于安装Vant组件，出现下图所示及代表下载完成</p><p><img src="https://s2.loli.net/2022/03/17/UVHnBof4Lde5qpX.png"></p><h3 id="构建npm包"><a href="#构建npm包" class="headerlink" title="构建npm包"></a><strong>构建npm包</strong></h3><p>打开微信开发者工具，点击工具→构建npm，并勾选使用npm模块选项，构建完成后，即可引入组件</p><p><img src="https://s2.loli.net/2022/03/17/3I7dTNXvRVZkDgy.png"></p><p>此时在目录树生成“miniprogram_npm”文件夹，如下图所示，Vant组件就下载完成了</p><p><img src="https://s2.loli.net/2022/03/17/GkyqXdBgLrPt3CM.png"></p><h3 id="修改app-json"><a href="#修改app-json" class="headerlink" title="修改app.json"></a><strong>修改app.json</strong></h3><p>将app.json中的”style”:”v2”去除，小程序的<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style">新版基础组件</a>强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱</p><h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a><strong>使用测试</strong></h3><p>以Button组件为例，只需要在app.json或index.json中配置Button对应的路径即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm安装</span></span><br><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果这种情况下没有出现报错情况，就可以正常使用了；如若出现错误，请按照下面方式修改：</p><p>在windows文件夹目录下，把miniprogram_npm@vant\weapp里的文件都删除</p><p><img src="https://s2.loli.net/2022/03/17/jTLOyUpbBc1PARu.png"></p><p>之后再打开<a href="https://github.com/youzan/vant-weapp">vant weapp</a>下载一份vant，将dist文件夹（vant-weapp-dev\vant-weapp-dev\dist）把dist文件夹复制到miniprogram_npm@vant\weapp下即可。</p><p><img src="https://s2.loli.net/2022/03/17/zicQEDyqwxb2f3L.png"></p><p>在app.json或index.json中修改配置Button对应的路径即可导入组件使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm安装</span></span><br><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Vant组件使用示例"><a href="#Vant组件使用示例" class="headerlink" title="Vant组件使用示例"></a>Vant组件使用示例</h2><h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>在index.json中修改配置Button对应的路径，用于定位Button组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van-button”为定义的标签名，“type”为当前按钮的样式类型，“bind:click”用于绑定当前按钮的点击事件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_default&quot;</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span><span class="attr">bind:click</span>=<span class="string">&quot;click_primary&quot;</span> &gt;</span>主要按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_info&quot;</span> &gt;</span>信息按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_warning&quot;</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_danger&quot;</span> &gt;</span>危险按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码（console.log用于在控制台输出信息，这个后面会经常用到，方便于调试）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">click_default</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击默认按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_primary</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击主要按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_info</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击信息按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_warning</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击警告按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_danger</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击危险按钮&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>可以在模拟器当中看到效果界面，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/H2Gp1z6bAxOnokq.png"></p><p>点击按钮后在输出栏会打印出信息，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/vTfAZVMtaElkeSy.png"></p><h3 id="Field输入框"><a href="#Field输入框" class="headerlink" title="Field输入框"></a>Field输入框</h3><p>在index.json中修改配置Field对应的路径，用于定位Field组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-field&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/field/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van-field”为定义的标签名，“placeholder”当输入框为空时显示的文本，“bind:change”为输入框添加修改绑定事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;&#123;&#123;value&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">bind:change</span>=<span class="string">&quot;onChange&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码，打印当前的输入值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">value</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">onChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="comment">//event.detail为当前输入的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">detail</span>);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以在模拟器当中看到效果界面，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/zBfoU8tumxknws2.png"></p><p>在输入框输入文本后，会在调试栏实时打印出来，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/kltau4yKwgnz8hS.png"></p><h3 id="Checkbox复选框"><a href="#Checkbox复选框" class="headerlink" title="Checkbox复选框"></a>Checkbox复选框</h3><p>在index.json中修改配置Checkbox对应的路径，用于定位Checkbox复选框组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-checkbox&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/checkbox/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van- checkbox”为定义的标签名，“value”绑定当前复选框的值，“bind:change”为复选框添加修改绑定事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-checkbox</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;checked&#125;&#125;&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;onChange&quot;</span>&gt;</span></span><br><span class="line">复选框</span><br><span class="line"><span class="tag">&lt;/<span class="name">van-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码，用于改变当前复选框的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">checked</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">onChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">checked</span>:event.<span class="property">detail</span>,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以点击复选框修改当前的状态，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/zHdgPGCUSTrbvDL.png"></p><h3 id="Layout布局"><a href="#Layout布局" class="headerlink" title="Layout布局"></a>Layout布局</h3><p>Layout提供了van-row和van-col两个组件来进行行列布局，在index.json中修改配置Layout对应的路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-row&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/row/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-col&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/col/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Layout组件提供了24列栅格，通过在Col上添加span属性设置列所占的宽度百分比；此外，添加offset属性可以设置列的偏移宽度，计算方式与span相同，在wxml中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;4&quot;</span>&gt;</span>span: 4<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;10&quot;</span><span class="attr">offset</span>=<span class="string">&quot;4&quot;</span>&gt;</span>offset: 4, span: 10<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">offset</span>=<span class="string">&quot;12&quot;</span> <span class="attr">span</span>=<span class="string">&quot;12&quot;</span>&gt;</span>offset: 12, span: 12<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其布局最终效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/24c7KL9XqVwFyEp.png"></p><p>通过gutter属性可以设置列元素之间的间距，默认间距为0，在wxml中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span> <span class="attr">gutter</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其布局最终效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/JnTvyGAa2Wxihc8.png"></p><p>更多相关组件的使用方法可以在<a href="https://vant-contrib.gitee.io/vant-weapp">Vant的官方说明文档</a>中查看</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发入门</title>
      <link href="/post/1597505920.html"/>
      <url>/post/1597505920.html</url>
      
        <content type="html"><![CDATA[<h2 id="微信开发者工具介绍"><a href="#微信开发者工具介绍" class="headerlink" title="微信开发者工具介绍"></a>微信开发者工具介绍</h2><p>为了帮助开发者简单和高效地开发和调试微信小程序，微信官方在原有的公众号网页调试工具的基础上，推出了全新的<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发者工具</a>，集成了公众号网页调试和小程序调试两种开发模式。</p><ul><li>使用公众号网页调试，开发者可以调试微信网页授权和微信JS-SDK</li><li>使用小程序调试，开发者可以完成小程序的API和页面的开发调试、代码查看和编辑、小程序预览和发布等功能。</li></ul><p>在<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发平台</a>可以直接下载，点击进入下载任意版本即可。使用安装包进行安装，一直点下一步即可（需要更换安装目录可自行配置）</p><p><img src="https://s2.loli.net/2022/03/17/9Sb5kVWvfNRsXyI.png"></p><h3 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h3><p><strong>登录页</strong></p><p>在登录页，可以使用微信扫码登录开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。</p><p><img src="https://s2.loli.net/2022/03/17/cBfd2gaO6F5ATxX.png"></p><p><strong>项目列表</strong></p><p>登录成功后，会看到已经存在的项目列表和代码片段列表，在项目列表可以选择公众号网页调试，进入到公众号网页调试模式</p><p><img src="https://s2.loli.net/2022/03/17/W3dsXC7g54ZwaOz.png"></p><p><strong>新建项目</strong></p><p>当符合以下条件时，可以在本地创建一个小程序项目：</p><ol><li>需要一个小程序的AppID；如没有AppID，可以选择申请使用测试号；</li><li>登录的微信号需要是该AppID的开发者；</li><li>需要选择一个空目录，或者选择的非空目录下存在app.json或者project.config.json。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。</li></ol><p><img src="https://s2.loli.net/2022/03/17/xA3okJEgwneXzRq.png"></p><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>开发者工具主界面，从上到下，从左到右，分别为：菜单栏、工具栏、模拟器、目录树、编辑区、调试器六大部分。</p><p><img src="https://s2.loli.net/2022/03/17/lRWGpF4Ls9uDqIo.png"></p><p><strong>菜单栏</strong></p><ol><li><p>项目</p><blockquote><p>新建项目：快速新建项目</p><p>打开最近：可以查看最近打开的项目列表，并选择是否进入对应项目</p><p>查看所有项目：新窗口打开启动页的项目列表页</p><p>关闭当前项目：关闭当前项目，回到启动页的项目列表页</p></blockquote></li><li><p>文件</p><blockquote><p>新建文件</p><p>保存</p><p>保存所有</p><p>关闭文件</p></blockquote></li><li><p>编辑：可以查看编辑相关的操作和快捷键</p></li><li><p>工具</p><blockquote><p>编译：编译当前小程序项目</p><p>刷新：与编译的功能一致，由于历史原因保留对应的快捷键ctrl+R</p><p>编译配置：可以选择普通编译或自定义编译条件</p><p>前后台切换：模拟客户端小程序进入后台运行和返回前台的操作</p><p>清除缓存：清除文件缓存、数据缓存、以及授权数据</p></blockquote></li><li><p>界面：控制主界面窗口模块的显示与隐藏</p></li><li><p>设置</p><blockquote><p>外观设置：控制编辑器的配色主题、字体、字号、行距</p><p>编辑设置：控制文件保存的行为，编辑器的表现</p><p>代理设置：选择直连网络、系统代理和手动设置代理</p><p>通知设置：设置是否接受某种类型的通知</p></blockquote></li></ol><p><strong>工具栏</strong></p><p>工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览；通过切后台按钮，可以模拟小程序进入后台的情况；工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。</p><p><img src="https://s2.loli.net/2022/03/17/NyEAMvsmbGqFIPD.png"></p><p>工具栏右侧是开发辅助功能的区域，在这里可以上传代码、版本管理、查看项目详情，如上图所示。</p><p><strong>模拟器</strong></p><p>模拟器可以模拟小程序在微信客户端的表现。小程序的代码通过编译后可以在模拟器上直接运行。开发者可以选择不同的设备，也可以添加自定义设备来调试小程序在不同尺寸机型上的适配问题。</p><p><img src="https://s2.loli.net/2022/03/17/Tzpx4mc9tihYSCj.png"></p><h2 id="你的第一个小程序"><a href="#你的第一个小程序" class="headerlink" title="你的第一个小程序"></a>你的第一个小程序</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的AppID，给你的项目起一个好听的名字，勾选”不使用云服务”（注意:你要选择一个空的目录才可以创建项目），点击新建，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在微信开发者工具中预览你的第一个小程序。</p><p><img src="https://s2.loli.net/2022/03/17/QqNxkPceW6igD1w.png"></p><p>点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。</p><p><img src="https://s2.loli.net/2022/03/17/Dwovtr1EFKuPVjZ.png"></p><h3 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h3><p>我们通过开发者工具快速创建了一个QuickStart项目。你可以留意到这个项目里边生成了不同类型的文件:</p><ul><li>.json后缀的JSON配置文件</li><li>.wxml后缀的WXML模板文件</li><li>.wxss后缀的WXSS样式文件</li><li>.js后缀的JS脚本逻辑文件</li></ul><p><strong>JSON配置</strong></p><p>JSON是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。</p><p>我们可以看到在项目的根目录有一个app.json和project.config.json，此外在pages&#x2F;logs目录下还有一个logs.json，我们依次来说明一下它们的用途。</p><ol><li><p>小程序配置app.jsonapp.json</p><p>小程序配置app.jsonapp.json是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部tab等。QuickStart项目里边的app.json配置内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;window&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;backgroundTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;light&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span><span class="string">&quot;#fff&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Weixin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;black&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>工具配置project.config.json</p><p>通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。</p><p>考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p></li><li><p>页面配置page.json</p><p>这里的page.json其实用来表示pages&#x2F;logs目录下的logs.json这类和小程序页面相关的配置。</p><p>如果你整个小程序的风格是蓝色调，那么你可以在app.json里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。</p></li></ol><p><strong>WXML 模板</strong></p><p>从事过网页编程的人知道，网页编程采用的是HTML+CSS+JS这样的组合，其中HTML是用来描述当前这个页面的结构，CSS用来描述页面的样子，JS通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中WXML充当的就是类似HTML的角色。打开pages&#x2F;index&#x2F;index.wxml，你会看到以下的内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span>获取头像昵称<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和HTML非常相似，WXML由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：</p><p>（1）标签名字有点不一样往往写 HTML 的时候，经常会用到的标签是div，p，span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。从上边的例子可以看到，小程序的WXML用的标签是view，button，text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。</p><p>（2）多了一些<code>wx:if</code>这样的属性以及<code>&#123;&#123; &#125;&#125;</code>这样的表达式在网页的一般开发流程中，我们通常会通过JS操作DOM（对应HTML的描述产生的树），以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS会记录一些状态到JS变量里边，同时通过DOM API操控DOM的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了MVVM的开发模式（例如React，Vue），提倡把渲染和逻辑分离。简单来说就是不要再让JS直接操控DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路，如果你需要把一个Hello World字符串显示在界面上。WXML是这么写:<code>&#123;&#123;msg&#125;&#125;JS</code>只需要管理状态即可:<code>this.setData(&#123;msg:&quot;Hello World&quot;&#125;)</code>通过<code>&#123;&#123; &#125;&#125;</code>的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要<code>if/else，for</code>等控制能力，在小程序里边，这些控制能力都用<code>wx:</code>开头的属性来表达。</p><p><strong>WXSS 样式</strong></p><p>WXSS具有CSS大部分的特性，小程序在WXSS也做了一些扩充和修改。</p><ol><li><p>新增了尺寸单位</p><p>在写CSS样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS在底层支持新的尺寸单位rpx，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</p></li><li><p>提供了全局的样式和局部样式</p><p>和前边app.json，page.json的概念相同，你可以写一个app.wxss作为全局样式，会作用于当前小程序的所有页面，局部页面样式page.wxss仅对当前页面生效。</p></li><li><p>此外WXSS仅支持部分CSS选择器</p></li></ol><p><strong>JS 逻辑交互</strong></p><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写JS脚本文件来处理用户的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序开发者工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（二）</title>
      <link href="/post/6004.html"/>
      <url>/post/6004.html</url>
      
        <content type="html"><![CDATA[<p>本文将接前文，继续讲述python程序对微信云开发数据库的操作。</p><h2 id="间接操作"><a href="#间接操作" class="headerlink" title="间接操作"></a>间接操作</h2><p>间接操作指的是python通过云函数对云开发数据库进行操作。所有的操作都是在获取access_token的前提下进行的，不懂的同学可以参考：链接: <a href="https://blog.csdn.net/qq_44001007/article/details/103944492">link</a>.<br>同时由于请求python请求云函数的代码基本类似，只有在data里面进行参数的变换即可，给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xxxx</span>(<span class="params">self</span>):</span><br><span class="line">    //在函数括号内需要添加参数</span><br><span class="line">    ACCESS_TOKEN = xxx   //获取的access_token</span><br><span class="line">    ENV = xxx                      //用户的数据库环境ID</span><br><span class="line">    FUNCTION_NAME = xxx   //所要执行的云函数名</span><br><span class="line">    url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=&#x27;</span> + ACCESS_TOKEN + <span class="string">&#x27;&amp;env=&#x27;</span> + ENV + <span class="string">&#x27;&amp;name=&#x27;</span> + FUNCTION_NAME</span><br><span class="line">    data = &#123;</span><br><span class="line">    //所要传输的参数</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url, data=json.dumps(data))</span><br><span class="line">    result = response.json()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>云函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.<span class="title function_">init</span>()</span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> db.<span class="title function_">createCollection</span>(event.<span class="property">id</span>)</span><br><span class="line">  <span class="comment">//event.id是python传输的数据，为该集合的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createCollection</span>(<span class="params">self，<span class="built_in">id</span></span>):</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="built_in">id</span>,</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h3><p>云函数：</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ndnSIM实现一发多收</title>
      <link href="/post/52359.html"/>
      <url>/post/52359.html</url>
      
        <content type="html"><![CDATA[<p>直接进入正题，想要实现一发多收，就是要在路由进行广播时转发的兴趣包与接收到数据包的数目相等，即For_num&#x3D;&#x3D;Rec_num；但正常情况下，路由在第一次接收到数据包时就会把pit条目删除，所以接下来的目的是在接收到数据包对删除pit的命令进行修改。</p><h2 id="pit条目修改"><a href="#pit条目修改" class="headerlink" title="pit条目修改"></a>pit条目修改</h2><p>先进入到ndnSIM源目录下</p><p><img src="https://s2.loli.net/2022/03/13/c1q9ETghuMdUK3w.png"></p><p>然后进入pit-entry.cpp&#x2F;.hpp所在目录，对这两个文件进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd NFD/daemon/table/</span><br></pre></td></tr></table></figure><p>先对hpp进行修改，添加For_NUM和Rec_NUM两个变量</p><p><img src="https://s2.loli.net/2022/03/13/ZDa2F4NlGQ5Ocwo.png"></p><p>然后添加获取参数的函数与对变量操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_RecNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Rec_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_ForNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> For_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_inter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> For_NUM++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Rec_NUM++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下进行参数的初始化定义，在cpp中实现</p><p><img src="https://s2.loli.net/2022/03/13/AESXW1HhkKRD3xe.png"></p><h2 id="转发策略修改"><a href="#转发策略修改" class="headerlink" title="转发策略修改"></a>转发策略修改</h2><h3 id="after-Recevie-Interest"><a href="#after-Recevie-Interest" class="headerlink" title="after Recevie Interest"></a>after Recevie Interest</h3><p>进入forwarder.cpp所在文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable constant_">NFD</span>/daemon/fw</span><br></pre></td></tr></table></figure><p>修改onOutgoingInterest（）函数</p><p><img src="https://s2.loli.net/2022/03/13/yH9XEQ1fVdRsglu.png"></p><h3 id="after-Recevie-data"><a href="#after-Recevie-data" class="headerlink" title="after Recevie data"></a>after Recevie data</h3><p>在同一个目录下打开strategy.cpp文件，对sendData（）函数进行修改</p><p><img src="https://s2.loli.net/2022/03/13/YxvCfIayOSl2L18.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行一个具有多个生产者的路由拓扑，查看路由接收的数据包数量，即可确认是否实现一发多收。</p><p><img src="https://s2.loli.net/2022/03/13/nkbEUVugKwcrqdZ.png"></p><p>有上图可以得出接收的是发送的两倍，实现一发多收。</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu安装ndnSIM</title>
      <link href="/post/57172.html"/>
      <url>/post/57172.html</url>
      
        <content type="html"><![CDATA[<p>通过对资料的查询获取相对应的版本号与ndnsim之间的关系：</p><table><thead><tr><th>操作系统</th><th>Ubuntu 18</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.7</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-ns-3.29</td></tr><tr><td>pybindgen</td><td>0.19.0</td></tr></tbody></table><p>如果想要安装其他版本，请找到上述条件所对应的版本号即可。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml</span><br><span class="line">sudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gi libgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip</span><br><span class="line">pip install pygraphviz pycairo PyGObject pygccxml</span><br><span class="line">sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config</span><br><span class="line">pip install pygraphviz</span><br></pre></td></tr></table></figure><p>可能出现报错无法安装的情况，我把后面的安装好，在安装前面的就成功了;同时这是Ubuntu18所需要的依赖环境，其他版本请参照官网。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>现在任意文件创建个ndnsim文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ndnSIM2.7</span><br></pre></td></tr></table></figure><p>然后进入该文件夹下，进行源码的下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>记住千万不要在最后一条命令按照官网的说法加上–recursive，这样就会把NFD和ndn-cxx模块直接下载最新版本，这样后面的操作就无效了。</p><h2 id="修改对应版本号"><a href="#修改对应版本号" class="headerlink" title="修改对应版本号"></a>修改对应版本号</h2><p>这里的命令依靠git实现，能到这一步肯定都安装好了，就不多说了。<br>首先进入到ndnSIM的核心源码地带</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>通过git checkout修改版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-2.7</span><br></pre></td></tr></table></figure><p>也可以通过git tag查看所有的版本号，然后修改为想要安装的版本</p><p><img src="https://img-blog.csdnimg.cn/20200725105311613.png"></p><p>然后安装NFD和ndn-cxx模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><p>接下来进入到ndnSIM2.7&#x2F;ns-3文件下进行版本的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-ns-3.29</span><br></pre></td></tr></table></figure><p>出现如图所示即为成功</p><p><img src="https://s2.loli.net/2022/03/12/LtPm79ICKAYwdrg.png"></p><p>接下对pybindgen的版本进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7/pybindgen</span><br><span class="line">git checkout 0.19.0</span><br></pre></td></tr></table></figure><p>然后在此目录下安装安装该python模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2022/03/12/fnUh7aDJ2MOErR5.png"></p><h2 id="运行编译"><a href="#运行编译" class="headerlink" title="运行编译"></a>运行编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.1/ns-3</span><br><span class="line">./waf configure --enable-examples</span><br><span class="line">./waf</span><br><span class="line">./waf --run ndn-simple --vis</span><br></pre></td></tr></table></figure><p>正常情况直接编译完成，出现错误的话请看下面的修改提示</p><p><img src="https://s2.loli.net/2022/03/12/B1fgyvZdDbkqxri.png"></p><p>进入到可视化模块下将‘file&#x3D;’删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  ndnSIM2.7/ns-3/src/visualizer/visualizer</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/12/q8nABHgkLvl2smt.png"></p><p>进入base.py文件，修改保存即可</p><p><img src="https://s2.loli.net/2022/03/12/ka8ywbI1o5YvpLj.png"></p><p>第二种错误可能出现在运行时加上–vis可视化模块时，如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/UDG7XjaZmOF3BuJ.png"></p><p>这种情况下，还是进入刚才的那个文件夹，修改hub.py文件</p><p><img src="https://s2.loli.net/2022/03/12/brEc9vg3pFwqhsj.png"></p><p>将from . import注释，修改为import core。再次运行就可以了</p><p><img src="https://s2.loli.net/2022/03/12/94Q7mq85lV1ekwz.png"></p><p>经过试验，添加Ubuntu16的对应版本</p><table><thead><tr><th>操作系统</th><th>Ubuntu 16</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.5</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-v2.5</td></tr><tr><td>pybindgen</td><td>0.18.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（一）</title>
      <link href="/post/34574.html"/>
      <url>/post/34574.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述python程序对微信云开发数据库的操作。</p><h1 id="直接操作"><a href="#直接操作" class="headerlink" title="直接操作"></a>直接操作</h1><p>直接操作指的是通过python程序对云开发数据库直接进行操作。<br>所有的操作前提都是在获取access_token下进行的，先通过下列代码获取access_token在进行接下来的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access_token</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           获取access_token</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        APPID = <span class="string">&#x27;**********&#x27;</span>                        //小程序ID</span><br><span class="line">        APPSECRET = <span class="string">&#x27;**************&#x27;</span>                //小程序秘钥</span><br><span class="line">        WECHAT_URL = <span class="string">&#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#x27;</span> + APPID + <span class="string">&#x27;&amp;secret=&#x27;</span> + APPSECRET</span><br><span class="line">        response = requests.get(WECHAT_URL)</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&quot;access_token&quot;</span>]     //将返回值解析获取access_token</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>此方法的创建只需要将集合的名字post给数据库即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseCollectionAdd</span>(<span class="params">access_token</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          创建数据库</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasecollectionadd?access_token&#x27;</span>+access_token</span><br><span class="line">       data=&#123;</span><br><span class="line">             <span class="string">&quot;env&quot;</span>:<span class="string">&quot;******&quot;</span>,                //用户的数据库环境ID</span><br><span class="line">             <span class="string">&quot;collection_name&quot;</span>: <span class="string">&quot;*******&quot;</span>   //数据库集合的名称</span><br><span class="line">             &#125;</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><p>将集合的名字Post即可返回该集合的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检索数据库</span></span><br><span class="line"><span class="string">           collection_name 集合的名称</span></span><br><span class="line"><span class="string">           .limit() 括号内的数值限定返回的记录数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasequery?access_token=&#x27;</span> + access_token</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).limit(100).get()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(url, data=json.dumps(data))</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>通过Post集合名字和Add函数对内容（datas）的传输。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseAdd</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       新建记录并对内容进行定义</span></span><br><span class="line"><span class="string">       collection_name 集合的名称</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).add(&#123;&quot;</span>+datas+<span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       datas=[&#123;</span><br><span class="line">       <span class="string">&quot;字段名称&quot;</span>：<span class="string">&quot;内容&quot;</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       这里主要是对创建记录的直接定义</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">             &#125;]</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><p>经测试这种创建记录的方式对datas的定义要求较为严格，一但定义不够严格会出现创建失败，所以建议通过间接的方式对数据库进行插入记录。</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>通过Post集合名称将该集合直接从数据库移除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         collection_name 集合的名称</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasedelete?access_token=&#x27;</span> + access_token</span><br><span class="line">      data = &#123;</span><br><span class="line">          <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">          <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;)..where(&#123;done:false&#125;).remove()&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      response = requests.post(url, data=json.dumps(data))</span><br><span class="line">      result = response.json()</span><br><span class="line">      <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>更新记录是对已有的记录内容进行修改，所以说想要对记录内容修改不可用.add()进行，通过.update()进行内容修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseUpdate</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       .where() 该集合所在记录的检索</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).where(&#123;age:14&#125;).update(&#123;data:&#123;age: _.inc(1)&#125;&#125;)&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">      &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">      这个例子是将集合里age=<span class="number">14</span>所有记录自增<span class="number">1</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       response = requests.post(url, data=json.dumps(data))</span></span><br><span class="line"><span class="string">       result = response.json()</span></span><br><span class="line"><span class="string">       print(result)     //将返回值打印</span></span><br></pre></td></tr></table></figure><p>更新是对记录的操作，所以很需要.where()的帮助，请大家牢记该函数的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是通过对微信小程序一段时间的学习后总结出来的，本作者是个新人，如有错误可指出，我将及时改正。<br>第二部分是通过调用云函数来对数据库进行操作，这种方法的BUG似乎比直接操作少。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nRF52840作为通信模块与Arduino的联动</title>
      <link href="/post/10336.html"/>
      <url>/post/10336.html</url>
      
        <content type="html"><![CDATA[<h3 id="蓝牙控制Arduino板上13号引脚灯的开关"><a href="#蓝牙控制Arduino板上13号引脚灯的开关" class="headerlink" title="蓝牙控制Arduino板上13号引脚灯的开关"></a>蓝牙控制Arduino板上13号引脚灯的开关</h3><h4 id="开发环境及工具"><a href="#开发环境及工具" class="headerlink" title="开发环境及工具"></a>开发环境及工具</h4><table><thead><tr><th></th><th>名称</th></tr></thead><tbody><tr><td>开发工具</td><td>Segger Embedded Studio</td></tr><tr><td>SDK版本</td><td>nRF5_SDK_15.3.0_59ac345</td></tr><tr><td>开发板</td><td>IK-nRF52840DK+Arduino Uno+IO扩展板</td></tr><tr><td>J-link</td><td>ARM-V9仿真器</td></tr><tr><td>手机App</td><td>nRF UART v2.0</td></tr></tbody></table><h4 id="nRF52840的代码烧录"><a href="#nRF52840的代码烧录" class="headerlink" title="nRF52840的代码烧录"></a>nRF52840的代码烧录</h4><p>打开SKD中示例的ble_app_uart，路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\nRF5_SDK_15.3.0_59ac345\examples\ble_peripheral\ble_app_uart\pca10056\s140\ses</span><br></pre></td></tr></table></figure><p>在main函数中将循环实例修改：</p><img src="https://s2.loli.net/2022/03/12/SyufYqkPidp9lae.png" style="zoom: 80%;" /><p>红圈里的修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> cr;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_get</span>(&amp;cr) != NRF_SUCCESS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_put</span>(cr) != NRF_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cr == <span class="string">&#x27;q&#x27;</span> || cr == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; \r\nExit!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后Build，Debug：</p><img src="https://s2.loli.net/2022/03/12/mXoL1pqk4ysEP9Q.png" style="zoom:67%;" /><img src="https://s2.loli.net/2022/03/12/gMkvVwdZ93WDc5Q.png" style="zoom:67%;" /><h4 id="Arduino的测试代码"><a href="#Arduino的测试代码" class="headerlink" title="Arduino的测试代码"></a>Arduino的测试代码</h4><p>将测试代码刷入Arduino就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"> <span class="built_in">pinMode</span>(<span class="number">13</span>,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Serial.<span class="built_in">available</span>())&#123;</span><br><span class="line">    ss=Serial.<span class="built_in">read</span>();</span><br><span class="line">  Serial.<span class="built_in">println</span>(ss);</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">digitalWrite</span>(<span class="number">13</span>,HIGH); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">digitalWrite</span>(<span class="number">13</span>,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固件连接"><a href="#固件连接" class="headerlink" title="固件连接"></a>固件连接</h4><p>将nRF52840的P06号脚接到IO扩展板上的RX接口，然后将VCC和GND与IO扩展板相应位置连接，如下图：</p><img src="https://s2.loli.net/2022/03/12/5ARiQ2kcNTVZPmF.png" style="zoom:50%;" /><p>然后Arduino板通上电。</p><h4 id="手机蓝牙端测试"><a href="#手机蓝牙端测试" class="headerlink" title="手机蓝牙端测试"></a>手机蓝牙端测试</h4><p>1.打开App搜索设备</p><img src="https://s2.loli.net/2022/03/12/YHX76db9yNPOaAB.png" style="zoom: 33%;" /><p>连接_UART设备<br>2.发送测试数据字符1</p><img src="https://s2.loli.net/2022/03/12/bSqRlZeEKkUvrnu.png" style="zoom:33%;" /><p>然后板上13灯亮起</p><img src="https://s2.loli.net/2022/03/12/WrNcS3XsHnOwyCx.png" style="zoom:50%;" /><p>3.输入其他任意字符熄灭</p><img src="https://s2.loli.net/2022/03/12/zfd4oCUTIFHA1se.png" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/03/12/QrER1vYujwzAGOD.png" style="zoom:50%;" /><p>到这里就基本结束测试，当然大家可以在扩展板上加更多的传感器去实现更加强大的功能!!!!!</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nordic nRF52840 入门学习</title>
      <link href="/post/4057281378.html"/>
      <url>/post/4057281378.html</url>
      
        <content type="html"><![CDATA[<h3 id="Board-Definition组"><a href="#Board-Definition组" class="headerlink" title="Board Definition组"></a>Board Definition组</h3><p>“ Board Definition”组中加入板卡定义文件“ boards.c”,该文件针对于具体板卡,主要要用来定义板卡的指示灯、按键、IO输出电压(仅nRFS2840具有此功能)以及常用的操作函数。对于Nordic nRF52840开发板(兼容 Nordic的PCA10056),设计了4个指示灯和按键,在“ boards.c”文件中,我们可以看到这些按键和指示灯的初始化函数以及一些基本功能如点亮、熄灭、翻转的操作函数。</p><p><img src="https://s2.loli.net/2022/03/12/8pnHB7jaXv2kP1Y.png"></p><h3 id="Board-Support组"><a href="#Board-Support组" class="headerlink" title="Board Support组"></a>Board Support组</h3><p>“ Board Support”组加入的是板卡支持包文件,即BSP文件,主要用于实现指示灯和按键的驱动。</p><p><img src="https://s2.loli.net/2022/03/12/WS51mxILhzJCi23.png"></p><h3 id="UTF8-x2F-UTF16-converter-组"><a href="#UTF8-x2F-UTF16-converter-组" class="headerlink" title="UTF8&#x2F;UTF16 converter 组"></a>UTF8&#x2F;UTF16 converter 组</h3><p>“UTF8&#x2F;UTF16 converter”组只需加入一个实现UTF8&#x2F;UTF16编码转换的文件。<br><img src="https://s2.loli.net/2022/03/12/4Lein2tspcY97rK.png"></p><h3 id="NRF-BLE组"><a href="#NRF-BLE组" class="headerlink" title="NRF BLE组"></a>NRF BLE组</h3><p>“ NRF BLE”组加入的是BLE相关的库文件,如广播、连接参数协、配对管理等等。<br><img src="https://s2.loli.net/2022/03/12/KgaQWBhncswMU2b.png"></p><h3 id="NRF-Drivers组"><a href="#NRF-Drivers组" class="headerlink" title="NRF Drivers组"></a>NRF Drivers组</h3><p>“ NRF Drivers”组加入的是各种外设的驱动库文件,如时钟、 GPOTE、UART等等。<br><img src="https://s2.loli.net/2022/03/12/M3wb9xsVk8r6tGI.png"></p><h3 id="NRF-Libraries"><a href="#NRF-Libraries" class="headerlink" title="NRF Libraries"></a>NRF Libraries</h3><p>“ NRF Libraries”组加入的是各种应用的库文件,如APP定时器、CRC校验、软件FIFO、<br>简易文件系统以及错误处理等等。<br><img src="https://s2.loli.net/2022/03/12/SsLUGfnVT13moBE.png"></p><h3 id="NRF-Log组"><a href="#NRF-Log组" class="headerlink" title="NRF Log组"></a>NRF Log组</h3><p>“ NRF Log”组中加入的文件如下表所示,Log程序模块为程序提供日志打印功能。<br><img src="https://s2.loli.net/2022/03/12/zhJHxUvIKMVwnY9.png"></p><h3 id="NRF-Segger-RT组"><a href="#NRF-Segger-RT组" class="headerlink" title="NRF Segger_RT组"></a>NRF Segger_RT组</h3><p>nRF_ Segger_RTT”组中加入的文件如下表所示,它们的作用是实现 JLINK- RTT Viewer<br>作为Log输出终端,打印Log。<br><img src="https://s2.loli.net/2022/03/12/E61qimBFjCzGpUP.png"></p><h3 id="NRE-Softdevice"><a href="#NRE-Softdevice" class="headerlink" title="NRE Softdevice"></a>NRE Softdevice</h3><p>“nRF_ Softdevice”组中加入的文件如下表所示,它们用于使能或禁止 Softdevice以及<br>向应用程序发布 Softdevice事件,功能如下:</p><p>(1)使能 Softdevice及其事件中断。</p><p>(2)禁止 Softdevice。</p><p>(3)从 Softdevice接收堆栈事件,并将它们转发给应用程序已注册的事件监查者。</p><p>(4)发送 Softdevice状态事件给应用程序和驱动。</p><p>(5)发送可由事件监查者接受或拒绝的SoftDevice状态请求。<br><img src="https://s2.loli.net/2022/03/12/Ils5mSyvA7k1Uwr.png"></p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turtle 3PA三轮小车基于pixhawk的改装（一）</title>
      <link href="/post/53698.html"/>
      <url>/post/53698.html</url>
      
        <content type="html"><![CDATA[<h1 id="Turtle-3PA三轮小车基于pixhawk的改装之准备"><a href="#Turtle-3PA三轮小车基于pixhawk的改装之准备" class="headerlink" title="Turtle 3PA三轮小车基于pixhawk的改装之准备"></a>Turtle 3PA三轮小车基于pixhawk的改装之准备</h1><p>今天在老师的指导下，对Arduino的小车进行改装，想要用pixhawk自动驾驶仪对小车进行控制。<br>工具准备：<br>（1）硬件<br>pixhawk控制板:</p><p><img src="https://s2.loli.net/2022/03/12/4zsFJA7OLHZD6UP.png"></p><p>Turtle 3PA三轮小车：</p><p><img src="https://s2.loli.net/2022/03/12/gxma9oRutrOfMyX.png"></p><p>详细信息：<a href="http://www.dfrobot.com.cn/goods-1069.html">http://www.dfrobot.com.cn/goods-1069.html</a></p><p>乐迪at9s：</p><p><img src="https://s2.loli.net/2022/03/12/39ucVU6LwgjZ1sm.png"></p><p>（2）软件<br>Mission planner：</p><p><img src="https://s2.loli.net/2022/03/12/hxqV1kIG29iJBYo.png"></p><p>官网：<a href="http://ardupilot.org/planner/">http://ardupilot.org/planner/</a><br>QGround：</p><p><img src="https://s2.loli.net/2022/03/12/7ASgCUQti9TrePN.png"></p><p>官网：<a href="http://qgroundcontrol.com/">http://qgroundcontrol.com/</a></p><p>两个地面站是为了刷飞控固件的方便，在对pixhawk飞控刷小车固件的时候总会出现Bad Ahrs，为了解决这个问题因此采用QGround。<br>具体的刷的方法在下个博客说明。</p>]]></content>
      
      
      <categories>
          
          <category> 科技杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pixhawk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
