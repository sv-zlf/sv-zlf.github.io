<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud学习</title>
      <link href="/post/1251775048.html"/>
      <url>/post/1251775048.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud?"></a>什么是Spring Cloud?</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。 </p><p>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</p><h2 id="REST和RPC的区别"><a href="#REST和RPC的区别" class="headerlink" title="REST和RPC的区别"></a>REST和RPC的区别</h2><p> REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。 </p><p> REST调用系统性能较低，RPC调用效率比REST高。 </p><p> REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。 </p><p> REST可以和Swagger等工具整合，自动输出接口API文档。</p><h2 id="SpringCloud如何实现服务的注册和发现"><a href="#SpringCloud如何实现服务的注册和发现" class="headerlink" title="SpringCloud如何实现服务的注册和发现"></a>SpringCloud如何实现服务的注册和发现</h2><p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p><p> 这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。 </p><p> 调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</p><h2 id="什么是服务熔断和服务降级？"><a href="#什么是服务熔断和服务降级？" class="headerlink" title="什么是服务熔断和服务降级？"></a>什么是服务熔断和服务降级？</h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。</p><p>在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p><p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。<br> Hystrix相关注解：<br> @EnableHystrix：开启熔断<br> @HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p><h2 id="服务网关的作用"><a href="#服务网关的作用" class="headerlink" title="服务网关的作用"></a>服务网关的作用</h2><p>简化客户端调用复杂度，统一处理外部请求。 </p><p>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。 </p><p>多渠道支持，针对不同的客户端提供不同的网关支持。 </p><p>遗留系统的微服务化改造，可以作为新老系统的中转组件。 </p><p>统一处理调用过程中的安全、权限问题。</p><h2 id="Ribbon和Feign区别"><a href="#Ribbon和Feign区别" class="headerlink" title="Ribbon和Feign区别"></a>Ribbon和Feign区别</h2><p>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value&#x3D;”服务名称”) 使用RestTemplate调用远程服务对应的方法；Feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”) </p><p>Ribbon和Feign的区别：</p><p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。 </p><p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。 </p><p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。 </p><p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 </p><p>Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p><h2 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h2><p>Zookeepper保证了CP（C：一致性，P：分区容错性） </p><p>Eureka保证了AP（A：高可用） </p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。 </p><p>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： </p><p>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 </p><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。 </p><p>当网络稳定时，当前实例新的注册信息会被同步到其他节点。 </p><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeepper那样使整个微服务瘫痪。</p><h2 id="Spring-Cloud-配置管理——Config"><a href="#Spring-Cloud-配置管理——Config" class="headerlink" title="Spring Cloud 配置管理——Config"></a>Spring Cloud 配置管理——Config</h2><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>为了能够对项目配置进行统一管理，同时又能在项目运行中修改配置，Spring Cloud Config提出了解决方案。</p><p>Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p><p>简单来说，Spring Cloud Config就是能将各个 应用&#x2F;系统&#x2F;模块的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，真实的情况是依赖于这个配置的应用并不会出现更改，这就是BUS总线的作用。</p><p>简单理解为 Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为 消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 Spring Cloud Bus之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><p><img src="https://s2.loli.net/2022/03/13/U4vzH3GP7ckSdlm.jpg"></p><h2 id="服务链路追踪-Spring-Cloud-Sleuth"><a href="#服务链路追踪-Spring-Cloud-Sleuth" class="headerlink" title="服务链路追踪(Spring Cloud Sleuth)"></a>服务链路追踪(Spring Cloud Sleuth)</h2><p>　微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在，一个请求可能需要调用很多个服务，而内部服务的调用复杂性，决定了问题难以定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题，很快定位。</p><p>参考文章：</p><p>[1] <a href="https://my.oschina.net/langwanghuangshifu/blog/3005195">https://my.oschina.net/langwanghuangshifu/blog/3005195</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/post/1365080245.html"/>
      <url>/post/1365080245.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>JVM内存结构分为5大区域，<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>、<strong>方法区</strong>。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>局部变量表是用于存放方法参数和方法内的局部变量。</p><p>每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，在方法调用过程中，会进行动态链接，将这个符号引用转化为直接引用。</p><ul><li>部分符号引用在类加载阶段的时候就转化为直接引用，这种转化就是静态链接 </li><li>部分符号引用在运行期间转化为直接引用，这种转化就是动态链接</li></ul><p>Java 虚拟机栈也是线程<strong>私有</strong>的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><p>可以通过<code>-Xss</code>参数来指定每个线程的虚拟机栈内存大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M</span><br></pre></td></tr></table></figure><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆用于存放对象实例，是垃圾收集器管理的主要区域，因此也被称作<code>GC</code>堆。堆可以细分为：新生代（<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间）和老年代。</p><p>通过 <code>-Xms</code>设定程序启动时占用内存大小，通过<code>-Xmx</code>设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出<code>OutOfMemory</code>异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>对方法区进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>。</p><p><strong>永久代</strong></p><p>方法区是 JVM 的规范，而永久代<code>PermGen</code>是方法区的一种实现方式，并且只有 <code>HotSpot</code> 有永久代。对于其他类型的虚拟机，如<code>JRockit</code>没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的场景比较容易出现永久代的内存溢出。</p><p><strong>元空间</strong></p><p>JDK 1.8 的时候，<code>HotSpot</code>的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。</p><p>为什么要将永久代替换为元空间呢?</p><p>永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>NIO的Buffer提供了DirectBuffer，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。</p><p>直接内存的读写操作比堆内存快，可以提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。</p><h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><ul><li>堆的<strong>物理地址分配</strong>是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</li><li>堆存放的是<strong>对象的实例和数组</strong>；栈存放的是<strong>局部变量，操作数栈，返回结果</strong>等。</li><li>堆是<strong>线程共享</strong>的；栈是<strong>线程私有</strong>的。</li></ul><h3 id="什么情况下会发生栈溢出？"><a href="#什么情况下会发生栈溢出？" class="headerlink" title="什么情况下会发生栈溢出？"></a>什么情况下会发生栈溢出？</h3><ul><li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出<code>StackOverFlowError</code>异常。这种情况通常是因为方法递归没终止条件。 </li><li>新建线程的时候没有足够的内存去创建对应的虚拟机栈，虚拟机会抛出<code>OutOfMemoryError</code>异常。比如线程启动过多就会出现这种情况。</li></ul><h2 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="https://s2.loli.net/2022/03/14/LPsfMauw3Q6dAkm.png"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池中定位</strong>到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://s2.loli.net/2022/03/14/xioUgrwnPjV1sz5.png"></p><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p><h4 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h4><p>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><img src="https://s2.loli.net/2022/03/14/FoHXNka4wS7upbU.png" style="zoom: 50%;" /><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><img src="https://s2.loli.net/2022/03/14/cgGJynRxq9o7fC5.png" style="zoom:50%;" /><p>总结：使用句柄最大的好处就是reference中存储的是稳定句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="GC是什么？为什么要GC？"><a href="#GC是什么？为什么要GC？" class="headerlink" title="GC是什么？为什么要GC？"></a>GC是什么？为什么要GC？</h3><p>GC（<code>Garbage Collection</code>），垃圾回收，是Java与C++的主要区别之一。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清理机制。对JVM中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><h3 id="Minor-GC-和-Full-GC的区别？"><a href="#Minor-GC-和-Full-GC的区别？" class="headerlink" title="Minor GC 和 Full GC的区别？"></a>Minor GC 和 Full GC的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code>会频繁执行，执行的速度一般也会比较快。</li><li><strong>Full GC</strong>：回收老年代和新生代，老年代的对象存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</li></ul><h3 id="Full-GC-的触发条件？"><a href="#Full-GC-的触发条件？" class="headerlink" title="Full GC 的触发条件？"></a>Full GC 的触发条件？</h3><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p><p><strong>调用 System.gc()</strong></p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p><strong>老年代空间不足</strong></p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p><strong>空间分配担保失败</strong></p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><p><strong>JDK 1.7 及以前的永久代空间不足</strong></p><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code></p><h3 id="内存的分配策略"><a href="#内存的分配策略" class="headerlink" title="内存的分配策略"></a>内存的分配策略</h3><p><strong>对象优先在 Eden 分配</strong></p><p>大多数情况下，对象在新生代 <code>Eden</code> 上分配，当 <code>Eden</code> 空间不够时，触发 <code>Minor GC</code>。</p><p><strong>大对象直接进入老年代</strong></p><p>大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 <code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配。</p><p><strong>长期存活的对象进入老年代</strong></p><p>通过参数 <code>-XX:MaxTenuringThreshold</code> 可以设置对象进入老年代的年龄阈值。对象在<code>Survivor</code>区每经过一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p><p><strong>动态对象年龄判定</strong></p><p>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 <code>MaxTenuringThreshold</code> 年龄阈值。</p><p><strong>空间分配担保</strong></p><p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值为不允许担保失败，那么就要进行一次 <code>Full GC</code>。</p><h3 id="如何判断对象死亡？"><a href="#如何判断对象死亡？" class="headerlink" title="如何判断对象死亡？"></a>如何判断对象死亡？</h3><p>对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：<strong>引用计数法</strong>和<strong>可达性分析</strong>。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p>这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，<code>obj1</code> 和 <code>obj2</code> 互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">obj1.instance = obj2;</span><br><span class="line">obj2.instance = obj1;</span><br><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>通过<code>GC Root</code>对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到<code>GC Root</code>没有任何的引用链相连时，说明这个对象是不可用的。</p><p><img src="https://s2.loli.net/2022/03/14/PZqXl1I6BF9EQjW.png"></p><p>可作为 <strong>GC Roots 的对象</strong>包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类?"></a>如何判断一个类是无用的类?</h3><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>首先利用可达性去遍历内存，把存活对象和垃圾对象进行标记。标记结束后统一将所有标记的对象回收掉。这种垃圾回收算法效率较低，并且会<strong>产生大量不连续的空间碎片</strong>。</p><img src="https://s2.loli.net/2022/03/14/xQ8X3CecNltYKfA.png" style="zoom:80%;" /><h4 id="复制清除算法"><a href="#复制清除算法" class="headerlink" title="复制清除算法"></a>复制清除算法</h4><p>半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程仍然与<code>标记-清除</code>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><img src="https://s2.loli.net/2022/03/14/vzUFNKVo89pdxZO.png" style="zoom:80%;" /><h4 id="分类收集算法"><a href="#分类收集算法" class="headerlink" title="分类收集算法"></a>分类收集算法</h4><p>根据各个年代的特点采用最适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用复制算法</li><li>老年代使用标记清除算法或者标记整理算法</li></ul><p>在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记-清理或者标记-整理算法进行垃圾回收。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器主要分为以下几种：<code>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1</code>。</p><p>这7种垃圾收集器的特点：</p><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代&#x2F;老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU环境下的Client模式</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或B&#x2F;S系统服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>both</td><td>标记-整理+复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换CMS</td></tr></tbody></table><p><strong>Serial 收集器</strong></p><p><strong>单线程收集器</strong>，使用一个垃圾收集线程去进行垃圾回收，在进行垃圾回收的时候必须暂停其他所有的工作线程（ <code>Stop The World</code> ），直到它收集结束。</p><p>特点：简单高效；内存消耗小；没有线程交互的开销，单线程收集效率高；需暂停所有的工作线程，用户体验不好。</p><p><strong>ParNew 收集器</strong></p><p><code>Serial</code>收集器的<strong>多线程版本</strong>，除了使用多线程进行垃圾收集外，其他行为、参数与 <code>Serial</code> 收集器基本一致。</p><p><strong>Parallel Scavenge 收集器</strong></p><p><strong>新生代收集器</strong>，基于<strong>复制清除算法</strong>实现的收集器。特点是<strong>吞吐量优先</strong>，能够并行收集的多线程收集器，允许多个垃圾回收线程同时运行，降低垃圾收集时间，提高吞吐量。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值（<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>）。<code>Parallel Scavenge</code> 收集器关注点是<strong>吞吐量，高效率的利用 CPU 资源</strong>。<code>CMS</code> 垃圾收集器关注点更多的是<strong>用户线程的停顿时间</strong>。</p><p><code>Parallel Scavenge</code>收集器提供了两个参数用于<strong>精确控制吞吐量</strong>，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</p><ul><li><code>-XX：MaxGCPauseMillis</code>参数的值是一个大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过用户设定值。</li><li><code>-XX：GCTimeRatio</code>参数的值大于0小于100，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</li></ul><p><strong>Serial Old 收集器</strong></p><p><code>Serial</code> 收集器的老年代版本，单线程收集器，使用<strong>标记整理算法</strong>。</p><p><strong>Parallel Old 收集器</strong></p><p><code>Parallel Scavenge</code> 收集器的老年代版本。多线程垃圾收集，使用<strong>标记整理算法</strong>。</p><p><strong>CMS 收集器</strong></p><p><code>Concurrent Mark Sweep</code> ，并发标记清除，追求获取<strong>最短停顿时间</strong>，实现了让<strong>垃圾收集线程与用户线程基本上同时工作</strong>。</p><p><code>CMS</code> 垃圾回收基于<strong>标记清除算法</strong>实现，整个过程分为四个步骤：</p><ul><li>初始标记： 暂停所有用户线程（<code>Stop The World</code>），记录直接与 <code>GC Roots</code> 直接相连的对象 。</li><li>并发标记：从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程。</li><li>重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。</li><li>并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。</li></ul><p>在整个过程中，耗时最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程都可以与用户线程一起工作，所以从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</p><p><strong>优点</strong>：并发收集，停顿时间短。</p><p><strong>缺点</strong>：</p><ul><li>标记清除算法导致收集结束有<strong>大量空间碎片</strong>。</li><li><strong>产生浮动垃圾</strong>，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在标记过程之后，<code>CMS</code>无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；</li></ul><p><strong>G1收集器</strong></p><p>G1垃圾收集器的目标是在不同应用场景中<strong>追求高吞吐量和低停顿之间的最佳平衡</strong>。</p><p>G1将整个堆分成相同大小的分区（<code>Region</code>），有四种不同类型的分区：<code>Eden、Survivor、Old和Humongous</code>。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定。<code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。</p><h4 id="CMS收集器和G1收集器的区别？"><a href="#CMS收集器和G1收集器的区别？" class="headerlink" title="CMS收集器和G1收集器的区别？"></a>CMS收集器和G1收集器的区别？</h4><p><strong>使用范围不一样</strong></p><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 </li><li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li></ul><p><strong>STW的时间</strong></p><ul><li>CMS收集器以最小的停顿时间为目标的收集器。 </li><li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</li></ul><p><strong>垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 </li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><p><strong>垃圾回收过程不一样</strong></p><h2 id="类相关知识"><a href="#类相关知识" class="headerlink" title="类相关知识"></a>类相关知识</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>Class 文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//类文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//类的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类的索引</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数如下：</p><p><strong>魔数</strong>：<code>class</code>文件标志。</p><p><strong>文件版本</strong>：高版本的 Java 虚拟机可以执行低版本编译器生成的类文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的类文件。</p><p><strong>常量池</strong>：存放字面量和符号引用。字面量类似于 Java 的常量，如字符串，声明为<code>final</code>的常量值等。符号引用包含三类：类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。</p><p><strong>访问标志</strong>：识别类或者接口的访问信息，比如这个<code>Class</code>是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型等等。</p><p><strong>当前类的索引</strong>：类索引用于确定这个类的全限定名。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>一个类的完整生命周期如下：</p><p><img src="https://s2.loli.net/2022/03/14/dBRNrygsQpSk65P.png"></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><strong>加载</strong></p><ol><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区类信息的访问入口</li></ol><p><strong>验证</strong></p><p>确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p><strong>准备</strong></p><p>为类变量分配内存并设置类变量初始值的阶段。</p><p><strong>解析</strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p><p><strong>初始化</strong></p><p>开始执行类中定义的<code>Java</code>代码，初始化阶段是调用类构造器的过程。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ul><li><strong>启动类加载器</strong>：用来加载 Java 核心类库，无法被 Java 程序直接引用。</li><li><strong>扩展类加载器</strong>：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>：它根据应用的类路径来加载 Java 类。可通过<code>ClassLoader.getSystemClassLoader()</code>获取它。</li><li><strong>自定义类加载器</strong>：通过继承<code>java.lang.ClassLoader</code>类的方式实现。</li></ul><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求<strong>委派</strong>给父类加载器去完成，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p><img src="https://s2.loli.net/2022/03/14/Op9Yfw56ankmB3o.png"></p><h4 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h4><p>双亲委派模型的好处：可以防止内存中出现多份同样的字节码。如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个<code>java.lang.Object</code>的同名类并放在<code>ClassPath</code>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的<code>Object</code>类，那么类之间的比较结果及类的唯一性将无法保证。</p><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[2] <a href="https://javaguide.cn/java/jvm">https://javaguide.cn/java/jvm</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/post/4159564061.html"/>
      <url>/post/4159564061.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p><strong>面向过程</strong>：</p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展。</li></ul><p><strong>面向对象</strong>：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li><li>缺点：性能比面向过程低。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>封装</strong></p><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 </p><p><strong>继承</strong></p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 </p><p><strong>多态性</strong></p><p>它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</p><ul><li>编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。 </li><li>运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-中的八种基本数据类型"><a href="#Java-中的八种基本数据类型" class="headerlink" title="Java 中的八种基本数据类型"></a>Java 中的八种基本数据类型</h3><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><h3 id="Java语言关键字有哪些？"><a href="#Java语言关键字有哪些？" class="headerlink" title="Java语言关键字有哪些？"></a>Java语言关键字有哪些？</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="final、finally、finalize的区别？"><a href="#final、finally、finalize的区别？" class="headerlink" title="final、finally、finalize的区别？"></a>final、finally、finalize的区别？</h3><p>final 用于修饰变量、方法和类。</p><ul><li>final 变量：被修饰的变量不可变，不可变分为<code>引用不可变</code>和<code>对象不可变</code>，final 指的是<code>引用不可变</code>，final 修饰的变量必须初始化，通常称被修饰的变量为<code>常量</code>。 </li><li>final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。 </li><li>final 类：被修饰的类不能被继承，所有方法不能被重写。</li></ul><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p><h3 id="访问修饰符public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 </li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong> </li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法 </li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="对象相等的判断"><a href="#对象相等的判断" class="headerlink" title="对象相等的判断"></a>对象相等的判断</h2><h3 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p><strong>equals()</strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法</p><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 hashCode值必须是相等。也就是说如果 equals&#96;方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><p>如果重写 equals()时没有重写 hashCode()方法的话就可能会导致 equals方法判断是相等的两个对象，hashCode值却不相等。</p><h3 id="java-创建对象有哪几种方式？"><a href="#java-创建对象有哪几种方式？" class="headerlink" title="java 创建对象有哪几种方式？"></a>java 创建对象有哪几种方式？</h3><p>java中提供了以下四种创建对象的方式:</p><ul><li>new创建新对象 </li><li>通过反射机制 </li><li>采用clone机制 </li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><h3 id="String-StringBuffer-StringBuilder-的区别是什么？"><a href="#String-StringBuffer-StringBuilder-的区别是什么？" class="headerlink" title="String,StringBuffer, StringBuilder 的区别是什么？"></a>String,StringBuffer, StringBuilder 的区别是什么？</h3><p>1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。<strong>对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.</strong></p><p>String类利用了final修饰的char类型数组存储字符，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure><p>2.是否多线程安全。</p><p>String中的对象是不可变的，也就可以理解为常量，显然线程安全。</p><p>StringBuilder是非线程安全的。</p><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><p>1.便于实现字符串池（String pool）</p><p>在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p><p>2.使多线程安全</p><p>在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。</p><p>3.避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p><p>4.加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p><p>总体来说，String不可变的原因要包括<strong>设计考虑</strong>，<strong>效率优化</strong>，以及<strong>安全性</strong>这三大方面。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><blockquote><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></blockquote><h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h3><ul><li>Integer是int的包装类；int是基本数据类型； </li><li>Integer变量必须实例化后才能使用；int变量不需要； </li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； </li><li>Integer的默认值是null；int的默认值是0。</li></ul><h3 id="两个new生成的Integer变量的对比"><a href="#两个new生成的Integer变量的对比" class="headerlink" title="两个new生成的Integer变量的对比"></a>两个new生成的Integer变量的对比</h3><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Integer变量和int变量的对比"><a href="#Integer变量和int变量的对比" class="headerlink" title="Integer变量和int变量的对比"></a>Integer变量和int变量的对比</h3><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c=<span class="number">10000</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="非new生成的Integer变量和new-Integer-生成变量的对比"><a href="#非new生成的Integer变量和new-Integer-生成变量的对比" class="headerlink" title="非new生成的Integer变量和new Integer()生成变量的对比"></a>非new生成的Integer变量和new Integer()生成变量的对比</h3><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c= <span class="number">10000</span>;</span><br><span class="line">System.out.println(b == c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="两个非new生成的Integer对象的对比"><a href="#两个非new生成的Integer对象的对比" class="headerlink" title="两个非new生成的Integer对象的对比"></a>两个非new生成的Integer对象的对比</h3><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ul><li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。</li></ul><h3 id="反射使用的步骤？"><a href="#反射使用的步骤？" class="headerlink" title="反射使用的步骤？"></a>反射使用的步骤？</h3><ol><li>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ol><li><strong>对象序列化可以实现分布式对象。</strong></li></ol><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><p>​    2. <strong>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong> </p><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p><ol start="3"><li><strong>序列化可以将内存中的类写入文件或数据库中。</strong></li></ol><p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p><p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p><ol start="4"><li><strong>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ol><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><h3 id="序列化实现的方式有哪些？"><a href="#序列化实现的方式有哪些？" class="headerlink" title="序列化实现的方式有哪些？"></a>序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p>两种序列化的对比:</p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="什么是serialVersionUID？"><a href="#什么是serialVersionUID？" class="headerlink" title="什么是serialVersionUID？"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性</p><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h3><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。 </li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li></ul><h3 id="非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？"><a href="#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？" class="headerlink" title="非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？"></a>非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h3><p>非受检查异常：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：<code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等。</p><p>受检查异常：是Exception 中除 <code>RuntimeException</code> 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p><p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p><h3 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h3 id="Java常见异常有哪些？"><a href="#Java常见异常有哪些？" class="headerlink" title="Java常见异常有哪些？"></a>Java常见异常有哪些？</h3><ul><li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 </li><li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. </li><li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 </li><li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 </li><li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 </li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 </li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。 </li><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 </li><li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 </li><li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 </li><li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 </li><li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 </li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 </li><li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 </li><li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="常用的通配符有哪些？"><a href="#常用的通配符有哪些？" class="headerlink" title="常用的通配符有哪些？"></a>常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的IO-流分为几种？"><a href="#Java的IO-流分为几种？" class="headerlink" title="Java的IO 流分为几种？"></a>Java的IO 流分为几种？</h3><ul><li>按照流的方向：输入流（inputStream）和输出流（outputStream）； </li><li>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）； </li><li>按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。</li></ul><h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><ul><li>读写的时候字节流是按字节读写，字符流按字符读写。 </li><li>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。 </li><li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 </li><li>只是读写文件，和文件内容无关时，一般选择字节流。</li></ul><h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 </p><img src="https://s2.loli.net/2022/03/13/6YqGgnEKibOeA3W.png" style="zoom:67%;" /><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。 </p><img src="https://s2.loli.net/2022/03/13/BUk9fdSj63tl4OA.png" style="zoom:67%;" /><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p><img src="https://s2.loli.net/2022/03/13/V76rpuQP2SXk81f.png" style="zoom:67%;" /><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/853116">Java基础八股文连环80问_笔经面经_牛客网 (nowcoder.com)</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（二）</title>
      <link href="/post/6004.html"/>
      <url>/post/6004.html</url>
      
        <content type="html"><![CDATA[<p>本文将接前文，继续讲述python程序对微信云开发数据库的操作。</p><h2 id="间接操作"><a href="#间接操作" class="headerlink" title="间接操作"></a>间接操作</h2><p>间接操作指的是python通过云函数对云开发数据库进行操作。所有的操作都是在获取access_token的前提下进行的，不懂的同学可以参考：链接: <a href="https://blog.csdn.net/qq_44001007/article/details/103944492">link</a>.<br>同时由于请求python请求云函数的代码基本类似，只有在data里面进行参数的变换即可，给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xxxx</span>(<span class="params">self</span>):</span><br><span class="line">    //在函数括号内需要添加参数</span><br><span class="line">    ACCESS_TOKEN = xxx   //获取的access_token</span><br><span class="line">    ENV = xxx                      //用户的数据库环境ID</span><br><span class="line">    FUNCTION_NAME = xxx   //所要执行的云函数名</span><br><span class="line">    url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=&#x27;</span> + ACCESS_TOKEN + <span class="string">&#x27;&amp;env=&#x27;</span> + ENV + <span class="string">&#x27;&amp;name=&#x27;</span> + FUNCTION_NAME</span><br><span class="line">    data = &#123;</span><br><span class="line">    //所要传输的参数</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url, data=json.dumps(data))</span><br><span class="line">    result = response.json()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>云函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.<span class="title function_">init</span>()</span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> db.<span class="title function_">createCollection</span>(event.<span class="property">id</span>)</span><br><span class="line">  <span class="comment">//event.id是python传输的数据，为该集合的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createCollection</span>(<span class="params">self，<span class="built_in">id</span></span>):</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="built_in">id</span>,</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h3><p>云函数：</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ndnSIM实现一发多收</title>
      <link href="/post/52359.html"/>
      <url>/post/52359.html</url>
      
        <content type="html"><![CDATA[<p>直接进入正题，想要实现一发多收，就是要在路由进行广播时转发的兴趣包与接收到数据包的数目相等，即For_num&#x3D;&#x3D;Rec_num；但正常情况下，路由在第一次接收到数据包时就会把pit条目删除，所以接下来的目的是在接收到数据包对删除pit的命令进行修改。</p><h2 id="pit条目修改"><a href="#pit条目修改" class="headerlink" title="pit条目修改"></a>pit条目修改</h2><p>先进入到ndnSIM源目录下</p><p><img src="https://s2.loli.net/2022/03/13/c1q9ETghuMdUK3w.png"></p><p>然后进入pit-entry.cpp&#x2F;.hpp所在目录，对这两个文件进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd NFD/daemon/table/</span><br></pre></td></tr></table></figure><p>先对hpp进行修改，添加For_NUM和Rec_NUM两个变量</p><p><img src="https://s2.loli.net/2022/03/13/ZDa2F4NlGQ5Ocwo.png"></p><p>然后添加获取参数的函数与对变量操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_RecNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Rec_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_ForNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> For_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_inter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> For_NUM++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Rec_NUM++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下进行参数的初始化定义，在cpp中实现</p><p><img src="https://s2.loli.net/2022/03/13/AESXW1HhkKRD3xe.png"></p><h2 id="转发策略修改"><a href="#转发策略修改" class="headerlink" title="转发策略修改"></a>转发策略修改</h2><h3 id="after-Recevie-Interest"><a href="#after-Recevie-Interest" class="headerlink" title="after Recevie Interest"></a>after Recevie Interest</h3><p>进入forwarder.cpp所在文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable constant_">NFD</span>/daemon/fw</span><br></pre></td></tr></table></figure><p>修改onOutgoingInterest（）函数</p><p><img src="https://s2.loli.net/2022/03/13/yH9XEQ1fVdRsglu.png"></p><h3 id="after-Recevie-data"><a href="#after-Recevie-data" class="headerlink" title="after Recevie data"></a>after Recevie data</h3><p>在同一个目录下打开strategy.cpp文件，对sendData（）函数进行修改</p><p><img src="https://s2.loli.net/2022/03/13/YxvCfIayOSl2L18.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行一个具有多个生产者的路由拓扑，查看路由接收的数据包数量，即可确认是否实现一发多收。</p><p><img src="https://s2.loli.net/2022/03/13/nkbEUVugKwcrqdZ.png"></p><p>有上图可以得出接收的是发送的两倍，实现一发多收。</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu安装ndnSIM</title>
      <link href="/post/57172.html"/>
      <url>/post/57172.html</url>
      
        <content type="html"><![CDATA[<p>通过对资料的查询获取相对应的版本号与ndnsim之间的关系：</p><table><thead><tr><th>操作系统</th><th>Ubuntu 18</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.7</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-ns-3.29</td></tr><tr><td>pybindgen</td><td>0.19.0</td></tr></tbody></table><p>如果想要安装其他版本，请找到上述条件所对应的版本号即可。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml</span><br><span class="line">sudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gi libgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip</span><br><span class="line">pip install pygraphviz pycairo PyGObject pygccxml</span><br><span class="line">sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config</span><br><span class="line">pip install pygraphviz</span><br></pre></td></tr></table></figure><p>可能出现报错无法安装的情况，我把后面的安装好，在安装前面的就成功了;同时这是Ubuntu18所需要的依赖环境，其他版本请参照官网。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>现在任意文件创建个ndnsim文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ndnSIM2.7</span><br></pre></td></tr></table></figure><p>然后进入该文件夹下，进行源码的下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>记住千万不要在最后一条命令按照官网的说法加上–recursive，这样就会把NFD和ndn-cxx模块直接下载最新版本，这样后面的操作就无效了。</p><h2 id="修改对应版本号"><a href="#修改对应版本号" class="headerlink" title="修改对应版本号"></a>修改对应版本号</h2><p>这里的命令依靠git实现，能到这一步肯定都安装好了，就不多说了。<br>首先进入到ndnSIM的核心源码地带</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>通过git checkout修改版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-2.7</span><br></pre></td></tr></table></figure><p>也可以通过git tag查看所有的版本号，然后修改为想要安装的版本</p><p><img src="https://img-blog.csdnimg.cn/20200725105311613.png"></p><p>然后安装NFD和ndn-cxx模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><p>接下来进入到ndnSIM2.7&#x2F;ns-3文件下进行版本的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-ns-3.29</span><br></pre></td></tr></table></figure><p>出现如图所示即为成功</p><p><img src="https://s2.loli.net/2022/03/12/LtPm79ICKAYwdrg.png"></p><p>接下对pybindgen的版本进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7/pybindgen</span><br><span class="line">git checkout 0.19.0</span><br></pre></td></tr></table></figure><p>然后在此目录下安装安装该python模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2022/03/12/fnUh7aDJ2MOErR5.png"></p><h2 id="运行编译"><a href="#运行编译" class="headerlink" title="运行编译"></a>运行编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.1/ns-3</span><br><span class="line">./waf configure --enable-examples</span><br><span class="line">./waf</span><br><span class="line">./waf --run ndn-simple --vis</span><br></pre></td></tr></table></figure><p>正常情况直接编译完成，出现错误的话请看下面的修改提示</p><p><img src="https://s2.loli.net/2022/03/12/B1fgyvZdDbkqxri.png"></p><p>进入到可视化模块下将‘file&#x3D;’删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  ndnSIM2.7/ns-3/src/visualizer/visualizer</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/12/q8nABHgkLvl2smt.png"></p><p>进入base.py文件，修改保存即可</p><p><img src="https://s2.loli.net/2022/03/12/ka8ywbI1o5YvpLj.png"></p><p>第二种错误可能出现在运行时加上–vis可视化模块时，如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/UDG7XjaZmOF3BuJ.png"></p><p>这种情况下，还是进入刚才的那个文件夹，修改hub.py文件</p><p><img src="https://s2.loli.net/2022/03/12/brEc9vg3pFwqhsj.png"></p><p>将from . import注释，修改为import core。再次运行就可以了</p><p><img src="https://s2.loli.net/2022/03/12/94Q7mq85lV1ekwz.png"></p><p>经过试验，添加Ubuntu16的对应版本</p><table><thead><tr><th>操作系统</th><th>Ubuntu 16</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.5</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-v2.5</td></tr><tr><td>pybindgen</td><td>0.18.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（一）</title>
      <link href="/post/34574.html"/>
      <url>/post/34574.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述python程序对微信云开发数据库的操作。</p><h1 id="直接操作"><a href="#直接操作" class="headerlink" title="直接操作"></a>直接操作</h1><p>直接操作指的是通过python程序对云开发数据库直接进行操作。<br>所有的操作前提都是在获取access_token下进行的，先通过下列代码获取access_token在进行接下来的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access_token</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           获取access_token</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        APPID = <span class="string">&#x27;**********&#x27;</span>                        //小程序ID</span><br><span class="line">        APPSECRET = <span class="string">&#x27;**************&#x27;</span>                //小程序秘钥</span><br><span class="line">        WECHAT_URL = <span class="string">&#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#x27;</span> + APPID + <span class="string">&#x27;&amp;secret=&#x27;</span> + APPSECRET</span><br><span class="line">        response = requests.get(WECHAT_URL)</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&quot;access_token&quot;</span>]     //将返回值解析获取access_token</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>此方法的创建只需要将集合的名字post给数据库即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseCollectionAdd</span>(<span class="params">access_token</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          创建数据库</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasecollectionadd?access_token&#x27;</span>+access_token</span><br><span class="line">       data=&#123;</span><br><span class="line">             <span class="string">&quot;env&quot;</span>:<span class="string">&quot;******&quot;</span>,                //用户的数据库环境ID</span><br><span class="line">             <span class="string">&quot;collection_name&quot;</span>: <span class="string">&quot;*******&quot;</span>   //数据库集合的名称</span><br><span class="line">             &#125;</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><p>将集合的名字Post即可返回该集合的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检索数据库</span></span><br><span class="line"><span class="string">           collection_name 集合的名称</span></span><br><span class="line"><span class="string">           .limit() 括号内的数值限定返回的记录数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasequery?access_token=&#x27;</span> + access_token</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).limit(100).get()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(url, data=json.dumps(data))</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>通过Post集合名字和Add函数对内容（datas）的传输。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseAdd</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       新建记录并对内容进行定义</span></span><br><span class="line"><span class="string">       collection_name 集合的名称</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).add(&#123;&quot;</span>+datas+<span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       datas=[&#123;</span><br><span class="line">       <span class="string">&quot;字段名称&quot;</span>：<span class="string">&quot;内容&quot;</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       这里主要是对创建记录的直接定义</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">             &#125;]</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><p>经测试这种创建记录的方式对datas的定义要求较为严格，一但定义不够严格会出现创建失败，所以建议通过间接的方式对数据库进行插入记录。</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>通过Post集合名称将该集合直接从数据库移除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         collection_name 集合的名称</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasedelete?access_token=&#x27;</span> + access_token</span><br><span class="line">      data = &#123;</span><br><span class="line">          <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">          <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;)..where(&#123;done:false&#125;).remove()&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      response = requests.post(url, data=json.dumps(data))</span><br><span class="line">      result = response.json()</span><br><span class="line">      <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>更新记录是对已有的记录内容进行修改，所以说想要对记录内容修改不可用.add()进行，通过.update()进行内容修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseUpdate</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       .where() 该集合所在记录的检索</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).where(&#123;age:14&#125;).update(&#123;data:&#123;age: _.inc(1)&#125;&#125;)&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">      &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">      这个例子是将集合里age=<span class="number">14</span>所有记录自增<span class="number">1</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       response = requests.post(url, data=json.dumps(data))</span></span><br><span class="line"><span class="string">       result = response.json()</span></span><br><span class="line"><span class="string">       print(result)     //将返回值打印</span></span><br></pre></td></tr></table></figure><p>更新是对记录的操作，所以很需要.where()的帮助，请大家牢记该函数的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是通过对微信小程序一段时间的学习后总结出来的，本作者是个新人，如有错误可指出，我将及时改正。<br>第二部分是通过调用云函数来对数据库进行操作，这种方法的BUG似乎比直接操作少。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nRF52840作为通信模块与Arduino的联动</title>
      <link href="/post/10336.html"/>
      <url>/post/10336.html</url>
      
        <content type="html"><![CDATA[<h3 id="蓝牙控制Arduino板上13号引脚灯的开关"><a href="#蓝牙控制Arduino板上13号引脚灯的开关" class="headerlink" title="蓝牙控制Arduino板上13号引脚灯的开关"></a>蓝牙控制Arduino板上13号引脚灯的开关</h3><h4 id="开发环境及工具"><a href="#开发环境及工具" class="headerlink" title="开发环境及工具"></a>开发环境及工具</h4><table><thead><tr><th></th><th>名称</th></tr></thead><tbody><tr><td>开发工具</td><td>Segger Embedded Studio</td></tr><tr><td>SDK版本</td><td>nRF5_SDK_15.3.0_59ac345</td></tr><tr><td>开发板</td><td>IK-nRF52840DK+Arduino Uno+IO扩展板</td></tr><tr><td>J-link</td><td>ARM-V9仿真器</td></tr><tr><td>手机App</td><td>nRF UART v2.0</td></tr></tbody></table><h4 id="nRF52840的代码烧录"><a href="#nRF52840的代码烧录" class="headerlink" title="nRF52840的代码烧录"></a>nRF52840的代码烧录</h4><p>打开SKD中示例的ble_app_uart，路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\nRF5_SDK_15.3.0_59ac345\examples\ble_peripheral\ble_app_uart\pca10056\s140\ses</span><br></pre></td></tr></table></figure><p>在main函数中将循环实例修改：</p><img src="https://s2.loli.net/2022/03/12/SyufYqkPidp9lae.png" style="zoom: 80%;" /><p>红圈里的修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> cr;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_get</span>(&amp;cr) != NRF_SUCCESS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_put</span>(cr) != NRF_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cr == <span class="string">&#x27;q&#x27;</span> || cr == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; \r\nExit!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后Build，Debug：</p><img src="https://s2.loli.net/2022/03/12/mXoL1pqk4ysEP9Q.png" style="zoom:67%;" /><img src="https://s2.loli.net/2022/03/12/gMkvVwdZ93WDc5Q.png" style="zoom:67%;" /><h4 id="Arduino的测试代码"><a href="#Arduino的测试代码" class="headerlink" title="Arduino的测试代码"></a>Arduino的测试代码</h4><p>将测试代码刷入Arduino就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"> <span class="built_in">pinMode</span>(<span class="number">13</span>,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Serial.<span class="built_in">available</span>())&#123;</span><br><span class="line">    ss=Serial.<span class="built_in">read</span>();</span><br><span class="line">  Serial.<span class="built_in">println</span>(ss);</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">digitalWrite</span>(<span class="number">13</span>,HIGH); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">digitalWrite</span>(<span class="number">13</span>,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固件连接"><a href="#固件连接" class="headerlink" title="固件连接"></a>固件连接</h4><p>将nRF52840的P06号脚接到IO扩展板上的RX接口，然后将VCC和GND与IO扩展板相应位置连接，如下图：</p><img src="https://s2.loli.net/2022/03/12/5ARiQ2kcNTVZPmF.png" style="zoom:50%;" /><p>然后Arduino板通上电。</p><h4 id="手机蓝牙端测试"><a href="#手机蓝牙端测试" class="headerlink" title="手机蓝牙端测试"></a>手机蓝牙端测试</h4><p>1.打开App搜索设备</p><img src="https://s2.loli.net/2022/03/12/YHX76db9yNPOaAB.png" style="zoom: 33%;" /><p>连接_UART设备<br>2.发送测试数据字符1</p><img src="https://s2.loli.net/2022/03/12/bSqRlZeEKkUvrnu.png" style="zoom:33%;" /><p>然后板上13灯亮起</p><img src="https://s2.loli.net/2022/03/12/WrNcS3XsHnOwyCx.png" style="zoom:50%;" /><p>3.输入其他任意字符熄灭</p><img src="https://s2.loli.net/2022/03/12/zfd4oCUTIFHA1se.png" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/03/12/QrER1vYujwzAGOD.png" style="zoom:50%;" /><p>到这里就基本结束测试，当然大家可以在扩展板上加更多的传感器去实现更加强大的功能!!!!!</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nordic nRF52840 入门学习</title>
      <link href="/post/4057281378.html"/>
      <url>/post/4057281378.html</url>
      
        <content type="html"><![CDATA[<h3 id="Board-Definition组"><a href="#Board-Definition组" class="headerlink" title="Board Definition组"></a>Board Definition组</h3><p>“ Board Definition”组中加入板卡定义文件“ boards.c”,该文件针对于具体板卡,主要要用来定义板卡的指示灯、按键、IO输出电压(仅nRFS2840具有此功能)以及常用的操作函数。对于Nordic nRF52840开发板(兼容 Nordic的PCA10056),设计了4个指示灯和按键,在“ boards.c”文件中,我们可以看到这些按键和指示灯的初始化函数以及一些基本功能如点亮、熄灭、翻转的操作函数。</p><p><img src="https://s2.loli.net/2022/03/12/8pnHB7jaXv2kP1Y.png"></p><h3 id="Board-Support组"><a href="#Board-Support组" class="headerlink" title="Board Support组"></a>Board Support组</h3><p>“ Board Support”组加入的是板卡支持包文件,即BSP文件,主要用于实现指示灯和按键的驱动。</p><p><img src="https://s2.loli.net/2022/03/12/WS51mxILhzJCi23.png"></p><h3 id="UTF8-x2F-UTF16-converter-组"><a href="#UTF8-x2F-UTF16-converter-组" class="headerlink" title="UTF8&#x2F;UTF16 converter 组"></a>UTF8&#x2F;UTF16 converter 组</h3><p>“UTF8&#x2F;UTF16 converter”组只需加入一个实现UTF8&#x2F;UTF16编码转换的文件。<br><img src="https://s2.loli.net/2022/03/12/4Lein2tspcY97rK.png"></p><h3 id="NRF-BLE组"><a href="#NRF-BLE组" class="headerlink" title="NRF BLE组"></a>NRF BLE组</h3><p>“ NRF BLE”组加入的是BLE相关的库文件,如广播、连接参数协、配对管理等等。<br><img src="https://s2.loli.net/2022/03/12/KgaQWBhncswMU2b.png"></p><h3 id="NRF-Drivers组"><a href="#NRF-Drivers组" class="headerlink" title="NRF Drivers组"></a>NRF Drivers组</h3><p>“ NRF Drivers”组加入的是各种外设的驱动库文件,如时钟、 GPOTE、UART等等。<br><img src="https://s2.loli.net/2022/03/12/M3wb9xsVk8r6tGI.png"></p><h3 id="NRF-Libraries"><a href="#NRF-Libraries" class="headerlink" title="NRF Libraries"></a>NRF Libraries</h3><p>“ NRF Libraries”组加入的是各种应用的库文件,如APP定时器、CRC校验、软件FIFO、<br>简易文件系统以及错误处理等等。<br><img src="https://s2.loli.net/2022/03/12/SsLUGfnVT13moBE.png"></p><h3 id="NRF-Log组"><a href="#NRF-Log组" class="headerlink" title="NRF Log组"></a>NRF Log组</h3><p>“ NRF Log”组中加入的文件如下表所示,Log程序模块为程序提供日志打印功能。<br><img src="https://s2.loli.net/2022/03/12/zhJHxUvIKMVwnY9.png"></p><h3 id="NRF-Segger-RT组"><a href="#NRF-Segger-RT组" class="headerlink" title="NRF Segger_RT组"></a>NRF Segger_RT组</h3><p>nRF_ Segger_RTT”组中加入的文件如下表所示,它们的作用是实现 JLINK- RTT Viewer<br>作为Log输出终端,打印Log。<br><img src="https://s2.loli.net/2022/03/12/E61qimBFjCzGpUP.png"></p><h3 id="NRE-Softdevice"><a href="#NRE-Softdevice" class="headerlink" title="NRE Softdevice"></a>NRE Softdevice</h3><p>“nRF_ Softdevice”组中加入的文件如下表所示,它们用于使能或禁止 Softdevice以及<br>向应用程序发布 Softdevice事件,功能如下:</p><p>(1)使能 Softdevice及其事件中断。</p><p>(2)禁止 Softdevice。</p><p>(3)从 Softdevice接收堆栈事件,并将它们转发给应用程序已注册的事件监查者。</p><p>(4)发送 Softdevice状态事件给应用程序和驱动。</p><p>(5)发送可由事件监查者接受或拒绝的SoftDevice状态请求。<br><img src="https://s2.loli.net/2022/03/12/Ils5mSyvA7k1Uwr.png"></p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turtle 3PA三轮小车基于pixhawk的改装（一）</title>
      <link href="/post/53698.html"/>
      <url>/post/53698.html</url>
      
        <content type="html"><![CDATA[<h1 id="Turtle-3PA三轮小车基于pixhawk的改装之准备"><a href="#Turtle-3PA三轮小车基于pixhawk的改装之准备" class="headerlink" title="Turtle 3PA三轮小车基于pixhawk的改装之准备"></a>Turtle 3PA三轮小车基于pixhawk的改装之准备</h1><p>今天在老师的指导下，对Arduino的小车进行改装，想要用pixhawk自动驾驶仪对小车进行控制。<br>工具准备：<br>（1）硬件<br>pixhawk控制板:</p><p><img src="https://s2.loli.net/2022/03/12/4zsFJA7OLHZD6UP.png"></p><p>Turtle 3PA三轮小车：</p><p><img src="https://s2.loli.net/2022/03/12/gxma9oRutrOfMyX.png"></p><p>详细信息：<a href="http://www.dfrobot.com.cn/goods-1069.html">http://www.dfrobot.com.cn/goods-1069.html</a></p><p>乐迪at9s：</p><p><img src="https://s2.loli.net/2022/03/12/39ucVU6LwgjZ1sm.png"></p><p>（2）软件<br>Mission planner：</p><p><img src="https://s2.loli.net/2022/03/12/hxqV1kIG29iJBYo.png"></p><p>官网：<a href="http://ardupilot.org/planner/">http://ardupilot.org/planner/</a><br>QGround：</p><p><img src="https://s2.loli.net/2022/03/12/7ASgCUQti9TrePN.png"></p><p>官网：<a href="http://qgroundcontrol.com/">http://qgroundcontrol.com/</a></p><p>两个地面站是为了刷飞控固件的方便，在对pixhawk飞控刷小车固件的时候总会出现Bad Ahrs，为了解决这个问题因此采用QGround。<br>具体的刷的方法在下个博客说明。</p>]]></content>
      
      
      <categories>
          
          <category> 科技杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pixhawk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
