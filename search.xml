<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud学习</title>
      <link href="/post/1251775048.html"/>
      <url>/post/1251775048.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud?"></a>什么是Spring Cloud?</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。 </p><p>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</p><h2 id="REST和RPC的区别"><a href="#REST和RPC的区别" class="headerlink" title="REST和RPC的区别"></a>REST和RPC的区别</h2><p> REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。 </p><p> REST调用系统性能较低，RPC调用效率比REST高。 </p><p> REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。 </p><p> REST可以和Swagger等工具整合，自动输出接口API文档。</p><h2 id="SpringCloud如何实现服务的注册和发现"><a href="#SpringCloud如何实现服务的注册和发现" class="headerlink" title="SpringCloud如何实现服务的注册和发现"></a>SpringCloud如何实现服务的注册和发现</h2><p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p><p> 这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。 </p><p> 调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</p><h2 id="什么是服务熔断和服务降级？"><a href="#什么是服务熔断和服务降级？" class="headerlink" title="什么是服务熔断和服务降级？"></a>什么是服务熔断和服务降级？</h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。</p><p>在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p><p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。<br> Hystrix相关注解：<br> @EnableHystrix：开启熔断<br> @HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p><h2 id="服务网关的作用"><a href="#服务网关的作用" class="headerlink" title="服务网关的作用"></a>服务网关的作用</h2><p>简化客户端调用复杂度，统一处理外部请求。 </p><p>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。 </p><p>多渠道支持，针对不同的客户端提供不同的网关支持。 </p><p>遗留系统的微服务化改造，可以作为新老系统的中转组件。 </p><p>统一处理调用过程中的安全、权限问题。</p><h2 id="Ribbon和Feign区别"><a href="#Ribbon和Feign区别" class="headerlink" title="Ribbon和Feign区别"></a>Ribbon和Feign区别</h2><p>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value&#x3D;”服务名称”) 使用RestTemplate调用远程服务对应的方法；Feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”) </p><p>Ribbon和Feign的区别：</p><p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。 </p><p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。 </p><p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。 </p><p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 </p><p>Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p><h2 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h2><p>Zookeepper保证了CP（C：一致性，P：分区容错性） </p><p>Eureka保证了AP（A：高可用） </p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。 </p><p>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： </p><p>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 </p><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。 </p><p>当网络稳定时，当前实例新的注册信息会被同步到其他节点。 </p><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeepper那样使整个微服务瘫痪。</p><h2 id="Spring-Cloud-配置管理——Config"><a href="#Spring-Cloud-配置管理——Config" class="headerlink" title="Spring Cloud 配置管理——Config"></a>Spring Cloud 配置管理——Config</h2><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>为了能够对项目配置进行统一管理，同时又能在项目运行中修改配置，Spring Cloud Config提出了解决方案。</p><p>Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p><p>简单来说，Spring Cloud Config就是能将各个 应用&#x2F;系统&#x2F;模块的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，真实的情况是依赖于这个配置的应用并不会出现更改，这就是BUS总线的作用。</p><p>简单理解为 Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为 消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 Spring Cloud Bus之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><p><img src="https://s2.loli.net/2022/03/13/U4vzH3GP7ckSdlm.jpg"></p><h2 id="服务链路追踪-Spring-Cloud-Sleuth"><a href="#服务链路追踪-Spring-Cloud-Sleuth" class="headerlink" title="服务链路追踪(Spring Cloud Sleuth)"></a>服务链路追踪(Spring Cloud Sleuth)</h2><p>　微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在，一个请求可能需要调用很多个服务，而内部服务的调用复杂性，决定了问题难以定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题，很快定位。</p><p>参考文章：</p><p>[1] <a href="https://my.oschina.net/langwanghuangshifu/blog/3005195">https://my.oschina.net/langwanghuangshifu/blog/3005195</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/post/4159564061.html"/>
      <url>/post/4159564061.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p><strong>面向过程</strong>：</p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展。</li></ul><p><strong>面向对象</strong>：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li><li>缺点：性能比面向过程低。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>封装</strong></p><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 </p><p><strong>继承</strong></p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 </p><p><strong>多态性</strong></p><p>它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</p><ul><li>编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。 </li><li>运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-中的八种基本数据类型"><a href="#Java-中的八种基本数据类型" class="headerlink" title="Java 中的八种基本数据类型"></a>Java 中的八种基本数据类型</h3><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><h3 id="Java语言关键字有哪些？"><a href="#Java语言关键字有哪些？" class="headerlink" title="Java语言关键字有哪些？"></a>Java语言关键字有哪些？</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="final、finally、finalize的区别？"><a href="#final、finally、finalize的区别？" class="headerlink" title="final、finally、finalize的区别？"></a>final、finally、finalize的区别？</h3><p>final 用于修饰变量、方法和类。</p><ul><li>final 变量：被修饰的变量不可变，不可变分为<code>引用不可变</code>和<code>对象不可变</code>，final 指的是<code>引用不可变</code>，final 修饰的变量必须初始化，通常称被修饰的变量为<code>常量</code>。 </li><li>final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。 </li><li>final 类：被修饰的类不能被继承，所有方法不能被重写。</li></ul><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p><h3 id="访问修饰符public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 </li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong> </li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法 </li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="对象相等的判断"><a href="#对象相等的判断" class="headerlink" title="对象相等的判断"></a>对象相等的判断</h2><h3 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p><strong>equals()</strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法</p><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 hashCode值必须是相等。也就是说如果 equals&#96;方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><p>如果重写 equals()时没有重写 hashCode()方法的话就可能会导致 equals方法判断是相等的两个对象，hashCode值却不相等。</p><h3 id="java-创建对象有哪几种方式？"><a href="#java-创建对象有哪几种方式？" class="headerlink" title="java 创建对象有哪几种方式？"></a>java 创建对象有哪几种方式？</h3><p>java中提供了以下四种创建对象的方式:</p><ul><li>new创建新对象 </li><li>通过反射机制 </li><li>采用clone机制 </li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><h3 id="String-StringBuffer-StringBuilder-的区别是什么？"><a href="#String-StringBuffer-StringBuilder-的区别是什么？" class="headerlink" title="String,StringBuffer, StringBuilder 的区别是什么？"></a>String,StringBuffer, StringBuilder 的区别是什么？</h3><p>1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。<strong>对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.</strong></p><p>String类利用了final修饰的char类型数组存储字符，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。</p><p>源码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char[] value;</span><br></pre></td></tr></table></figure><p>2.是否多线程安全。</p><p>String中的对象是不可变的，也就可以理解为常量，显然线程安全。</p><p>StringBuilder是非线程安全的。</p><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><p>1.便于实现字符串池（String pool）</p><p>在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p><p>2.使多线程安全</p><p>在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。</p><p>3.避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p><p>4.加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p><p>总体来说，String不可变的原因要包括<strong>设计考虑</strong>，<strong>效率优化</strong>，以及<strong>安全性</strong>这三大方面。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><blockquote><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></blockquote><h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h3><ul><li>Integer是int的包装类；int是基本数据类型； </li><li>Integer变量必须实例化后才能使用；int变量不需要； </li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； </li><li>Integer的默认值是null；int的默认值是0。</li></ul><h3 id="两个new生成的Integer变量的对比"><a href="#两个new生成的Integer变量的对比" class="headerlink" title="两个new生成的Integer变量的对比"></a>两个new生成的Integer变量的对比</h3><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Integer变量和int变量的对比"><a href="#Integer变量和int变量的对比" class="headerlink" title="Integer变量和int变量的对比"></a>Integer变量和int变量的对比</h3><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c=<span class="number">10000</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="非new生成的Integer变量和new-Integer-生成变量的对比"><a href="#非new生成的Integer变量和new-Integer-生成变量的对比" class="headerlink" title="非new生成的Integer变量和new Integer()生成变量的对比"></a>非new生成的Integer变量和new Integer()生成变量的对比</h3><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c= <span class="number">10000</span>;</span><br><span class="line">System.out.println(b == c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="两个非new生成的Integer对象的对比"><a href="#两个非new生成的Integer对象的对比" class="headerlink" title="两个非new生成的Integer对象的对比"></a>两个非new生成的Integer对象的对比</h3><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ul><li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。</li></ul><h3 id="反射使用的步骤？"><a href="#反射使用的步骤？" class="headerlink" title="反射使用的步骤？"></a>反射使用的步骤？</h3><ol><li>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ol><li><strong>对象序列化可以实现分布式对象。</strong></li></ol><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><p>​    2. <strong>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong> </p><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p><ol start="3"><li><strong>序列化可以将内存中的类写入文件或数据库中。</strong></li></ol><p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p><p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p><ol start="4"><li><strong>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ol><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><h3 id="序列化实现的方式有哪些？"><a href="#序列化实现的方式有哪些？" class="headerlink" title="序列化实现的方式有哪些？"></a>序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p>两种序列化的对比:</p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="什么是serialVersionUID？"><a href="#什么是serialVersionUID？" class="headerlink" title="什么是serialVersionUID？"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性</p><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h3><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。 </li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li></ul><h3 id="非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？"><a href="#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？" class="headerlink" title="非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？"></a>非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h3><p>非受检查异常：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：<code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等。</p><p>受检查异常：是Exception 中除 <code>RuntimeException</code> 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p><p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p><h3 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h3 id="Java常见异常有哪些？"><a href="#Java常见异常有哪些？" class="headerlink" title="Java常见异常有哪些？"></a>Java常见异常有哪些？</h3><ul><li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 </li><li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. </li><li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 </li><li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 </li><li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 </li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 </li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。 </li><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 </li><li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 </li><li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 </li><li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 </li><li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 </li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 </li><li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 </li><li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="常用的通配符有哪些？"><a href="#常用的通配符有哪些？" class="headerlink" title="常用的通配符有哪些？"></a>常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的IO-流分为几种？"><a href="#Java的IO-流分为几种？" class="headerlink" title="Java的IO 流分为几种？"></a>Java的IO 流分为几种？</h3><ul><li>按照流的方向：输入流（inputStream）和输出流（outputStream）； </li><li>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）； </li><li>按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。</li></ul><h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><ul><li>读写的时候字节流是按字节读写，字符流按字符读写。 </li><li>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。 </li><li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 </li><li>只是读写文件，和文件内容无关时，一般选择字节流。</li></ul><h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 </p><img src="https://s2.loli.net/2022/03/13/6YqGgnEKibOeA3W.png" style="zoom:67%;" /><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。 </p><img src="https://s2.loli.net/2022/03/13/BUk9fdSj63tl4OA.png" style="zoom:67%;" /><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p><img src="https://s2.loli.net/2022/03/13/V76rpuQP2SXk81f.png" style="zoom:67%;" /><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/853116">Java基础八股文连环80问_笔经面经_牛客网 (nowcoder.com)</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（二）</title>
      <link href="/post/6004.html"/>
      <url>/post/6004.html</url>
      
        <content type="html"><![CDATA[<p>本文将接前文，继续讲述python程序对微信云开发数据库的操作。</p><h2 id="间接操作"><a href="#间接操作" class="headerlink" title="间接操作"></a>间接操作</h2><p>间接操作指的是python通过云函数对云开发数据库进行操作。所有的操作都是在获取access_token的前提下进行的，不懂的同学可以参考：链接: <a href="https://blog.csdn.net/qq_44001007/article/details/103944492">link</a>.<br>同时由于请求python请求云函数的代码基本类似，只有在data里面进行参数的变换即可，给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xxxx</span>(<span class="params">self</span>):</span><br><span class="line">    //在函数括号内需要添加参数</span><br><span class="line">    ACCESS_TOKEN = xxx   //获取的access_token</span><br><span class="line">    ENV = xxx                      //用户的数据库环境ID</span><br><span class="line">    FUNCTION_NAME = xxx   //所要执行的云函数名</span><br><span class="line">    url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=&#x27;</span> + ACCESS_TOKEN + <span class="string">&#x27;&amp;env=&#x27;</span> + ENV + <span class="string">&#x27;&amp;name=&#x27;</span> + FUNCTION_NAME</span><br><span class="line">    data = &#123;</span><br><span class="line">    //所要传输的参数</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url, data=json.dumps(data))</span><br><span class="line">    result = response.json()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>云函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.<span class="title function_">init</span>()</span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> db.<span class="title function_">createCollection</span>(event.<span class="property">id</span>)</span><br><span class="line">  <span class="comment">//event.id是python传输的数据，为该集合的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createCollection</span>(<span class="params">self，<span class="built_in">id</span></span>):</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="built_in">id</span>,</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h3><p>云函数：</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ndnSIM实现一发多收</title>
      <link href="/post/52359.html"/>
      <url>/post/52359.html</url>
      
        <content type="html"><![CDATA[<p>直接进入正题，想要实现一发多收，就是要在路由进行广播时转发的兴趣包与接收到数据包的数目相等，即For_num&#x3D;&#x3D;Rec_num；但正常情况下，路由在第一次接收到数据包时就会把pit条目删除，所以接下来的目的是在接收到数据包对删除pit的命令进行修改。</p><h2 id="pit条目修改"><a href="#pit条目修改" class="headerlink" title="pit条目修改"></a>pit条目修改</h2><p>先进入到ndnSIM源目录下</p><p><img src="https://s2.loli.net/2022/03/13/c1q9ETghuMdUK3w.png"></p><p>然后进入pit-entry.cpp&#x2F;.hpp所在目录，对这两个文件进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd NFD/daemon/table/</span><br></pre></td></tr></table></figure><p>先对hpp进行修改，添加For_NUM和Rec_NUM两个变量</p><p><img src="https://s2.loli.net/2022/03/13/ZDa2F4NlGQ5Ocwo.png"></p><p>然后添加获取参数的函数与对变量操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_RecNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Rec_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_ForNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> For_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_inter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> For_NUM++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Rec_NUM++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下进行参数的初始化定义，在cpp中实现</p><p><img src="https://s2.loli.net/2022/03/13/AESXW1HhkKRD3xe.png"></p><h2 id="转发策略修改"><a href="#转发策略修改" class="headerlink" title="转发策略修改"></a>转发策略修改</h2><h3 id="after-Recevie-Interest"><a href="#after-Recevie-Interest" class="headerlink" title="after Recevie Interest"></a>after Recevie Interest</h3><p>进入forwarder.cpp所在文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable constant_">NFD</span>/daemon/fw</span><br></pre></td></tr></table></figure><p>修改onOutgoingInterest（）函数</p><p><img src="https://s2.loli.net/2022/03/13/yH9XEQ1fVdRsglu.png"></p><h3 id="after-Recevie-data"><a href="#after-Recevie-data" class="headerlink" title="after Recevie data"></a>after Recevie data</h3><p>在同一个目录下打开strategy.cpp文件，对sendData（）函数进行修改</p><p><img src="https://s2.loli.net/2022/03/13/YxvCfIayOSl2L18.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行一个具有多个生产者的路由拓扑，查看路由接收的数据包数量，即可确认是否实现一发多收。</p><p><img src="https://s2.loli.net/2022/03/13/nkbEUVugKwcrqdZ.png"></p><p>有上图可以得出接收的是发送的两倍，实现一发多收。</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu安装ndnSIM</title>
      <link href="/post/57172.html"/>
      <url>/post/57172.html</url>
      
        <content type="html"><![CDATA[<p>通过对资料的查询获取相对应的版本号与ndnsim之间的关系：</p><table><thead><tr><th>操作系统</th><th>Ubuntu 18</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.7</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-ns-3.29</td></tr><tr><td>pybindgen</td><td>0.19.0</td></tr></tbody></table><p>如果想要安装其他版本，请找到上述条件所对应的版本号即可。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml</span><br><span class="line">sudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gi libgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip</span><br><span class="line">pip install pygraphviz pycairo PyGObject pygccxml</span><br><span class="line">sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config</span><br><span class="line">pip install pygraphviz</span><br></pre></td></tr></table></figure><p>可能出现报错无法安装的情况，我把后面的安装好，在安装前面的就成功了;同时这是Ubuntu18所需要的依赖环境，其他版本请参照官网。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>现在任意文件创建个ndnsim文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ndnSIM2.7</span><br></pre></td></tr></table></figure><p>然后进入该文件夹下，进行源码的下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>记住千万不要在最后一条命令按照官网的说法加上–recursive，这样就会把NFD和ndn-cxx模块直接下载最新版本，这样后面的操作就无效了。</p><h2 id="修改对应版本号"><a href="#修改对应版本号" class="headerlink" title="修改对应版本号"></a>修改对应版本号</h2><p>这里的命令依靠git实现，能到这一步肯定都安装好了，就不多说了。<br>首先进入到ndnSIM的核心源码地带</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>通过git checkout修改版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-2.7</span><br></pre></td></tr></table></figure><p>也可以通过git tag查看所有的版本号，然后修改为想要安装的版本</p><p><img src="https://img-blog.csdnimg.cn/20200725105311613.png"></p><p>然后安装NFD和ndn-cxx模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><p>接下来进入到ndnSIM2.7&#x2F;ns-3文件下进行版本的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-ns-3.29</span><br></pre></td></tr></table></figure><p>出现如图所示即为成功</p><p><img src="https://s2.loli.net/2022/03/12/LtPm79ICKAYwdrg.png"></p><p>接下对pybindgen的版本进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7/pybindgen</span><br><span class="line">git checkout 0.19.0</span><br></pre></td></tr></table></figure><p>然后在此目录下安装安装该python模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2022/03/12/fnUh7aDJ2MOErR5.png"></p><h2 id="运行编译"><a href="#运行编译" class="headerlink" title="运行编译"></a>运行编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.1/ns-3</span><br><span class="line">./waf configure --enable-examples</span><br><span class="line">./waf</span><br><span class="line">./waf --run ndn-simple --vis</span><br></pre></td></tr></table></figure><p>正常情况直接编译完成，出现错误的话请看下面的修改提示</p><p><img src="https://s2.loli.net/2022/03/12/B1fgyvZdDbkqxri.png"></p><p>进入到可视化模块下将‘file&#x3D;’删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  ndnSIM2.7/ns-3/src/visualizer/visualizer</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/12/q8nABHgkLvl2smt.png"></p><p>进入base.py文件，修改保存即可</p><p><img src="https://s2.loli.net/2022/03/12/ka8ywbI1o5YvpLj.png"></p><p>第二种错误可能出现在运行时加上–vis可视化模块时，如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/UDG7XjaZmOF3BuJ.png"></p><p>这种情况下，还是进入刚才的那个文件夹，修改hub.py文件</p><p><img src="https://s2.loli.net/2022/03/12/brEc9vg3pFwqhsj.png"></p><p>将from . import注释，修改为import core。再次运行就可以了</p><p><img src="https://s2.loli.net/2022/03/12/94Q7mq85lV1ekwz.png"></p><p>经过试验，添加Ubuntu16的对应版本</p><table><thead><tr><th>操作系统</th><th>Ubuntu 16</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.5</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-v2.5</td></tr><tr><td>pybindgen</td><td>0.18.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（一）</title>
      <link href="/post/34574.html"/>
      <url>/post/34574.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述python程序对微信云开发数据库的操作。</p><h1 id="直接操作"><a href="#直接操作" class="headerlink" title="直接操作"></a>直接操作</h1><p>直接操作指的是通过python程序对云开发数据库直接进行操作。<br>所有的操作前提都是在获取access_token下进行的，先通过下列代码获取access_token在进行接下来的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access_token</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           获取access_token</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        APPID = <span class="string">&#x27;**********&#x27;</span>                        //小程序ID</span><br><span class="line">        APPSECRET = <span class="string">&#x27;**************&#x27;</span>                //小程序秘钥</span><br><span class="line">        WECHAT_URL = <span class="string">&#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#x27;</span> + APPID + <span class="string">&#x27;&amp;secret=&#x27;</span> + APPSECRET</span><br><span class="line">        response = requests.get(WECHAT_URL)</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&quot;access_token&quot;</span>]     //将返回值解析获取access_token</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>此方法的创建只需要将集合的名字post给数据库即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseCollectionAdd</span>(<span class="params">access_token</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          创建数据库</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasecollectionadd?access_token&#x27;</span>+access_token</span><br><span class="line">       data=&#123;</span><br><span class="line">             <span class="string">&quot;env&quot;</span>:<span class="string">&quot;******&quot;</span>,                //用户的数据库环境ID</span><br><span class="line">             <span class="string">&quot;collection_name&quot;</span>: <span class="string">&quot;*******&quot;</span>   //数据库集合的名称</span><br><span class="line">             &#125;</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><p>将集合的名字Post即可返回该集合的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检索数据库</span></span><br><span class="line"><span class="string">           collection_name 集合的名称</span></span><br><span class="line"><span class="string">           .limit() 括号内的数值限定返回的记录数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasequery?access_token=&#x27;</span> + access_token</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).limit(100).get()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(url, data=json.dumps(data))</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>通过Post集合名字和Add函数对内容（datas）的传输。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseAdd</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       新建记录并对内容进行定义</span></span><br><span class="line"><span class="string">       collection_name 集合的名称</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).add(&#123;&quot;</span>+datas+<span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       datas=[&#123;</span><br><span class="line">       <span class="string">&quot;字段名称&quot;</span>：<span class="string">&quot;内容&quot;</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       这里主要是对创建记录的直接定义</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">             &#125;]</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><p>经测试这种创建记录的方式对datas的定义要求较为严格，一但定义不够严格会出现创建失败，所以建议通过间接的方式对数据库进行插入记录。</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>通过Post集合名称将该集合直接从数据库移除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         collection_name 集合的名称</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasedelete?access_token=&#x27;</span> + access_token</span><br><span class="line">      data = &#123;</span><br><span class="line">          <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">          <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;)..where(&#123;done:false&#125;).remove()&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      response = requests.post(url, data=json.dumps(data))</span><br><span class="line">      result = response.json()</span><br><span class="line">      <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>更新记录是对已有的记录内容进行修改，所以说想要对记录内容修改不可用.add()进行，通过.update()进行内容修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseUpdate</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       .where() 该集合所在记录的检索</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).where(&#123;age:14&#125;).update(&#123;data:&#123;age: _.inc(1)&#125;&#125;)&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">      &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">      这个例子是将集合里age=<span class="number">14</span>所有记录自增<span class="number">1</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       response = requests.post(url, data=json.dumps(data))</span></span><br><span class="line"><span class="string">       result = response.json()</span></span><br><span class="line"><span class="string">       print(result)     //将返回值打印</span></span><br></pre></td></tr></table></figure><p>更新是对记录的操作，所以很需要.where()的帮助，请大家牢记该函数的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是通过对微信小程序一段时间的学习后总结出来的，本作者是个新人，如有错误可指出，我将及时改正。<br>第二部分是通过调用云函数来对数据库进行操作，这种方法的BUG似乎比直接操作少。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nRF52840作为通信模块与Arduino的联动</title>
      <link href="/post/10336.html"/>
      <url>/post/10336.html</url>
      
        <content type="html"><![CDATA[<h3 id="蓝牙控制Arduino板上13号引脚灯的开关"><a href="#蓝牙控制Arduino板上13号引脚灯的开关" class="headerlink" title="蓝牙控制Arduino板上13号引脚灯的开关"></a>蓝牙控制Arduino板上13号引脚灯的开关</h3><h4 id="开发环境及工具"><a href="#开发环境及工具" class="headerlink" title="开发环境及工具"></a>开发环境及工具</h4><table><thead><tr><th></th><th>名称</th></tr></thead><tbody><tr><td>开发工具</td><td>Segger Embedded Studio</td></tr><tr><td>SDK版本</td><td>nRF5_SDK_15.3.0_59ac345</td></tr><tr><td>开发板</td><td>IK-nRF52840DK+Arduino Uno+IO扩展板</td></tr><tr><td>J-link</td><td>ARM-V9仿真器</td></tr><tr><td>手机App</td><td>nRF UART v2.0</td></tr></tbody></table><h4 id="nRF52840的代码烧录"><a href="#nRF52840的代码烧录" class="headerlink" title="nRF52840的代码烧录"></a>nRF52840的代码烧录</h4><p>打开SKD中示例的ble_app_uart，路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\nRF5_SDK_15.3.0_59ac345\examples\ble_peripheral\ble_app_uart\pca10056\s140\ses</span><br></pre></td></tr></table></figure><p>在main函数中将循环实例修改：</p><img src="https://s2.loli.net/2022/03/12/SyufYqkPidp9lae.png" style="zoom: 80%;" /><p>红圈里的修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> cr;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_get</span>(&amp;cr) != NRF_SUCCESS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_put</span>(cr) != NRF_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cr == <span class="string">&#x27;q&#x27;</span> || cr == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; \r\nExit!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后Build，Debug：</p><img src="https://s2.loli.net/2022/03/12/mXoL1pqk4ysEP9Q.png" style="zoom:67%;" /><img src="https://s2.loli.net/2022/03/12/gMkvVwdZ93WDc5Q.png" style="zoom:67%;" /><h4 id="Arduino的测试代码"><a href="#Arduino的测试代码" class="headerlink" title="Arduino的测试代码"></a>Arduino的测试代码</h4><p>将测试代码刷入Arduino就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"> <span class="built_in">pinMode</span>(<span class="number">13</span>,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Serial.<span class="built_in">available</span>())&#123;</span><br><span class="line">    ss=Serial.<span class="built_in">read</span>();</span><br><span class="line">  Serial.<span class="built_in">println</span>(ss);</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">digitalWrite</span>(<span class="number">13</span>,HIGH); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">digitalWrite</span>(<span class="number">13</span>,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固件连接"><a href="#固件连接" class="headerlink" title="固件连接"></a>固件连接</h4><p>将nRF52840的P06号脚接到IO扩展板上的RX接口，然后将VCC和GND与IO扩展板相应位置连接，如下图：</p><img src="https://s2.loli.net/2022/03/12/5ARiQ2kcNTVZPmF.png" style="zoom:50%;" /><p>然后Arduino板通上电。</p><h4 id="手机蓝牙端测试"><a href="#手机蓝牙端测试" class="headerlink" title="手机蓝牙端测试"></a>手机蓝牙端测试</h4><p>1.打开App搜索设备</p><img src="https://s2.loli.net/2022/03/12/YHX76db9yNPOaAB.png" style="zoom: 33%;" /><p>连接_UART设备<br>2.发送测试数据字符1</p><img src="https://s2.loli.net/2022/03/12/bSqRlZeEKkUvrnu.png" style="zoom:33%;" /><p>然后板上13灯亮起</p><img src="https://s2.loli.net/2022/03/12/WrNcS3XsHnOwyCx.png" style="zoom:50%;" /><p>3.输入其他任意字符熄灭</p><img src="https://s2.loli.net/2022/03/12/zfd4oCUTIFHA1se.png" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/03/12/QrER1vYujwzAGOD.png" style="zoom:50%;" /><p>到这里就基本结束测试，当然大家可以在扩展板上加更多的传感器去实现更加强大的功能!!!!!</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nordic nRF52840 入门学习</title>
      <link href="/post/4057281378.html"/>
      <url>/post/4057281378.html</url>
      
        <content type="html"><![CDATA[<h3 id="Board-Definition组"><a href="#Board-Definition组" class="headerlink" title="Board Definition组"></a>Board Definition组</h3><p>“ Board Definition”组中加入板卡定义文件“ boards.c”,该文件针对于具体板卡,主要要用来定义板卡的指示灯、按键、IO输出电压(仅nRFS2840具有此功能)以及常用的操作函数。对于Nordic nRF52840开发板(兼容 Nordic的PCA10056),设计了4个指示灯和按键,在“ boards.c”文件中,我们可以看到这些按键和指示灯的初始化函数以及一些基本功能如点亮、熄灭、翻转的操作函数。</p><p><img src="https://s2.loli.net/2022/03/12/8pnHB7jaXv2kP1Y.png"></p><h3 id="Board-Support组"><a href="#Board-Support组" class="headerlink" title="Board Support组"></a>Board Support组</h3><p>“ Board Support”组加入的是板卡支持包文件,即BSP文件,主要用于实现指示灯和按键的驱动。</p><p><img src="https://s2.loli.net/2022/03/12/WS51mxILhzJCi23.png"></p><h3 id="UTF8-x2F-UTF16-converter-组"><a href="#UTF8-x2F-UTF16-converter-组" class="headerlink" title="UTF8&#x2F;UTF16 converter 组"></a>UTF8&#x2F;UTF16 converter 组</h3><p>“UTF8&#x2F;UTF16 converter”组只需加入一个实现UTF8&#x2F;UTF16编码转换的文件。<br><img src="https://s2.loli.net/2022/03/12/4Lein2tspcY97rK.png"></p><h3 id="NRF-BLE组"><a href="#NRF-BLE组" class="headerlink" title="NRF BLE组"></a>NRF BLE组</h3><p>“ NRF BLE”组加入的是BLE相关的库文件,如广播、连接参数协、配对管理等等。<br><img src="https://s2.loli.net/2022/03/12/KgaQWBhncswMU2b.png"></p><h3 id="NRF-Drivers组"><a href="#NRF-Drivers组" class="headerlink" title="NRF Drivers组"></a>NRF Drivers组</h3><p>“ NRF Drivers”组加入的是各种外设的驱动库文件,如时钟、 GPOTE、UART等等。<br><img src="https://s2.loli.net/2022/03/12/M3wb9xsVk8r6tGI.png"></p><h3 id="NRF-Libraries"><a href="#NRF-Libraries" class="headerlink" title="NRF Libraries"></a>NRF Libraries</h3><p>“ NRF Libraries”组加入的是各种应用的库文件,如APP定时器、CRC校验、软件FIFO、<br>简易文件系统以及错误处理等等。<br><img src="https://s2.loli.net/2022/03/12/SsLUGfnVT13moBE.png"></p><h3 id="NRF-Log组"><a href="#NRF-Log组" class="headerlink" title="NRF Log组"></a>NRF Log组</h3><p>“ NRF Log”组中加入的文件如下表所示,Log程序模块为程序提供日志打印功能。<br><img src="https://s2.loli.net/2022/03/12/zhJHxUvIKMVwnY9.png"></p><h3 id="NRF-Segger-RT组"><a href="#NRF-Segger-RT组" class="headerlink" title="NRF Segger_RT组"></a>NRF Segger_RT组</h3><p>nRF_ Segger_RTT”组中加入的文件如下表所示,它们的作用是实现 JLINK- RTT Viewer<br>作为Log输出终端,打印Log。<br><img src="https://s2.loli.net/2022/03/12/E61qimBFjCzGpUP.png"></p><h3 id="NRE-Softdevice"><a href="#NRE-Softdevice" class="headerlink" title="NRE Softdevice"></a>NRE Softdevice</h3><p>“nRF_ Softdevice”组中加入的文件如下表所示,它们用于使能或禁止 Softdevice以及<br>向应用程序发布 Softdevice事件,功能如下:</p><p>(1)使能 Softdevice及其事件中断。</p><p>(2)禁止 Softdevice。</p><p>(3)从 Softdevice接收堆栈事件,并将它们转发给应用程序已注册的事件监查者。</p><p>(4)发送 Softdevice状态事件给应用程序和驱动。</p><p>(5)发送可由事件监查者接受或拒绝的SoftDevice状态请求。<br><img src="https://s2.loli.net/2022/03/12/Ils5mSyvA7k1Uwr.png"></p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turtle 3PA三轮小车基于pixhawk的改装（一）</title>
      <link href="/post/53698.html"/>
      <url>/post/53698.html</url>
      
        <content type="html"><![CDATA[<h1 id="Turtle-3PA三轮小车基于pixhawk的改装之准备"><a href="#Turtle-3PA三轮小车基于pixhawk的改装之准备" class="headerlink" title="Turtle 3PA三轮小车基于pixhawk的改装之准备"></a>Turtle 3PA三轮小车基于pixhawk的改装之准备</h1><p>今天在老师的指导下，对Arduino的小车进行改装，想要用pixhawk自动驾驶仪对小车进行控制。<br>工具准备：<br>（1）硬件<br>pixhawk控制板:</p><p><img src="https://s2.loli.net/2022/03/12/4zsFJA7OLHZD6UP.png"></p><p>Turtle 3PA三轮小车：</p><p><img src="https://s2.loli.net/2022/03/12/gxma9oRutrOfMyX.png"></p><p>详细信息：<a href="http://www.dfrobot.com.cn/goods-1069.html">http://www.dfrobot.com.cn/goods-1069.html</a></p><p>乐迪at9s：</p><p><img src="https://s2.loli.net/2022/03/12/39ucVU6LwgjZ1sm.png"></p><p>（2）软件<br>Mission planner：</p><p><img src="https://s2.loli.net/2022/03/12/hxqV1kIG29iJBYo.png"></p><p>官网：<a href="http://ardupilot.org/planner/">http://ardupilot.org/planner/</a><br>QGround：</p><p><img src="https://s2.loli.net/2022/03/12/7ASgCUQti9TrePN.png"></p><p>官网：<a href="http://qgroundcontrol.com/">http://qgroundcontrol.com/</a></p><p>两个地面站是为了刷飞控固件的方便，在对pixhawk飞控刷小车固件的时候总会出现Bad Ahrs，为了解决这个问题因此采用QGround。<br>具体的刷的方法在下个博客说明。</p>]]></content>
      
      
      <categories>
          
          <category> 科技杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pixhawk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
