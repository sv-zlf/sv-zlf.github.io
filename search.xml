<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见maven依赖</title>
      <link href="/post/3791434479.html"/>
      <url>/post/3791434479.html</url>
      
        <content type="html"><![CDATA[<h3 id="Sping-Boot-Web依赖"><a href="#Sping-Boot-Web依赖" class="headerlink" title="Sping Boot Web依赖"></a>Sping Boot Web依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Test-测试起步依赖"><a href="#Test-测试起步依赖" class="headerlink" title="Test 测试起步依赖"></a>Test 测试起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger依赖导入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mybaits"><a href="#Mybaits" class="headerlink" title="Mybaits"></a>Mybaits</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="commons-lang包"><a href="#commons-lang包" class="headerlink" title="commons-lang包"></a>commons-lang包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Security --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JWT--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger配置</title>
      <link href="/post/162472822.html"/>
      <url>/post/162472822.html</url>
      
        <content type="html"><![CDATA[<h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger依赖导入--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="swagger配置类"><a href="#swagger配置类" class="headerlink" title="swagger配置类"></a>swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ParameterBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.schema.ModelRef;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Parameter;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//开启在线文档</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        添加head参数</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line"><span class="comment">/*        ParameterBuilder tokenPar = new ParameterBuilder();</span></span><br><span class="line"><span class="comment">        List&lt;Parameter&gt; pars = new ArrayList&lt;Parameter&gt;();</span></span><br><span class="line"><span class="comment">        tokenPar.name(&quot;token&quot;).description(&quot;AccessToken令牌&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(false).build();</span></span><br><span class="line"><span class="comment">        pars.add(tokenPar.build());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .pathMapping(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .select() <span class="comment">// 选择那些路径和api会生成document</span></span><br><span class="line">                .apis(RequestHandlerSelectors.any())<span class="comment">// 对所有api进行监控</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.xxx.xxx.controller&quot;</span>))</span><br><span class="line">                .build()</span><br><span class="line">                .globalOperationParameters(pars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;XXXXX&quot;</span>)        <span class="comment">//api文档名字</span></span><br><span class="line">                .description(<span class="string">&quot;XXXXX&quot;</span>)   <span class="comment">//api名字</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://www.zlfeng.cn/&quot;</span>)  <span class="comment">//附带链接资源</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud学习</title>
      <link href="/post/1251775048.html"/>
      <url>/post/1251775048.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud?"></a>什么是Spring Cloud?</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><h2 id="Spring-Cloud和Dubbo的区别"><a href="#Spring-Cloud和Dubbo的区别" class="headerlink" title="Spring Cloud和Dubbo的区别"></a>Spring Cloud和Dubbo的区别</h2><p>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。 </p><p>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</p><h2 id="REST和RPC的区别"><a href="#REST和RPC的区别" class="headerlink" title="REST和RPC的区别"></a>REST和RPC的区别</h2><p> REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。 </p><p> REST调用系统性能较低，RPC调用效率比REST高。 </p><p> REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。 </p><p> REST可以和Swagger等工具整合，自动输出接口API文档。</p><h2 id="SpringCloud如何实现服务的注册和发现"><a href="#SpringCloud如何实现服务的注册和发现" class="headerlink" title="SpringCloud如何实现服务的注册和发现"></a>SpringCloud如何实现服务的注册和发现</h2><p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p><p> 这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。 </p><p> 调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</p><h2 id="什么是服务熔断和服务降级？"><a href="#什么是服务熔断和服务降级？" class="headerlink" title="什么是服务熔断和服务降级？"></a>什么是服务熔断和服务降级？</h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。</p><p>在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p><p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。<br> Hystrix相关注解：<br> @EnableHystrix：开启熔断<br> @HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p><h2 id="服务网关的作用"><a href="#服务网关的作用" class="headerlink" title="服务网关的作用"></a>服务网关的作用</h2><p>简化客户端调用复杂度，统一处理外部请求。 </p><p>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。 </p><p>多渠道支持，针对不同的客户端提供不同的网关支持。 </p><p>遗留系统的微服务化改造，可以作为新老系统的中转组件。 </p><p>统一处理调用过程中的安全、权限问题。</p><h2 id="Ribbon和Feign区别"><a href="#Ribbon和Feign区别" class="headerlink" title="Ribbon和Feign区别"></a>Ribbon和Feign区别</h2><p>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value&#x3D;”服务名称”) 使用RestTemplate调用远程服务对应的方法；Feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(“指定服务名”) </p><p>Ribbon和Feign的区别：</p><p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。 </p><p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。 </p><p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。 </p><p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 </p><p>Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p><h2 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h2><p>Zookeepper保证了CP（C：一致性，P：分区容错性） </p><p>Eureka保证了AP（A：高可用） </p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。 </p><p>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： </p><p>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 </p><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。 </p><p>当网络稳定时，当前实例新的注册信息会被同步到其他节点。 </p><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeepper那样使整个微服务瘫痪。</p><h2 id="Spring-Cloud-配置管理——Config"><a href="#Spring-Cloud-配置管理——Config" class="headerlink" title="Spring Cloud 配置管理——Config"></a>Spring Cloud 配置管理——Config</h2><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p><p>为了能够对项目配置进行统一管理，同时又能在项目运行中修改配置，Spring Cloud Config提出了解决方案。</p><p>Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p><p>简单来说，Spring Cloud Config就是能将各个 应用&#x2F;系统&#x2F;模块的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><blockquote><p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p></blockquote><p>如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，真实的情况是依赖于这个配置的应用并不会出现更改，这就是BUS总线的作用。</p><p>简单理解为 Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为 消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。</p><p>而拥有了 Spring Cloud Bus之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p><p><img src="https://s2.loli.net/2022/03/13/U4vzH3GP7ckSdlm.jpg"></p><h2 id="服务链路追踪-Spring-Cloud-Sleuth"><a href="#服务链路追踪-Spring-Cloud-Sleuth" class="headerlink" title="服务链路追踪(Spring Cloud Sleuth)"></a>服务链路追踪(Spring Cloud Sleuth)</h2><p>　微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在，一个请求可能需要调用很多个服务，而内部服务的调用复杂性，决定了问题难以定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题，很快定位。</p><p>参考文章：</p><p>[1] <a href="https://my.oschina.net/langwanghuangshifu/blog/3005195">https://my.oschina.net/langwanghuangshifu/blog/3005195</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/springcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发</title>
      <link href="/post/2441703857.html"/>
      <url>/post/2441703857.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>**初始(NEW)**：线程被构建，还没有调用 start()。</p><p>**运行(RUNNABLE)**：包括操作系统的就绪和运行两种状态。</p><p>**阻塞(BLOCKED)**：一般是被动的，在抢占资源中得不到资源，被动的挂起在内存，等待资源释放将其唤醒。线程被阻塞会释放CPU，不释放内存。</p><p>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</p><p>**终止(TERMINATED)**：表示该线程已经执行完毕。</p><p><img src="https://s2.loli.net/2022/03/16/XNZAb7iBdV21lL3.png"></p><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别?"></a>并发与并行的区别?</h3><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li></ul><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="讲讲线程中断？"><a href="#讲讲线程中断？" class="headerlink" title="讲讲线程中断？"></a>讲讲线程中断？</h3><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑取决于目标线程。</p><p>线程中断三个重要的方法：</p><p><strong>1、java.lang.Thread#interrupt</strong></p><p>调用目标线程的<code>interrupt()</code>方法，给目标线程发一个中断信号，线程被打上中断标记。</p><p><strong>2、java.lang.Thread#isInterrupted()</strong></p><p>判断目标线程是否被中断，不会清除中断标记。</p><p><strong>3、java.lang.Thread#interrupted</strong></p><p>判断目标线程是否被中断，会清除中断标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Java技术栈线程被中断，程序退出。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h3><ul><li>通过扩展<code>Thread</code>类来创建多线程</li><li>通过实现<code>Runnable</code>接口来创建多线程</li><li>实现<code>Callable</code>接口，通过<code>FutureTask</code>接口创建线程。</li><li>使用<code>Executor</code>框架来创建线程池。</li></ul><p><strong>继承 Thread 创建线程</strong>代码如下。run()方法是由jvm创建完操作系统级线程后回调的方法，不可以手动调用，手动调用相当于调用普通方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread1.start();</span><br><span class="line">        mThread2.start();</span><br><span class="line">        myThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runnable 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Runnable1</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>可以避免java中的单继承的限制</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类</li></ol><p><strong>Callable 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callable1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步计算的结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(result).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务完成，返回结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Executor 创建线程代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 程序员大彬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2021-09-11 10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取ExecutorService实例，生产禁用，需要手动创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableDemo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大彬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runnable和Callable有什么区别？"><a href="#Runnable和Callable有什么区别？" class="headerlink" title="Runnable和Callable有什么区别？"></a>Runnable和Callable有什么区别？</h3><ul><li>Callable接口方法是<code>call()</code>，Runnable的方法是<code>run()</code>；</li><li>Callable接口call方法有返回值，支持泛型，Runnable接口run方法无返回值。</li><li>Callable接口<code>call()</code>方法允许抛出异常；而Runnable接口<code>run()</code>方法不能继续上抛异常。</li></ul><h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://s2.loli.net/2022/03/16/7mgxOrW1Q6PHfDv.png"></p><h3 id="线程死锁怎么产生？怎么避免？"><a href="#线程死锁怎么产生？怎么避免？" class="headerlink" title="线程死锁怎么产生？怎么避免？"></a>线程死锁怎么产生？怎么避免？</h3><p><strong>死锁产生的四个必要条件</strong>：</p><ul><li>互斥：一个资源每次只能被一个进程使用</li><li>请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源</li><li>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺</li><li>循环等待：进程之间循环等待着资源</li></ul><p><strong>避免死锁的方法</strong>：</p><ul><li>互斥条件不能破坏，因为加锁就是为了保证互斥</li><li>一次性申请所有的资源，避免线程占有资源而且在等待其他资源</li><li>占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源</li><li>按序申请资源</li></ul><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><ul><li>两者最主要的区别在于：**<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁** 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep() </code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h3 id="线程run和start的区别？"><a href="#线程run和start的区别？" class="headerlink" title="线程run和start的区别？"></a>线程run和start的区别？</h3><ul><li>当程序调用<code>start()</code>方法，将会创建一个新线程去执行<code>run()</code>方法中的代码。<code>run()</code>就像一个普通方法一样，直接调用<code>run()</code>的话，不会创建新线程。</li><li>一个线程的 <code>start()</code> 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常。<code>run()</code> 方法则没有限制。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池：一个管理线程的池子。</p><h3 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h3><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。统一管理线程，避免系统创建大量同类线程而导致消耗完内存。</li></ul><h3 id="线程池执行原理？"><a href="#线程池执行原理？" class="headerlink" title="线程池执行原理？"></a>线程池执行原理？</h3><p><img src="https://s2.loli.net/2022/03/16/JPO5hXagxrS2poG.png"></p><ol><li>当线程池里存活的线程数小于核心线程数<code>corePoolSize</code>时，这时对于一个新提交的任务，线程池会创建一个线程去处理任务。当线程池里面存活的线程数小于等于核心线程数<code>corePoolSize</code>时，线程池里面的线程会一直存活着，就算空闲时间超过了<code>keepAliveTime</code>，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>了，这是对于一个新提交的任务，会被放进任务队列<code>workQueue</code>排队等待执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>了，并且任务队列也满了，假设<code>maximumPoolSize&gt;corePoolSize</code>，这时如果再来新的任务，线程池就会继续创建新的线程来处理新的任务，知道线程数达到<code>maximumPoolSize</code>，就不会再创建了。</li><li>如果当前的线程数达到了<code>maximumPoolSize</code>，并且任务队列也满了，如果还有新的任务过来，那就直接采用拒绝策略进行处理。默认的拒绝策略是抛出一个<code>RejectedExecutionException</code>异常。</li></ol><h3 id="线程池参数有哪些？"><a href="#线程池参数有哪些？" class="headerlink" title="线程池参数有哪些？"></a>线程池参数有哪些？</h3><p>ThreadPoolExecutor 的通用构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span>;</span><br></pre></td></tr></table></figure><p>1、<code>corePoolSize</code>：当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列。当线程池中存活的线程数总是大于 corePoolSize 时，应该考虑调大 corePoolSize。</p><p>2、<code>maximumPoolSize</code>：当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务。非核心线程类似于临时借来的资源，这些线程在空闲时间超过 keepAliveTime 之后，就应该退出，避免资源浪费。</p><p>3、<code>BlockingQueue</code>：存储等待运行的任务。</p><p>4、<code>keepAliveTime</code>：<strong>非核心线程</strong>空闲后，保持存活的时间，此参数只对非核心线程有效。设置为0，表示多余的空闲线程会被立即终止。</p><p>5、<code>TimeUnit</code>：时间单位</p><p>6、<code>ThreadFactory</code>：每当线程池创建一个新的线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新线程就会调用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadFactory</span><span class="params">(String poolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAppThread</span>(runnable, poolName);<span class="comment">//将线程池名字传递给构造函数，用于区分不同线程池的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、<code>RejectedExecutionHandler</code>：当队列和线程池都满了的时候，根据拒绝策略处理新任务。</p><p>AbortPolicy：默认的策略，直接抛出RejectedExecutionException<br>DiscardPolicy：不处理，直接丢弃<br>DiscardOldestPolicy：将等待队列队首的任务丢弃，并执行当前任务<br>CallerRunsPolicy：由调用线程处理该任务</p><h3 id="线程池大小怎么设置？"><a href="#线程池大小怎么设置？" class="headerlink" title="线程池大小怎么设置？"></a>线程池大小怎么设置？</h3><p>如果线程池线程数量太小，当有大量请求需要处理，系统响应比较慢，会影响用户体验，甚至会出现任务队列大量堆积任务导致OOM。</p><p>如果线程池线程数量过大，大量线程可能会同时抢占 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了执行效率。</p><p>**CPU 密集型任务(N+1)**： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为<code> N（CPU 核心数）+1</code>，多出来的一个线程是为了防止某些原因导致的线程阻塞（如IO操作，线程sleep，等待锁）而带来的影响。一旦某个线程被阻塞，释放了CPU资源，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p>**I&#x2F;O 密集型任务(2N)**： 系统的大部分时间都在处理 IO 操作，此时线程可能会被阻塞，释放CPU资源，这时就可以将 CPU 交出给其它线程使用。因此在 IO 密集型任务的应用中，可以多配置一些线程，具体的计算方法：<code>最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (IO耗时/CPU耗时))</code>，一般可设置为2N。</p><h3 id="线程池的类型有哪些？适用场景？"><a href="#线程池的类型有哪些？适用场景？" class="headerlink" title="线程池的类型有哪些？适用场景？"></a>线程池的类型有哪些？适用场景？</h3><p>常见的线程池有 <code>FixedThreadPool</code>、<code>SingleThreadExecutor</code>、<code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>。这几个都是 <code>ExecutorService</code> 线程池实例。</p><p><strong>FixedThreadPool</strong></p><p>固定线程数的线程池。任何时间点，最多只有 nThreads 个线程处于活动状态执行任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无界队列 LinkedBlockingQueue（队列容量为 Integer.MAX_VALUE），运行中的线程池不会拒绝任务，即不会调用RejectedExecutionHandler.rejectedExecution()方法。</p><p>maxThreadPoolSize 是无效参数，故将它的值设置为与 coreThreadPoolSize 一致。</p><p>keepAliveTime 也是无效参数，设置为0L，因为此线程池里所有线程都是核心线程，核心线程不会被回收（除非设置了executor.allowCoreThreadTimeOut(true)）。</p><p>适用场景：适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。需要注意的是，FixedThreadPool 不会拒绝任务，<strong>在任务比较多的时候会导致 OOM。</strong></p><p><strong>SingleThreadExecutor</strong></p><p>只有一个线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutionService newSingleThreadExecutor() &#123;</span><br><span class="line">return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无界队列 LinkedBlockingQueue。线程池只有一个运行的线程，新来的任务放入工作队列，线程处理完任务就循环从队列里获取任务执行。保证顺序的执行各个任务。</p><p>适用场景：适用于串行执行任务的场景，一个任务一个任务地执行。<strong>在任务比较多的时候也是会导致 OOM。</strong></p><p><strong>CachedThreadPool</strong></p><p>根据需要创建新线程的线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主线程提交任务的速度高于线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><p>使用没有容量的SynchronousQueue作为线程池工作队列，当线程池有空闲线程时，<code>SynchronousQueue.offer(Runnable task)</code>提交的任务会被空闲线程处理，否则会创建新的线程处理任务。</p><p>适用场景：用于并发执行大量短期的小任务。<code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，<strong>可能会创建大量线程，从而导致 OOM。</strong></p><p><strong>ScheduledThreadPoolExecutor</strong></p><p>在给定的延迟后运行任务，或者定期执行任务。在实际项目中基本不会被用到，因为有其他方案选择比如<code>quartz</code>。</p><p>使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，时间早的任务先被执行(即<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果time相同则先提交的任务会被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p><p>执行周期任务步骤：</p><ol><li>线程从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>执行这个 <code>ScheduledFutureTask</code>；</li><li>修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><p><img src="https://s2.loli.net/2022/03/16/mzgWtji1vUyD8k7.png"></p><p>适用场景：周期性执行任务的场景，需要限制线程数量的场景。</p><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><h3 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="headerlink" title="synchronized的用法有哪些?"></a>synchronized的用法有哪些?</h3><ol><li><strong>修饰普通方法</strong>：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法</strong>：作用于当前类，进入同步代码前要获得当前类对象的锁，synchronized关键字加到static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</li><li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ol><h3 id="synchronized的作用有哪些？"><a href="#synchronized的作用有哪些？" class="headerlink" title="synchronized的作用有哪些？"></a>synchronized的作用有哪些？</h3><p><strong>原子性</strong>：确保线程互斥的访问同步代码；</p><p><strong>可见性</strong>：保证共享变量的修改能够及时可见；</p><p><strong>有序性</strong>：有效解决重排序问题。</p><h3 id="synchronized底层实现原理？"><a href="#synchronized底层实现原理？" class="headerlink" title="synchronized底层实现原理？"></a>synchronized底层实现原理？</h3><p>synchronized 同步代码块的实现是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <code>monitor</code>的持有权（monitor对象存在于每个Java对象的对象头中， synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）。</p><p>其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 <code>monitorexit</code> 指令后，将锁计数器设为0 ，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</p><p>synchronized 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><ol><li>使用synchronized关键字实现同步，线程执行完同步代码块会<strong>自动释放锁</strong>，而ReentrantLock需要手动释放锁。</li><li>synchronized是<strong>非公平锁</strong>，ReentrantLock可以设置为公平锁。</li><li>ReentrantLock上等待获取锁的线程是<strong>可中断的</strong>，线程可以放弃等待锁。而synchonized会无限期等待下去。</li><li>ReentrantLock <strong>可以设置超时获取锁</strong>。在指定的截止时间之前获取锁，如果截止时间到了还没有获取到锁，则返回。</li><li>ReentrantLock 的 tryLock() 方法<strong>可以尝试非阻塞的获取锁</strong>，调用该方法后立刻返回，如果能够获取则返回true，否则返回false。</li></ol><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p><code>volatile</code>是轻量级的同步机制，<code>volatile</code>保证变量对所有线程的可见性，不保证原子性。</p><ol><li>当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条<code>LOCK</code>前缀的指令，将该变量所在缓存行的数据写回系统内存。</li><li>由于缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。</li></ol><blockquote><p>来看看缓存一致性协议是什么。</p><p><strong>缓存一致性协议</strong>：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，就会从内存重新读取。</p></blockquote><p><code>volatile</code>关键字的两个作用：</p><ol><li>保证了不同线程对共享变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行<strong>指令重排序</strong>。</li></ol><blockquote><p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。Java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止处理器重排序。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。对一个volatile字段进行写操作，Java内存模型将在写操作后插入一个写屏障指令，这个指令会把之前的写入值都刷新到内存。</p></blockquote><h3 id="volatile和synchronized的区别是什么？"><a href="#volatile和synchronized的区别是什么？" class="headerlink" title="volatile和synchronized的区别是什么？"></a>volatile和synchronized的区别是什么？</h3><ol><li><code>volatile</code>只能使用在变量上；而<code>synchronized</code>可以在类，变量，方法和代码块上。</li><li><code>volatile</code>至保证可见性；<code>synchronized</code>保证原子性与可见性。</li><li><code>volatile</code>禁用指令重排序；<code>synchronized</code>不会。</li><li><code>volatile</code>不会造成阻塞；<code>synchronized</code>会。</li></ol><h3 id="ReentrantLock-是如何实现可重入性的"><a href="#ReentrantLock-是如何实现可重入性的" class="headerlink" title="ReentrantLock 是如何实现可重入性的?"></a>ReentrantLock 是如何实现可重入性的?</h3><p><code>ReentrantLock</code>内部自定义了同步器sync，在加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，检查当前维护的那个线程ID和当前请求的线程ID是否 一致，如果一致，同步状态加1，表示锁被当前线程获取了多次。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>线程本地变量。当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。</p><img src="https://s2.loli.net/2022/03/16/RjYXxNMvWeC6VEp.jpg" style="zoom:67%;" /><p>调用<code>threadLocal.set()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.set(this, value)</code>，this是<code>threadLocal</code>本身。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>get()</code>–&gt;调用<code>getMap(Thread)</code>–&gt;返回当前线程的<code>ThreadLocalMap&lt;ThreadLocal, value&gt;</code>–&gt;<code>map.getEntry(this)</code>，返回<code>value</code>。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threadLocals</code>的类型<code>ThreadLocalMap</code>的键为<code>ThreadLocal</code>对象，因为每个线程中可有多个<code>threadLocal</code>变量，如<code>longLocal</code>和<code>stringLocal</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span> &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">threadLocalDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        threadLocalDemo.set();</span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocalDemo.set();</span><br><span class="line">            System.out.println(threadLocalDemo.get());</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadLocalDemo.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>并不是用来解决共享资源的多线程访问问题，因为每个线程中的资源只是副本，不会共享。因此<code>ThreadLocal</code>适合作为线程上下文变量，简化线程内传参。</p><h3 id="ThreadLocal内存泄漏的原因？"><a href="#ThreadLocal内存泄漏的原因？" class="headerlink" title="ThreadLocal内存泄漏的原因？"></a>ThreadLocal内存泄漏的原因？</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal使用场景有哪些？"><a href="#ThreadLocal使用场景有哪些？" class="headerlink" title="ThreadLocal使用场景有哪些？"></a>ThreadLocal使用场景有哪些？</h3><p><code>ThreadLocal</code>适用场景：每个线程需要有自己单独的实例，且需要在多个方法中共享实例，即同时满足实例在线程间的隔离与方法间的共享，这种情况适合使用<code>ThreadLocal</code>。比如Java web应用中，每个线程有自己单独的<code>Session</code>实例，就可以使用<code>ThreadLocal</code>来实现。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h3><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><img src="https://s2.loli.net/2022/03/16/p3sQZ1Biv2bTndJ.png"></p><p>AQS使用一个<code>volatile</code>的int类型的成员变量<code>state</code>来表示同步状态，通过CAS修改同步状态的值。当线程调用 lock 方法时 ，如果 <code>state</code>&#x3D;0，说明没有任何线程占有共享资源的锁，可以获得锁并将 <code>state</code>加1。如果 <code>state</code>不为0，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;//共享变量，使用volatile修饰保证线程可见性</span><br></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如<code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>按照<strong>线程访问顺序</strong>获取对象锁。<code>synchronized</code>是非公平锁，<code>Lock</code>默认是非公平锁，可以设置为公平锁，公平锁会影响性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享式与独占式锁"><a href="#共享式与独占式锁" class="headerlink" title="共享式与独占式锁"></a>共享式与独占式锁</h3><p>共享式与独占式的最主要<strong>区别</strong>在于：同一时刻独占式只能有<strong>一个线程</strong>获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>悲观锁，<strong>每次访问资源都会加锁</strong>，执行完同步代码释放锁，<code>synchronized</code>和<code>ReentrantLock</code>属于悲观锁。</p><p>乐观锁，不会锁定资源，所有的线程都能访问并修改同一个资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。乐观锁最常见的实现就是<code>CAS</code>。</p><p>适用场景：</p><ul><li>悲观锁适合<strong>写操作多</strong>的场景。</li><li>乐观锁适合<strong>读操作多</strong>的场景，不加锁可以提升读操作的性能。</li></ul><h3 id="乐观锁有什么问题"><a href="#乐观锁有什么问题" class="headerlink" title="乐观锁有什么问题?"></a>乐观锁有什么问题?</h3><p>乐观锁避免了悲观锁独占对象的问题，提高了并发性能，但它也有缺点:</p><ul><li>乐观锁只能保证<strong>一个共享变量</strong>的原子操作。</li><li>长时间自旋可能导致<strong>开销大</strong>。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。</li><li><strong>ABA问题</strong>。CAS的原理是通过比对内存值与预期值是否一样而判断内存值是否被改过，但是会有以下问题：假如内存值原来是A， 后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变。可以引入版本号解决这个问题，每次变量更新都把版本号加一。</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><p>CAS全称<code>Compare And Swap</code>，比较与交换，是乐观锁的主要实现方式。CAS在不使用锁的情况下实现多线程之间的变量同步。<code>ReentrantLock</code>内部的AQS和原子类内部都使用了CAS。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值V。</li><li>进行比较的值A。</li><li>要写入的新值B。</li></ul><p>只有当V的值等于A时，才会使用原子方式用新值B来更新V的值，否则会继续重试直到成功更新值。</p><p>以<code>AtomicInteger</code>为例，<code>AtomicInteger</code>的<code>getAndIncrement()</code>方法底层就是CAS实现，关键代码是 <code>compareAndSwapInt(obj, offset, expect, update)</code>，其含义就是，如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果不相等，那就会继续重试直到成功更新值。</p><h3 id="CAS存在的问题？"><a href="#CAS存在的问题？" class="headerlink" title="CAS存在的问题？"></a>CAS存在的问题？</h3><ol><li><p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从<code>A－B－A</code>变成了<code>1A－2B－3A</code>。</p><p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。</p></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>CountDownLatch</code> 的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier(同步屏障)，用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数parties指让多少个线程或者任务等待至某个状态；参数barrierAction为当这些线程都达到某个状态时会执行的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">        cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h3><p>CyclicBarrier 和 CountDownLatch 都能够实现线程之间的等待。</p><p>CountDownLatch用于某个线程等待其他线程<strong>执行完任务</strong>再执行。CyclicBarrier用于一组线程互相等待到某个状态，然后这组线程再<strong>同时</strong>执行。 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可用于处理更为复杂的业务场景。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore类似于锁，它用于控制同时访问特定资源的线程数量，控制并发线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Worker</span>(s, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Semaphore s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.acquire();</span><br><span class="line">            System.out.println(<span class="string">&quot;worker&quot;</span> + num +  <span class="string">&quot; using the machine&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;worker&quot;</span> + num +  <span class="string">&quot; finished the task&quot;</span>);</span><br><span class="line">            s.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>AtomicInteger 类常用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) 保证原子操作，从而避免加锁的高开销。</p><h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>AtomicIntegerArray 类常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：带有版本号的引用类型原子类。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li></ul><p>参考文章：</p><p>[1] <a href="https://snailclimb.gitee.io/javaguide/#/?id=%E5%B9%B6%E5%8F%91">JavaGuide (gitee.io)</a></p><p>[2] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/post/72389457.html"/>
      <url>/post/72389457.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见的Java集合"><a href="#常见的Java集合" class="headerlink" title="常见的Java集合"></a>常见的Java集合</h2><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src="https://s2.loli.net/2022/03/15/DKvo3mzbB2ljd14.png"></p><h2 id="List-Set-Queue-Map-四者的区别？"><a href="#List-Set-Queue-Map-四者的区别？" class="headerlink" title="List, Set, Queue, Map 四者的区别？"></a>List, Set, Queue, Map 四者的区别？</h2><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-的扩容机制？"><a href="#ArrayList-的扩容机制？" class="headerlink" title="ArrayList 的扩容机制？"></a>ArrayList 的扩容机制？</h3><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍</strong>。以JDK1.8为例说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将e添加到数组末尾</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次在新增一个元素时，需要判断这个list的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 容量不足则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//检查容量是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="怎么在遍历-ArrayList-时移除一个元素？"><a href="#怎么在遍历-ArrayList-时移除一个元素？" class="headerlink" title="怎么在遍历 ArrayList 时移除一个元素？"></a>怎么在遍历 ArrayList 时移除一个元素？</h3><p>foreach删除会导致快速失败问题，可以使用迭代器的 remove() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">itr</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(itr.next().equals(<span class="string">&quot;jay&quot;</span>) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h3><ul><li><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</p></li><li><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</p></li><li><p><code>ArrayList</code>在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</p></li><li><p><code>Vector</code>属于线程安全级别的，但是大多数情况下不使用Vector，因为操作Vector效率比较低。</p></li></ul><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h3><ol><li>ArrayList基于动态数组实现；LinkedList基于链表实现。 </li><li>对于随机index访问的get和set方法，ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。 </li><li>新增和删除元素，LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</li><li>ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全</strong>的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>HashMap 使用数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的， 链表长度大于8（TREEIFY_THRESHOLD）时，会把链表转换为红黑树，红黑树节点个数小于6（UNTREEIFY_THRESHOLD）时才转化为链表，防止频繁的转化。</p><h3 id="解决hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决hash冲突的办法有哪些？HashMap用的哪种？"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h3><p>解决Hash冲突方法有:开放定址法、再哈希法、链地址法。HashMap中采用的是 链地址法 。</p><ul><li>开放定址法基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code> </li><li>再哈希法提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。 </li><li>链地址法将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li></ul><h3 id="HashMap扩容过程？"><a href="#HashMap扩容过程？" class="headerlink" title="HashMap扩容过程？"></a>HashMap扩容过程？</h3><p>1.8扩容机制：当元素个数大于threshold时，会进行扩容，使用2倍容量的数组代替原有数组。采用尾插入的方式将原数组元素拷贝到新数组。1.8扩容之后链表元素相对位置没有变化，而1.7扩容之后链表元素会倒置。</p><p>1.7链表新节点采用的是头插法，这样在线程一扩容迁移元素时，会将元素顺序改变，导致两个线程中出现元素的相互指向而形成循环链表，1.8采用了尾插法，避免了这种情况的发生。</p><p>原数组的元素在重新计算hash之后，因为数组容量n变为2倍，那么n-1的mask范围在高位多1bit。在元素拷贝过程不需要重新计算元素在数组中的位置，只需要看看原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成“原索引+oldCap”（根据<code>e.hash &amp; (oldCap - 1) == 0</code>判断） 。这样可以省去重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程会均匀的把之前的冲突的节点分散到新的bucket。</p><h3 id="红黑树的特点？"><a href="#红黑树的特点？" class="headerlink" title="红黑树的特点？"></a>红黑树的特点？</h3><ul><li>每个节点或者是黑色，或者是红色。 </li><li>根节点是黑色。 </li><li>每个叶子节点（NIL）是黑色。 </li><li>如果一个节点是红色的，则它的子节点必须是黑色的。 </li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><h3 id="为什么使用红黑树而不使用AVL树？"><a href="#为什么使用红黑树而不使用AVL树？" class="headerlink" title="为什么使用红黑树而不使用AVL树？"></a>为什么使用红黑树而不使用AVL树？</h3><p>ConcurrentHashMap 在put的时候会加锁，使用红黑树插入速度更快，可以减少等待锁释放的时间。红黑树是对AVL树的优化，只要求部分平衡，用非严格的平衡来换取增删节点时候旋转次数的降低，提高了插入和删除的性能。</p><h3 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h3><p>一般用<code>Integer</code>、<code>String</code>这种不可变类当 HashMap 当 key。String类比较常用。</p><ul><li>因为 String 是不可变的，所以在它创建的时候<code>hashcode</code>就被缓存了，不需要重新计算。这就是 HashMap 中的key经常使用字符串的原因。</li><li>获取对象的时候要用到 <code>equals()</code> 和 <code>hashCode()</code> 方法，而Integer、String这些类都已经重写了 <code>hashCode()</code> 以及 <code>equals()</code> 方法，不需要自己去重写这两个方法。</li></ul><h3 id="HashMap为什么线程不安全？"><a href="#HashMap为什么线程不安全？" class="headerlink" title="HashMap为什么线程不安全？"></a>HashMap为什么线程不安全？</h3><ul><li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。</li><li>在JDK1.8中，在多线程环境下，会发生<strong>数据覆盖</strong>的情况。</li></ul><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th align="center"><code>HashMap</code></th><th align="center"><code>HashSet</code></th></tr></thead><tbody><tr><td align="center">实现了 <code>Map</code> 接口</td><td align="center">实现 <code>Set</code> 接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向 map 中添加元素</td><td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="https://s2.loli.net/2022/03/16/E1JwO3sNZro9nSq.png"></p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力，默认是按 key 的升序排序。</p><h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>Hashtable:</strong></p><p><img src="https://s2.loli.net/2022/03/16/LMvRnZb1rfTPW4h.png"></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><p><img src="https://s2.loli.net/2022/03/16/HZCjMynR63smVtN.png"></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><p><img src="https://s2.loli.net/2022/03/16/XfJDszeat9L7kqw.png"></p><h3 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h3><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）;</li><li>Streams API 遍历（JDK 1.8+）。</li></ol><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol><h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h2 id="什么是fail-fast？"><a href="#什么是fail-fast？" class="headerlink" title="什么是fail fast？"></a>什么是fail fast？</h2><p>fast-fail是Java集合的一种错误机制。当多个线程对同一个集合进行操作时，就有可能会产生fast-fail事件。例如：当线程a正通过iterator遍历集合时，另一个线程b修改了集合的内容，此时modCount（记录集合操作过程的修改次数）会加1，不等于expectedModCount，那么线程a访问集合的时候，就会抛出ConcurrentModificationException，产生fast-fail事件。边遍历边修改集合也会产生fast-fail事件。</p><p>解决方法：</p><ul><li>使用Colletions.synchronizedList方法或在修改集合内容的地方加上synchronized。这样的话，增删集合内容的同步锁会阻塞遍历操作，影响性能。</li><li>使用CopyOnWriteArrayList来替换ArrayList。在对CopyOnWriteArrayList进行修改操作的时候，会拷贝一个新的数组，对新的数组进行操作，操作完成后再把引用移到新的数组。</li></ul><h2 id="什么是fail-safe？"><a href="#什么是fail-safe？" class="headerlink" title="什么是fail safe？"></a>什么是fail safe？</h2><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><p><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p><strong>缺点</strong>：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h2 id="哪些集合类是线程安全的？哪些不安全？"><a href="#哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="哪些集合类是线程安全的？哪些不安全？"></a>哪些集合类是线程安全的？哪些不安全？</h2><p>线性安全的集合类：</p><ul><li>Vector：比ArrayList多了同步机制。</li><li>Hashtable。</li><li>ConcurrentHashMap：是一种高效并且线程安全的集合。</li><li>Stack：栈，也是线程安全的，继承于Vector。</li></ul><p>线性不安全的集合类：</p><ul><li>Hashmap</li><li>Arraylist</li><li>LinkedList</li><li>HashSet</li><li>TreeSet</li><li>TreeMap</li></ul><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap:</strong> 线程安全的 HashMap</li><li><strong>CopyOnWriteArrayList:</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li><li><strong>ConcurrentLinkedQueue:</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li><strong>BlockingQueue:</strong> 阻塞队列接口，JDK 内部通过链表、数组等方式实现了这个接口。非常适合用于作为数据共享的通道。</li><li><strong>ConcurrentSkipListMap:</strong> 跳表的实现。使用跳表的数据结构进行快速查找。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>多线程环境下，使用Hashmap进行put操作会引起死循环，应该使用支持多线程的 ConcurrentHashMap。</p><p>JDK1.8 ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构采用数组+链表&#x2F;红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，相比1.7锁定HashEntry数组，锁粒度更小，支持更高的并发量。当链表长度过长时，Node会转换成TreeNode，提高查找速度。</p><h4 id="put执行流程？"><a href="#put执行流程？" class="headerlink" title="put执行流程？"></a>put执行流程？</h4><p>在put的时候需要锁住Segment，保证并发安全。调用get的时候不加锁，因为node数组成员val和指针next是用volatile修饰的，更改后的值会立刻刷新到主存中，保证了可见性，node数组table也用volatile修饰，保证在运行过程对其他线程具有可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 操作流程：</p><ol><li>如果table没有初始化就先进行初始化过程</li><li>使用hash算法计算key的位置</li><li>如果这个位置为空则直接CAS插入，如果不为空的话，则取出这个节点来</li><li>如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</li><li>如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作，这里有两种情况，一种是链表形式就直接遍历到尾端插入或者覆盖掉相同的key，一种是红黑树就按照红黑树结构插入</li><li>链表的数量大于阈值8，就会转换成红黑树的结构或者进行扩容（table长度小于64）</li><li>添加成功后会检查是否需要扩容</li></ol><h4 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h4><p>数组扩容transfer方法中会设置一个步长，表示一个线程处理的数组长度，最小值是16。在一个步长范围内只有一个线程会对其进行复制移动操作。</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>写时复制。当我们往容器添加元素时，不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。这样做的好处就是可以对<code>CopyOnWrite</code>容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); //add方法需要加锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1); //复制新数组</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements); //原容器的引用指向新容器</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。</p><p><code>CopyOnWriteArrayList</code>中add方法添加的时候是需要加锁的，保证同步，避免了多线程写的时候复制出多个副本。读的时候不需要加锁，如果读的时候有其他线程正在向<code>CopyOnWriteArrayList</code>添加数据，还是可以读到旧的数据。</p><p><strong>缺点：</strong></p><ul><li>内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。</li><li>CopyOnWrite容器不能保证数据的实时一致性，可能读取到旧数据。</li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>非阻塞队列。高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，通过 CAS 操作实现。</p><p>如果对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代。适合在对性能要求相对较高，同时有多个线程对队列进行读写的场景。</p><p><strong>非阻塞队列中的几种主要方法：</strong> <code>add(E e)</code>: 将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常； <code>remove()</code>：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常； <code>offer(E e)</code>：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false； <code>poll()</code>：移除并获取队首元素，若成功，则返回队首元素；否则返回null； <code>peek()</code>：获取队首元素，若成功，则返回队首元素；否则返回null</p><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是<code>java.util.concurrent</code>包下重要的数据结构，<code>BlockingQueue</code>提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于<code>BlockingQueue</code>实现的。<code>BlockingQueue</code> 适合用于作为数据共享的通道。</p><p>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</p><p>阻塞队列和一般的队列的区别就在于：</p><ol><li>多线程支持，多个线程可以安全的访问队列</li><li>阻塞操作，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满</li></ol><p><strong>方法</strong></p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><p><strong>原理</strong></p><p>JDK使用通知模式实现阻塞队列。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><p>ArrayBlockingQueue使用Condition来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 队列为空时，阻塞当前消费者</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     notEmpty.signal(); <span class="comment">// 队列不为空时，通知消费者获取元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/843288">https://www.nowcoder.com/discuss/843288</a></p><p>[2] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[3] <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/java-collection-questions-02">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/post/1365080245.html"/>
      <url>/post/1365080245.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>JVM内存结构分为5大区域，<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>堆</strong>、<strong>方法区</strong>。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>局部变量表是用于存放方法参数和方法内的局部变量。</p><p>每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，在方法调用过程中，会进行动态链接，将这个符号引用转化为直接引用。</p><ul><li>部分符号引用在类加载阶段的时候就转化为直接引用，这种转化就是静态链接 </li><li>部分符号引用在运行期间转化为直接引用，这种转化就是动态链接</li></ul><p>Java 虚拟机栈也是线程<strong>私有</strong>的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><p>可以通过<code>-Xss</code>参数来指定每个线程的虚拟机栈内存大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M</span><br></pre></td></tr></table></figure><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆用于存放对象实例，是垃圾收集器管理的主要区域，因此也被称作<code>GC</code>堆。堆可以细分为：新生代（<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间）和老年代。</p><p>通过 <code>-Xms</code>设定程序启动时占用内存大小，通过<code>-Xmx</code>设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出<code>OutOfMemory</code>异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>对方法区进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>。</p><p><strong>永久代</strong></p><p>方法区是 JVM 的规范，而永久代<code>PermGen</code>是方法区的一种实现方式，并且只有 <code>HotSpot</code> 有永久代。对于其他类型的虚拟机，如<code>JRockit</code>没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的场景比较容易出现永久代的内存溢出。</p><p><strong>元空间</strong></p><p>JDK 1.8 的时候，<code>HotSpot</code>的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。</p><p>为什么要将永久代替换为元空间呢?</p><p>永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>NIO的Buffer提供了DirectBuffer，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。</p><p>直接内存的读写操作比堆内存快，可以提升程序I&#x2F;O操作的性能。通常在I&#x2F;O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。</p><h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><ul><li>堆的<strong>物理地址分配</strong>是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</li><li>堆存放的是<strong>对象的实例和数组</strong>；栈存放的是<strong>局部变量，操作数栈，返回结果</strong>等。</li><li>堆是<strong>线程共享</strong>的；栈是<strong>线程私有</strong>的。</li></ul><h3 id="什么情况下会发生栈溢出？"><a href="#什么情况下会发生栈溢出？" class="headerlink" title="什么情况下会发生栈溢出？"></a>什么情况下会发生栈溢出？</h3><ul><li>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出<code>StackOverFlowError</code>异常。这种情况通常是因为方法递归没终止条件。 </li><li>新建线程的时候没有足够的内存去创建对应的虚拟机栈，虚拟机会抛出<code>OutOfMemoryError</code>异常。比如线程启动过多就会出现这种情况。</li></ul><h2 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="https://s2.loli.net/2022/03/14/LPsfMauw3Q6dAkm.png"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池中定位</strong>到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://s2.loli.net/2022/03/14/xioUgrwnPjV1sz5.png"></p><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p><h4 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h4><p>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><img src="https://s2.loli.net/2022/03/14/FoHXNka4wS7upbU.png" style="zoom: 50%;" /><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><img src="https://s2.loli.net/2022/03/14/cgGJynRxq9o7fC5.png" style="zoom:50%;" /><p>总结：使用句柄最大的好处就是reference中存储的是稳定句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="GC是什么？为什么要GC？"><a href="#GC是什么？为什么要GC？" class="headerlink" title="GC是什么？为什么要GC？"></a>GC是什么？为什么要GC？</h3><p>GC（<code>Garbage Collection</code>），垃圾回收，是Java与C++的主要区别之一。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清理机制。对JVM中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><h3 id="Minor-GC-和-Full-GC的区别？"><a href="#Minor-GC-和-Full-GC的区别？" class="headerlink" title="Minor GC 和 Full GC的区别？"></a>Minor GC 和 Full GC的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code>会频繁执行，执行的速度一般也会比较快。</li><li><strong>Full GC</strong>：回收老年代和新生代，老年代的对象存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</li></ul><h3 id="Full-GC-的触发条件？"><a href="#Full-GC-的触发条件？" class="headerlink" title="Full GC 的触发条件？"></a>Full GC 的触发条件？</h3><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p><p><strong>调用 System.gc()</strong></p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p><strong>老年代空间不足</strong></p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p><strong>空间分配担保失败</strong></p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><p><strong>JDK 1.7 及以前的永久代空间不足</strong></p><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code></p><h3 id="内存的分配策略"><a href="#内存的分配策略" class="headerlink" title="内存的分配策略"></a>内存的分配策略</h3><p><strong>对象优先在 Eden 分配</strong></p><p>大多数情况下，对象在新生代 <code>Eden</code> 上分配，当 <code>Eden</code> 空间不够时，触发 <code>Minor GC</code>。</p><p><strong>大对象直接进入老年代</strong></p><p>大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 <code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配。</p><p><strong>长期存活的对象进入老年代</strong></p><p>通过参数 <code>-XX:MaxTenuringThreshold</code> 可以设置对象进入老年代的年龄阈值。对象在<code>Survivor</code>区每经过一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p><p><strong>动态对象年龄判定</strong></p><p>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 <code>MaxTenuringThreshold</code> 年龄阈值。</p><p><strong>空间分配担保</strong></p><p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值为不允许担保失败，那么就要进行一次 <code>Full GC</code>。</p><h3 id="如何判断对象死亡？"><a href="#如何判断对象死亡？" class="headerlink" title="如何判断对象死亡？"></a>如何判断对象死亡？</h3><p>对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：<strong>引用计数法</strong>和<strong>可达性分析</strong>。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p>这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，<code>obj1</code> 和 <code>obj2</code> 互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line"><span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">obj1.instance = obj2;</span><br><span class="line">obj2.instance = obj1;</span><br><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>通过<code>GC Root</code>对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到<code>GC Root</code>没有任何的引用链相连时，说明这个对象是不可用的。</p><p><img src="https://s2.loli.net/2022/03/14/PZqXl1I6BF9EQjW.png"></p><p>可作为 <strong>GC Roots 的对象</strong>包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类?"></a>如何判断一个类是无用的类?</h3><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>首先利用可达性去遍历内存，把存活对象和垃圾对象进行标记。标记结束后统一将所有标记的对象回收掉。这种垃圾回收算法效率较低，并且会<strong>产生大量不连续的空间碎片</strong>。</p><img src="https://s2.loli.net/2022/03/14/xQ8X3CecNltYKfA.png" style="zoom:80%;" /><h4 id="复制清除算法"><a href="#复制清除算法" class="headerlink" title="复制清除算法"></a>复制清除算法</h4><p>半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程仍然与<code>标记-清除</code>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><img src="https://s2.loli.net/2022/03/14/vzUFNKVo89pdxZO.png" style="zoom:80%;" /><h4 id="分类收集算法"><a href="#分类收集算法" class="headerlink" title="分类收集算法"></a>分类收集算法</h4><p>根据各个年代的特点采用最适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用复制算法</li><li>老年代使用标记清除算法或者标记整理算法</li></ul><p>在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记-清理或者标记-整理算法进行垃圾回收。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器主要分为以下几种：<code>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1</code>。</p><p>这7种垃圾收集器的特点：</p><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代&#x2F;老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU环境下的Client模式</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或B&#x2F;S系统服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>both</td><td>标记-整理+复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换CMS</td></tr></tbody></table><p><strong>Serial 收集器</strong></p><p><strong>单线程收集器</strong>，使用一个垃圾收集线程去进行垃圾回收，在进行垃圾回收的时候必须暂停其他所有的工作线程（ <code>Stop The World</code> ），直到它收集结束。</p><p>特点：简单高效；内存消耗小；没有线程交互的开销，单线程收集效率高；需暂停所有的工作线程，用户体验不好。</p><p><strong>ParNew 收集器</strong></p><p><code>Serial</code>收集器的<strong>多线程版本</strong>，除了使用多线程进行垃圾收集外，其他行为、参数与 <code>Serial</code> 收集器基本一致。</p><p><strong>Parallel Scavenge 收集器</strong></p><p><strong>新生代收集器</strong>，基于<strong>复制清除算法</strong>实现的收集器。特点是<strong>吞吐量优先</strong>，能够并行收集的多线程收集器，允许多个垃圾回收线程同时运行，降低垃圾收集时间，提高吞吐量。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值（<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>）。<code>Parallel Scavenge</code> 收集器关注点是<strong>吞吐量，高效率的利用 CPU 资源</strong>。<code>CMS</code> 垃圾收集器关注点更多的是<strong>用户线程的停顿时间</strong>。</p><p><code>Parallel Scavenge</code>收集器提供了两个参数用于<strong>精确控制吞吐量</strong>，分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX：GCTimeRatio</code>参数。</p><ul><li><code>-XX：MaxGCPauseMillis</code>参数的值是一个大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过用户设定值。</li><li><code>-XX：GCTimeRatio</code>参数的值大于0小于100，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</li></ul><p><strong>Serial Old 收集器</strong></p><p><code>Serial</code> 收集器的老年代版本，单线程收集器，使用<strong>标记整理算法</strong>。</p><p><strong>Parallel Old 收集器</strong></p><p><code>Parallel Scavenge</code> 收集器的老年代版本。多线程垃圾收集，使用<strong>标记整理算法</strong>。</p><p><strong>CMS 收集器</strong></p><p><code>Concurrent Mark Sweep</code> ，并发标记清除，追求获取<strong>最短停顿时间</strong>，实现了让<strong>垃圾收集线程与用户线程基本上同时工作</strong>。</p><p><code>CMS</code> 垃圾回收基于<strong>标记清除算法</strong>实现，整个过程分为四个步骤：</p><ul><li>初始标记： 暂停所有用户线程（<code>Stop The World</code>），记录直接与 <code>GC Roots</code> 直接相连的对象 。</li><li>并发标记：从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程。</li><li>重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。</li><li>并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。</li></ul><p>在整个过程中，耗时最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程都可以与用户线程一起工作，所以从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</p><p><strong>优点</strong>：并发收集，停顿时间短。</p><p><strong>缺点</strong>：</p><ul><li>标记清除算法导致收集结束有<strong>大量空间碎片</strong>。</li><li><strong>产生浮动垃圾</strong>，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在标记过程之后，<code>CMS</code>无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；</li></ul><p><strong>G1收集器</strong></p><p>G1垃圾收集器的目标是在不同应用场景中<strong>追求高吞吐量和低停顿之间的最佳平衡</strong>。</p><p>G1将整个堆分成相同大小的分区（<code>Region</code>），有四种不同类型的分区：<code>Eden、Survivor、Old和Humongous</code>。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定。<code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。</p><h4 id="CMS收集器和G1收集器的区别？"><a href="#CMS收集器和G1收集器的区别？" class="headerlink" title="CMS收集器和G1收集器的区别？"></a>CMS收集器和G1收集器的区别？</h4><p><strong>使用范围不一样</strong></p><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 </li><li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li></ul><p><strong>STW的时间</strong></p><ul><li>CMS收集器以最小的停顿时间为目标的收集器。 </li><li>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</li></ul><p><strong>垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 </li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><p><strong>垃圾回收过程不一样</strong></p><h2 id="类相关知识"><a href="#类相关知识" class="headerlink" title="类相关知识"></a>类相关知识</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>Class 文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//类文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//类的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类的索引</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数如下：</p><p><strong>魔数</strong>：<code>class</code>文件标志。</p><p><strong>文件版本</strong>：高版本的 Java 虚拟机可以执行低版本编译器生成的类文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的类文件。</p><p><strong>常量池</strong>：存放字面量和符号引用。字面量类似于 Java 的常量，如字符串，声明为<code>final</code>的常量值等。符号引用包含三类：类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。</p><p><strong>访问标志</strong>：识别类或者接口的访问信息，比如这个<code>Class</code>是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型等等。</p><p><strong>当前类的索引</strong>：类索引用于确定这个类的全限定名。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>一个类的完整生命周期如下：</p><p><img src="https://s2.loli.net/2022/03/14/dBRNrygsQpSk65P.png"></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><strong>加载</strong></p><ol><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区类信息的访问入口</li></ol><p><strong>验证</strong></p><p>确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p><strong>准备</strong></p><p>为类变量分配内存并设置类变量初始值的阶段。</p><p><strong>解析</strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p><p><strong>初始化</strong></p><p>开始执行类中定义的<code>Java</code>代码，初始化阶段是调用类构造器的过程。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ul><li><strong>启动类加载器</strong>：用来加载 Java 核心类库，无法被 Java 程序直接引用。</li><li><strong>扩展类加载器</strong>：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>：它根据应用的类路径来加载 Java 类。可通过<code>ClassLoader.getSystemClassLoader()</code>获取它。</li><li><strong>自定义类加载器</strong>：通过继承<code>java.lang.ClassLoader</code>类的方式实现。</li></ul><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求<strong>委派</strong>给父类加载器去完成，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p><img src="https://s2.loli.net/2022/03/14/Op9Yfw56ankmB3o.png"></p><h4 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h4><p>双亲委派模型的好处：可以防止内存中出现多份同样的字节码。如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个<code>java.lang.Object</code>的同名类并放在<code>ClassPath</code>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的<code>Object</code>类，那么类之间的比较结果及类的唯一性将无法保证。</p><p>参考文章：</p><p>[1] <a href="https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md">https://github.com/Tyson0314/Java-learning/blob/master/Java/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p><p>[2] <a href="https://javaguide.cn/java/jvm">https://javaguide.cn/java/jvm</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/post/4159564061.html"/>
      <url>/post/4159564061.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p><strong>面向过程</strong>：</p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展。</li></ul><p><strong>面向对象</strong>：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li><li>缺点：性能比面向过程低。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>封装</strong></p><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 </p><p><strong>继承</strong></p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 </p><p><strong>多态性</strong></p><p>它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</p><ul><li>编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。 </li><li>运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-中的八种基本数据类型"><a href="#Java-中的八种基本数据类型" class="headerlink" title="Java 中的八种基本数据类型"></a>Java 中的八种基本数据类型</h3><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><h3 id="Java语言关键字有哪些？"><a href="#Java语言关键字有哪些？" class="headerlink" title="Java语言关键字有哪些？"></a>Java语言关键字有哪些？</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="final、finally、finalize的区别？"><a href="#final、finally、finalize的区别？" class="headerlink" title="final、finally、finalize的区别？"></a>final、finally、finalize的区别？</h3><p>final 用于修饰变量、方法和类。</p><ul><li>final 变量：被修饰的变量不可变，不可变分为<code>引用不可变</code>和<code>对象不可变</code>，final 指的是<code>引用不可变</code>，final 修饰的变量必须初始化，通常称被修饰的变量为<code>常量</code>。 </li><li>final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。 </li><li>final 类：被修饰的类不能被继承，所有方法不能被重写。</li></ul><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p><h3 id="访问修饰符public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 </li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong> </li><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法 </li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="对象相等的判断"><a href="#对象相等的判断" class="headerlink" title="对象相等的判断"></a>对象相等的判断</h2><h3 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p><strong>equals()</strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法</p><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 hashCode值必须是相等。也就是说如果 equals&#96;方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><p>如果重写 equals()时没有重写 hashCode()方法的话就可能会导致 equals方法判断是相等的两个对象，hashCode值却不相等。</p><h3 id="java-创建对象有哪几种方式？"><a href="#java-创建对象有哪几种方式？" class="headerlink" title="java 创建对象有哪几种方式？"></a>java 创建对象有哪几种方式？</h3><p>java中提供了以下四种创建对象的方式:</p><ul><li>new创建新对象 </li><li>通过反射机制 </li><li>采用clone机制 </li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><h3 id="String-StringBuffer-StringBuilder-的区别是什么？"><a href="#String-StringBuffer-StringBuilder-的区别是什么？" class="headerlink" title="String,StringBuffer, StringBuilder 的区别是什么？"></a>String,StringBuffer, StringBuilder 的区别是什么？</h3><p>1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。<strong>对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.</strong></p><p>String类利用了final修饰的char类型数组存储字符，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure><p>2.是否多线程安全。</p><p>String中的对象是不可变的，也就可以理解为常量，显然线程安全。</p><p>StringBuilder是非线程安全的。</p><p>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><p>1.便于实现字符串池（String pool）</p><p>在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p><p>2.使多线程安全</p><p>在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。</p><p>3.避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p><p>4.加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p><p>总体来说，String不可变的原因要包括<strong>设计考虑</strong>，<strong>效率优化</strong>，以及<strong>安全性</strong>这三大方面。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><blockquote><p>Java 为每个原始类型提供了包装类型：</p><p>原始类型: boolean，char，byte，short，int，long，float，double</p><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></blockquote><h3 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别?"></a>int 和 Integer 有什么区别?</h3><ul><li>Integer是int的包装类；int是基本数据类型； </li><li>Integer变量必须实例化后才能使用；int变量不需要； </li><li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； </li><li>Integer的默认值是null；int的默认值是0。</li></ul><h3 id="两个new生成的Integer变量的对比"><a href="#两个new生成的Integer变量的对比" class="headerlink" title="两个new生成的Integer变量的对比"></a>两个new生成的Integer变量的对比</h3><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Integer变量和int变量的对比"><a href="#Integer变量和int变量的对比" class="headerlink" title="Integer变量和int变量的对比"></a>Integer变量和int变量的对比</h3><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c=<span class="number">10000</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="非new生成的Integer变量和new-Integer-生成变量的对比"><a href="#非new生成的Integer变量和new-Integer-生成变量的对比" class="headerlink" title="非new生成的Integer变量和new Integer()生成变量的对比"></a>非new生成的Integer变量和new Integer()生成变量的对比</h3><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10000</span>);</span><br><span class="line">Integer c= <span class="number">10000</span>;</span><br><span class="line">System.out.println(b == c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="两个非new生成的Integer对象的对比"><a href="#两个非new生成的Integer对象的对比" class="headerlink" title="两个非new生成的Integer对象的对比"></a>两个非new生成的Integer对象的对比</h3><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ul><li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。</li></ul><h3 id="反射使用的步骤？"><a href="#反射使用的步骤？" class="headerlink" title="反射使用的步骤？"></a>反射使用的步骤？</h3><ol><li>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Java序列化与反序列化是什么？"><a href="#Java序列化与反序列化是什么？" class="headerlink" title="Java序列化与反序列化是什么？"></a>Java序列化与反序列化是什么？</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="为什么需要序列化与反序列化？"><a href="#为什么需要序列化与反序列化？" class="headerlink" title="为什么需要序列化与反序列化？"></a>为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ol><li><strong>对象序列化可以实现分布式对象。</strong></li></ol><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><p>​    2. <strong>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong> </p><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p><ol start="3"><li><strong>序列化可以将内存中的类写入文件或数据库中。</strong></li></ol><p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p><p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p><ol start="4"><li><strong>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ol><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><h3 id="序列化实现的方式有哪些？"><a href="#序列化实现的方式有哪些？" class="headerlink" title="序列化实现的方式有哪些？"></a>序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p>两种序列化的对比:</p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="什么是serialVersionUID？"><a href="#什么是serialVersionUID？" class="headerlink" title="什么是serialVersionUID？"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性</p><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h3><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。 </li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li></ul><h3 id="非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？"><a href="#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？" class="headerlink" title="非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？"></a>非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h3><p>非受检查异常：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：<code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等。</p><p>受检查异常：是Exception 中除 <code>RuntimeException</code> 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p><p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p><h3 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h3 id="Java常见异常有哪些？"><a href="#Java常见异常有哪些？" class="headerlink" title="Java常见异常有哪些？"></a>Java常见异常有哪些？</h3><ul><li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 </li><li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. </li><li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 </li><li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。 </li><li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 </li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 </li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。 </li><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 </li><li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 </li><li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 </li><li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 </li><li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 </li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 </li><li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 </li><li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="常用的通配符有哪些？"><a href="#常用的通配符有哪些？" class="headerlink" title="常用的通配符有哪些？"></a>常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的IO-流分为几种？"><a href="#Java的IO-流分为几种？" class="headerlink" title="Java的IO 流分为几种？"></a>Java的IO 流分为几种？</h3><ul><li>按照流的方向：输入流（inputStream）和输出流（outputStream）； </li><li>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）； </li><li>按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。</li></ul><h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><ul><li>读写的时候字节流是按字节读写，字符流按字符读写。 </li><li>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。 </li><li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 </li><li>只是读写文件，和文件内容无关时，一般选择字节流。</li></ul><h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。 </p><img src="https://s2.loli.net/2022/03/13/6YqGgnEKibOeA3W.png" style="zoom:67%;" /><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。 </p><img src="https://s2.loli.net/2022/03/13/BUk9fdSj63tl4OA.png" style="zoom:67%;" /><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</p><img src="https://s2.loli.net/2022/03/13/V76rpuQP2SXk81f.png" style="zoom:67%;" /><p>参考文章：</p><p>[1] <a href="https://www.nowcoder.com/discuss/853116">Java基础八股文连环80问_笔经面经_牛客网 (nowcoder.com)</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序连接阿里云实战</title>
      <link href="/post/1096404487.html"/>
      <url>/post/1096404487.html</url>
      
        <content type="html"><![CDATA[<p>本次实验有两个物联网设备接入阿里云物联网平台，具体的数据转发流程如下所示：</p><ul><li>温湿度传感器：设备上传数据→物联网平台接收→规则引擎转发→小程序接收到数据</li><li>台灯：小程序发送指令→物联网平台接收→规则引擎转发→台灯接收指令</li></ul><p>其中，规则引擎的作用是进行数据的转发，要进行设备之间的通信，并不是直接进行点对点的通信，而是进行中间平台的转发，下图基本上解释了这个过程。</p><p><img src="https://s2.loli.net/2022/03/17/SLKeIj9QJYhfRx1.png"></p><p>微信小程序进行温湿度传感器数值的接受与解析，同时具有上传控制台灯指令的功能，下面对小程序的开发进行详细介绍。</p><h3 id="创建工程并导入第三方库"><a href="#创建工程并导入第三方库" class="headerlink" title="创建工程并导入第三方库"></a>创建工程并导入第三方库</h3><p>如上述的入门小程序开发所示，创建示例工程；在此基础上添加第三方库，才能进行mqtt的数据转发。</p><ul><li>mqtt.js：<a href="https://unpkg.com/mqtt/dist/mqtt.min.js%EF%BC%8C%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%EF%BC%8C%E5%8F%B3%E9%94%AE%E5%8F%A6%E5%AD%98%E4%B8%BA%E5%8D%B3%E5%8F%AF">https://unpkg.com/mqtt/dist/mqtt.min.js，点击进入，右键另存为即可</a></li><li>hex_hmac_sha1.js：<a href="https://github.com/xihu-fm/aliyun-iot-client-sdk%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E5%B0%86%E5%AF%B9%E5%BA%94%E7%9A%84js%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%E5%8D%B3%E5%8F%AF">https://github.com/xihu-fm/aliyun-iot-client-sdk，下载完将对应的js文件提取出来即可</a></li></ul><p>然后将这两个放在工程目录里的utils下，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/gzqQGOST2bVuCmJ.png"></p><h3 id="WXML界面设计"><a href="#WXML界面设计" class="headerlink" title="WXML界面设计"></a>WXML界面设计</h3><p>本实例实现需要输入框用于输入用户三元组，文本信息的显示以及用户的操作（设备上线、设备下线、开灯、关灯），所以在index.json中添加本次实例构建所需要的组件依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-field&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/field/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-divider&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/divider/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-slider&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/slider/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/icon/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-row&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/row/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-col&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/col/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加三个输入框用于填写设备的三元组信息，其wxml代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-cell-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;productKey&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;productKey:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;deviceName&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;deviceName:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;deviceSecret&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">label</span>=<span class="string">&quot;deviceSecret:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-cell-group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其在小程序中显示效果如图下所示：</p><p><img src="https://s2.loli.net/2022/03/17/ITuQmFvHYtaEVk6.png"></p><p>添加Slider滑块用于显示当前的温湿度信息，同时设置disable防止误触修改获取到的信息，其wxml代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>湿度：<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-slider</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;shidu&#125;&#125;&quot;</span> <span class="attr">use-button-slot</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;custom-button&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;shidu&#125;&#125;%</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-slider</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>温度：<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-slider</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;wendu&#125;&#125;&quot;</span> <span class="attr">use-button-slot</span> <span class="attr">disabled</span> <span class="attr">bar-height</span>=<span class="string">&quot;4px&quot;</span> <span class="attr">active-color</span>=<span class="string">&quot;#ee0a24&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;custom-button&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;wendu&#125;&#125;°C</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-slider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>温度、湿度为0时无显示效果，所以将初始值设为50，其效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qPukUM62xdHSjLp.png"></p><p>接下来设置四个按钮，用于设备上线、设备下线、开灯、关灯；其wxml代码如下所示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;5&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;turn_on&quot;</span>&gt;</span>开灯<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;online&quot;</span>&gt;</span>设备上线<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line">&lt;van-buttontype=&quot;danger&quot; bind:click=&quot;offline&quot;&gt;设备下线<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;5&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;turn_off&quot;</span>&gt;</span>关灯<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其显示效果如图下所示：</p><p><img src="https://s2.loli.net/2022/03/17/a7LUwdOWkyP23t6.png"></p><h3 id="JS功能实现"><a href="#JS功能实现" class="headerlink" title="JS功能实现"></a>JS功能实现</h3><p>定义全局变量，导入工具类，设置设备三元组信息（将*替换为自己的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client;</span><br><span class="line"><span class="keyword">var</span> mqtt=<span class="built_in">require</span>(<span class="string">&#x27;../../utils/mqtt.min.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> crypto=<span class="built_in">require</span>(<span class="string">&#x27;../../utils/hex_hmac_sha1.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> deviceConfig=&#123;</span><br><span class="line"><span class="attr">productKey</span>:<span class="string">&quot;**********&quot;</span>,</span><br><span class="line"><span class="attr">deviceName</span>:<span class="string">&quot; **********&quot;</span>,</span><br><span class="line"><span class="attr">deviceSecret</span>:<span class="string">&quot;**********&quot;</span>,</span><br><span class="line"><span class="attr">regionId</span>:<span class="string">&quot; **********&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置data，用于与前端页面交互，共设置6个参数。“productKey”、“deviceName”、“deviceSecret”直接初始化定义为“deviceConfig”内的属性，也可以通过客户端输入修改；“wendu”、“shidu”两个个字段分别代表温度、湿度数值；其具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">productKey</span>:deviceConfig.<span class="property">productKey</span>,</span><br><span class="line"><span class="attr">deviceName</span>:deviceConfig.<span class="property">deviceName</span>,</span><br><span class="line"><span class="attr">deviceSecret</span>:deviceConfig.<span class="property">deviceSecret</span>,</span><br><span class="line"><span class="attr">wendu</span>:<span class="number">50</span>,</span><br><span class="line"><span class="attr">shidu</span>:<span class="number">50</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>对基本的参数定义后，实现mqtt协议的基础工具类：</p><p>IoT平台mqtt连接参数初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initMqttOptions</span>(<span class="params">deviceConfig</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> params=&#123;</span><br><span class="line"><span class="attr">productKey</span>:deviceConfig.<span class="property">productKey</span>,</span><br><span class="line"><span class="attr">deviceName</span>:deviceConfig.<span class="property">deviceName</span>,</span><br><span class="line"><span class="attr">timestamp</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">clientId</span>:<span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substr</span>(<span class="number">2</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CONNECT参数</span></span><br><span class="line"><span class="keyword">const</span> options=&#123;</span><br><span class="line"><span class="attr">keepalive</span>:<span class="number">60</span>,         <span class="comment">//60s</span></span><br><span class="line"><span class="attr">clean</span>:<span class="literal">true</span>,           <span class="comment">//cleanSession不保持持久会话</span></span><br><span class="line"><span class="attr">protocolVersion</span>:<span class="number">4</span>   <span class="comment">//MQTTv3.1.1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.生成clientId，username，password</span></span><br><span class="line">options.<span class="property">password</span>=<span class="variable language_">this</span>.<span class="title function_">signHmacSha1</span>(params, deviceConfig.<span class="property">deviceSecret</span>);</span><br><span class="line">options.<span class="property">clientId</span>=<span class="string">`<span class="subst">$&#123;params.clientId&#125;</span>|securemode=2,signmethod=hmacsha1,timestamp=<span class="subst">$&#123;params.timestamp&#125;</span>|`</span>;</span><br><span class="line">options.<span class="property">username</span>=<span class="string">`<span class="subst">$&#123;params.deviceName&#125;</span>&amp;<span class="subst">$&#123;params.productKey&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">return</span> options;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>生成基于HmacSha1的password，参考文档：<a href="https://help.aliyun.com/document_detail/73742.html">https://help.aliyun.com/document_detail/73742.html</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">signHmacSha1(params<span class="punctuation">,</span>deviceSecret)<span class="punctuation">&#123;</span></span><br><span class="line">let keys=Object.keys(params).sort();</span><br><span class="line"><span class="comment">//按字典序排序</span></span><br><span class="line">Keys=keys.sort();</span><br><span class="line">const list=<span class="punctuation">[</span><span class="punctuation">]</span>;</span><br><span class="line">keys.map((key)=&gt;<span class="punctuation">&#123;</span></span><br><span class="line">list.push(`$<span class="punctuation">&#123;</span>key<span class="punctuation">&#125;</span>$<span class="punctuation">&#123;</span>params<span class="punctuation">[</span>key<span class="punctuation">]</span><span class="punctuation">&#125;</span>`);</span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br><span class="line">const contentStr=list.join(&#x27;&#x27;);</span><br><span class="line">return crypto.hex_hmac_sha1(deviceSecret<span class="punctuation">,</span>contentStr);</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后实现对按钮的绑定功能事件的实现：</p><p>设备上线：对设备三元组信息进行初始化，使用三元组连接阿里云，并通过“client.on（）”进行监听，将获取到的温湿度数值绑定“wendu”、“shidu”变量，最后在小程序中显示，其实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">online</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">varthat=<span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> options=<span class="variable language_">this</span>.<span class="title function_">initMqttOptions</span>(deviceConfig);</span><br><span class="line"><span class="comment">//连接阿里云</span></span><br><span class="line">client=mqtt.<span class="title function_">connect</span>(<span class="string">&#x27;wxs://&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;.iot-as-mqtt.cn-shanghai.aliyuncs.com&#x27;</span>,options)</span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接服务器成功&#x27;</span>)</span><br><span class="line"><span class="comment">//订阅主题(这里的主题可能会不一样，具体请查看后台设备Topic列表或使用自定义主题)</span></span><br><span class="line">client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/sys/&#x27;</span>+<span class="string">`<span class="subst">$&#123;deviceConfig.productKey&#125;</span>`</span>+<span class="string">&#x27;/&#x27;</span>+<span class="string">`<span class="subst">$&#123;deviceConfig.deviceName&#125;</span>`</span>+<span class="string">&#x27;/thing/service/property/set&#x27;</span>,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!err)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;订阅成功！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接收消息监听</span></span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">topic,message</span>)&#123;</span><br><span class="line">message=message.<span class="title function_">toString</span>()</span><br><span class="line">message=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(message)</span><br><span class="line"><span class="comment">//将接收到的字符串进行Json格式转换</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">that.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">wendu</span>:message[<span class="string">&#x27;items&#x27;</span>][<span class="string">&#x27;temp&#x27;</span>][<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line"><span class="attr">shidu</span>:message[<span class="string">&#x27;items&#x27;</span>][<span class="string">&#x27;hum&#x27;</span>][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>设备下线：将“client”连接关闭，并将“wendu”、“shidu”的值初始化为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">offline</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//client连接断开,关闭连接</span></span><br><span class="line">client.<span class="title function_">end</span>()</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">wendu</span>:<span class="number">0</span>,</span><br><span class="line"><span class="attr">shidu</span>:<span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设备断开连接&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开灯：定义发布链接，设置“Lightswitch”字段为1，通过发布函数将信息提交给阿里云</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turn_on</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> topics=<span class="string">&#x27;/sys/&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;/&#x27;</span>+deviceConfig.<span class="property">deviceName</span>+<span class="string">&#x27;/thing/event/property/post&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> payloadJson=&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="string">&quot;Lightswitch&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;thing.event.property.post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">client.<span class="title function_">publish</span>(topics,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payloadJson))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>关灯：与开灯基本没有区别，将“Lightswitch”字段设置为0即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turn_off</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> topics=<span class="string">&#x27;/sys/&#x27;</span>+deviceConfig.<span class="property">productKey</span>+<span class="string">&#x27;/&#x27;</span>+deviceConfig.<span class="property">deviceName</span>+<span class="string">&#x27;/thing/event/property/post&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> payloadJson=&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="string">&quot;Lightswitch&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;thing.event.property.post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">client.<span class="title function_">publish</span>(topics,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payloadJson))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="实验整体流程"><a href="#实验整体流程" class="headerlink" title="实验整体流程"></a>实验整体流程</h3><p>在阿里云物联网平台添加三个设备（台灯、温湿度传感器、微信小程序），设置规则引擎（用于信息流转），将设备开启连接上云，同时微信小程序开启设备实现数据的监听，一段时间后收到云上的数据，在页面显示温湿度数值；同时可以点击开灯、关灯按钮实现对于台灯的控制</p><p><img src="https://s2.loli.net/2022/03/17/WN2e9JKgUZ7AcsH.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vant组件开发使用</title>
      <link href="/post/2204700370.html"/>
      <url>/post/2204700370.html</url>
      
        <content type="html"><![CDATA[<p>Vant是有赞前端团队开源的移动端组件库，于2016年开源，已持续维护4年时间。Vant对内承载了有赞所有核心业务，对外服务十多万开发者，是业界主流的移动端组件库之一。</p><p>目前Vant官方提供了Vue版本和<a href="http://vant-contrib.gitee.io/vant-weapp">微信小程序版本</a>，并由社区团队维护React版本。</p><h2 id="Vant组件安装"><a href="#Vant组件安装" class="headerlink" title="Vant组件安装"></a>Vant组件安装</h2><h3 id="通过npm方式安装"><a href="#通过npm方式安装" class="headerlink" title="通过npm方式安装"></a><strong>通过npm方式安装</strong></h3><p>先去node.js官网（<a href="https://nodejs.org/en/download/%EF%BC%89%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%EF%BC%8C%E6%9E%84%E5%BB%BAnpm%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%9C%A8cmd%E4%B8%AD%E6%89%A7%E8%A1%8C%60npm">https://nodejs.org/en/download/）下载安装，构建npm命令，在cmd中执行`npm</a> -v&#96;，如下图所示，即完成安装：</p><p><img src="https://s2.loli.net/2022/03/17/2yw4g1jXNLVGsZD.png"></p><p>进入小程序的项目中，如图打开小程序的项目路径的终端，在终端输入：<code>npm init</code>，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qnmO2p9LByAFkeQ.png"></p><p>紧接着在终端继续输入：<code>npm i @vant/weapp -S –production</code>，用于安装Vant组件，出现下图所示及代表下载完成</p><p><img src="https://s2.loli.net/2022/03/17/UVHnBof4Lde5qpX.png"></p><h3 id="构建npm包"><a href="#构建npm包" class="headerlink" title="构建npm包"></a><strong>构建npm包</strong></h3><p>打开微信开发者工具，点击工具→构建npm，并勾选使用npm模块选项，构建完成后，即可引入组件</p><p><img src="https://s2.loli.net/2022/03/17/3I7dTNXvRVZkDgy.png"></p><p>此时在目录树生成“miniprogram_npm”文件夹，如下图所示，Vant组件就下载完成了</p><p><img src="https://s2.loli.net/2022/03/17/GkyqXdBgLrPt3CM.png"></p><h3 id="修改app-json"><a href="#修改app-json" class="headerlink" title="修改app.json"></a><strong>修改app.json</strong></h3><p>将app.json中的”style”:”v2”去除，小程序的<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style">新版基础组件</a>强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱</p><h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a><strong>使用测试</strong></h3><p>以Button组件为例，只需要在app.json或index.json中配置Button对应的路径即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm安装</span></span><br><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果这种情况下没有出现报错情况，就可以正常使用了；如若出现错误，请按照下面方式修改：</p><p>在windows文件夹目录下，把miniprogram_npm@vant\weapp里的文件都删除</p><p><img src="https://s2.loli.net/2022/03/17/jTLOyUpbBc1PARu.png"></p><p>之后再打开<a href="https://github.com/youzan/vant-weapp">vant weapp</a>下载一份vant，将dist文件夹（vant-weapp-dev\vant-weapp-dev\dist）把dist文件夹复制到miniprogram_npm@vant\weapp下即可。</p><p><img src="https://s2.loli.net/2022/03/17/zicQEDyqwxb2f3L.png"></p><p>在app.json或index.json中修改配置Button对应的路径即可导入组件使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm安装</span></span><br><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Vant组件使用示例"><a href="#Vant组件使用示例" class="headerlink" title="Vant组件使用示例"></a>Vant组件使用示例</h2><h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>在index.json中修改配置Button对应的路径，用于定位Button组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van-button”为定义的标签名，“type”为当前按钮的样式类型，“bind:click”用于绑定当前按钮的点击事件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_default&quot;</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span><span class="attr">bind:click</span>=<span class="string">&quot;click_primary&quot;</span> &gt;</span>主要按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_info&quot;</span> &gt;</span>信息按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_warning&quot;</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">bind:click</span>=<span class="string">&quot;click_danger&quot;</span> &gt;</span>危险按钮<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码（console.log用于在控制台输出信息，这个后面会经常用到，方便于调试）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">click_default</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击默认按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_primary</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击主要按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_info</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击信息按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_warning</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击警告按钮&quot;</span>)&#125;,</span><br><span class="line"><span class="title function_">click_danger</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击危险按钮&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>可以在模拟器当中看到效果界面，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/H2Gp1z6bAxOnokq.png"></p><p>点击按钮后在输出栏会打印出信息，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/vTfAZVMtaElkeSy.png"></p><h3 id="Field输入框"><a href="#Field输入框" class="headerlink" title="Field输入框"></a>Field输入框</h3><p>在index.json中修改配置Field对应的路径，用于定位Field组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-field&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/field/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van-field”为定义的标签名，“placeholder”当输入框为空时显示的文本，“bind:change”为输入框添加修改绑定事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-field</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;&#123;&#123;value&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">bind:change</span>=<span class="string">&quot;onChange&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码，打印当前的输入值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">value</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">onChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="comment">//event.detail为当前输入的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">detail</span>);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以在模拟器当中看到效果界面，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/zBfoU8tumxknws2.png"></p><p>在输入框输入文本后，会在调试栏实时打印出来，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/kltau4yKwgnz8hS.png"></p><h3 id="Checkbox复选框"><a href="#Checkbox复选框" class="headerlink" title="Checkbox复选框"></a>Checkbox复选框</h3><p>在index.json中修改配置Checkbox对应的路径，用于定位Checkbox复选框组件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-checkbox&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/checkbox/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在wxml中添加如下代码，“van- checkbox”为定义的标签名，“value”绑定当前复选框的值，“bind:change”为复选框添加修改绑定事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-checkbox</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;checked&#125;&#125;&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;onChange&quot;</span>&gt;</span></span><br><span class="line">复选框</span><br><span class="line"><span class="tag">&lt;/<span class="name">van-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在js中添加点击执行事件的函数代码，用于改变当前复选框的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">checked</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">onChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line"><span class="attr">checked</span>:event.<span class="property">detail</span>,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以点击复选框修改当前的状态，如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/zHdgPGCUSTrbvDL.png"></p><h3 id="Layout布局"><a href="#Layout布局" class="headerlink" title="Layout布局"></a>Layout布局</h3><p>Layout提供了van-row和van-col两个组件来进行行列布局，在index.json中修改配置Layout对应的路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;van-row&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/row/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;van-col&quot;</span><span class="punctuation">:</span><span class="string">&quot;@vant/weapp/dist/col/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Layout组件提供了24列栅格，通过在Col上添加span属性设置列所占的宽度百分比；此外，添加offset属性可以设置列的偏移宽度，计算方式与span相同，在wxml中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;4&quot;</span>&gt;</span>span: 4<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;10&quot;</span><span class="attr">offset</span>=<span class="string">&quot;4&quot;</span>&gt;</span>offset: 4, span: 10<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">offset</span>=<span class="string">&quot;12&quot;</span> <span class="attr">span</span>=<span class="string">&quot;12&quot;</span>&gt;</span>offset: 12, span: 12<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其布局最终效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/24c7KL9XqVwFyEp.png"></p><p>通过gutter属性可以设置列元素之间的间距，默认间距为0，在wxml中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-row</span> <span class="attr">gutter</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-col</span> <span class="attr">span</span>=<span class="string">&quot;8&quot;</span>&gt;</span>span: 8<span class="tag">&lt;/<span class="name">van-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-row</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其布局最终效果如下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/JnTvyGAa2Wxihc8.png"></p><p>更多相关组件的使用方法可以在<a href="https://vant-contrib.gitee.io/vant-weapp">Vant的官方说明文档</a>中查看</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发入门</title>
      <link href="/post/1597505920.html"/>
      <url>/post/1597505920.html</url>
      
        <content type="html"><![CDATA[<h2 id="微信开发者工具介绍"><a href="#微信开发者工具介绍" class="headerlink" title="微信开发者工具介绍"></a>微信开发者工具介绍</h2><p>为了帮助开发者简单和高效地开发和调试微信小程序，微信官方在原有的公众号网页调试工具的基础上，推出了全新的<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发者工具</a>，集成了公众号网页调试和小程序调试两种开发模式。</p><ul><li>使用公众号网页调试，开发者可以调试微信网页授权和微信JS-SDK</li><li>使用小程序调试，开发者可以完成小程序的API和页面的开发调试、代码查看和编辑、小程序预览和发布等功能。</li></ul><p>在<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发平台</a>可以直接下载，点击进入下载任意版本即可。使用安装包进行安装，一直点下一步即可（需要更换安装目录可自行配置）</p><p><img src="https://s2.loli.net/2022/03/17/9Sb5kVWvfNRsXyI.png"></p><h3 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h3><p><strong>登录页</strong></p><p>在登录页，可以使用微信扫码登录开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。</p><p><img src="https://s2.loli.net/2022/03/17/cBfd2gaO6F5ATxX.png"></p><p><strong>项目列表</strong></p><p>登录成功后，会看到已经存在的项目列表和代码片段列表，在项目列表可以选择公众号网页调试，进入到公众号网页调试模式</p><p><img src="https://s2.loli.net/2022/03/17/W3dsXC7g54ZwaOz.png"></p><p><strong>新建项目</strong></p><p>当符合以下条件时，可以在本地创建一个小程序项目：</p><ol><li>需要一个小程序的AppID；如没有AppID，可以选择申请使用测试号；</li><li>登录的微信号需要是该AppID的开发者；</li><li>需要选择一个空目录，或者选择的非空目录下存在app.json或者project.config.json。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。</li></ol><p><img src="https://s2.loli.net/2022/03/17/xA3okJEgwneXzRq.png"></p><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>开发者工具主界面，从上到下，从左到右，分别为：菜单栏、工具栏、模拟器、目录树、编辑区、调试器六大部分。</p><p><img src="https://s2.loli.net/2022/03/17/lRWGpF4Ls9uDqIo.png"></p><p><strong>菜单栏</strong></p><ol><li><p>项目</p><blockquote><p>新建项目：快速新建项目</p><p>打开最近：可以查看最近打开的项目列表，并选择是否进入对应项目</p><p>查看所有项目：新窗口打开启动页的项目列表页</p><p>关闭当前项目：关闭当前项目，回到启动页的项目列表页</p></blockquote></li><li><p>文件</p><blockquote><p>新建文件</p><p>保存</p><p>保存所有</p><p>关闭文件</p></blockquote></li><li><p>编辑：可以查看编辑相关的操作和快捷键</p></li><li><p>工具</p><blockquote><p>编译：编译当前小程序项目</p><p>刷新：与编译的功能一致，由于历史原因保留对应的快捷键ctrl+R</p><p>编译配置：可以选择普通编译或自定义编译条件</p><p>前后台切换：模拟客户端小程序进入后台运行和返回前台的操作</p><p>清除缓存：清除文件缓存、数据缓存、以及授权数据</p></blockquote></li><li><p>界面：控制主界面窗口模块的显示与隐藏</p></li><li><p>设置</p><blockquote><p>外观设置：控制编辑器的配色主题、字体、字号、行距</p><p>编辑设置：控制文件保存的行为，编辑器的表现</p><p>代理设置：选择直连网络、系统代理和手动设置代理</p><p>通知设置：设置是否接受某种类型的通知</p></blockquote></li></ol><p><strong>工具栏</strong></p><p>工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览；通过切后台按钮，可以模拟小程序进入后台的情况；工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。</p><p><img src="https://s2.loli.net/2022/03/17/NyEAMvsmbGqFIPD.png"></p><p>工具栏右侧是开发辅助功能的区域，在这里可以上传代码、版本管理、查看项目详情，如上图所示。</p><p><strong>模拟器</strong></p><p>模拟器可以模拟小程序在微信客户端的表现。小程序的代码通过编译后可以在模拟器上直接运行。开发者可以选择不同的设备，也可以添加自定义设备来调试小程序在不同尺寸机型上的适配问题。</p><p><img src="https://s2.loli.net/2022/03/17/Tzpx4mc9tihYSCj.png"></p><h2 id="你的第一个小程序"><a href="#你的第一个小程序" class="headerlink" title="你的第一个小程序"></a>你的第一个小程序</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的AppID，给你的项目起一个好听的名字，勾选”不使用云服务”（注意:你要选择一个空的目录才可以创建项目），点击新建，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在微信开发者工具中预览你的第一个小程序。</p><p><img src="https://s2.loli.net/2022/03/17/QqNxkPceW6igD1w.png"></p><p>点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。</p><p><img src="https://s2.loli.net/2022/03/17/Dwovtr1EFKuPVjZ.png"></p><h3 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h3><p>我们通过开发者工具快速创建了一个QuickStart项目。你可以留意到这个项目里边生成了不同类型的文件:</p><ul><li>.json后缀的JSON配置文件</li><li>.wxml后缀的WXML模板文件</li><li>.wxss后缀的WXSS样式文件</li><li>.js后缀的JS脚本逻辑文件</li></ul><p><strong>JSON配置</strong></p><p>JSON是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。</p><p>我们可以看到在项目的根目录有一个app.json和project.config.json，此外在pages&#x2F;logs目录下还有一个logs.json，我们依次来说明一下它们的用途。</p><ol><li><p>小程序配置app.jsonapp.json</p><p>小程序配置app.jsonapp.json是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部tab等。QuickStart项目里边的app.json配置内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;window&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;backgroundTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;light&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span><span class="string">&quot;#fff&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span><span class="string">&quot;Weixin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;black&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>工具配置project.config.json</p><p>通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。</p><p>考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p></li><li><p>页面配置page.json</p><p>这里的page.json其实用来表示pages&#x2F;logs目录下的logs.json这类和小程序页面相关的配置。</p><p>如果你整个小程序的风格是蓝色调，那么你可以在app.json里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。</p></li></ol><p><strong>WXML 模板</strong></p><p>从事过网页编程的人知道，网页编程采用的是HTML+CSS+JS这样的组合，其中HTML是用来描述当前这个页面的结构，CSS用来描述页面的样子，JS通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中WXML充当的就是类似HTML的角色。打开pages&#x2F;index&#x2F;index.wxml，你会看到以下的内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span>获取头像昵称<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和HTML非常相似，WXML由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：</p><p>（1）标签名字有点不一样往往写 HTML 的时候，经常会用到的标签是div，p，span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。从上边的例子可以看到，小程序的WXML用的标签是view，button，text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。</p><p>（2）多了一些<code>wx:if</code>这样的属性以及<code>&#123;&#123; &#125;&#125;</code>这样的表达式在网页的一般开发流程中，我们通常会通过JS操作DOM（对应HTML的描述产生的树），以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS会记录一些状态到JS变量里边，同时通过DOM API操控DOM的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了MVVM的开发模式（例如React，Vue），提倡把渲染和逻辑分离。简单来说就是不要再让JS直接操控DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路，如果你需要把一个Hello World字符串显示在界面上。WXML是这么写:<code>&#123;&#123;msg&#125;&#125;JS</code>只需要管理状态即可:<code>this.setData(&#123;msg:&quot;Hello World&quot;&#125;)</code>通过<code>&#123;&#123; &#125;&#125;</code>的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要<code>if/else，for</code>等控制能力，在小程序里边，这些控制能力都用<code>wx:</code>开头的属性来表达。</p><p><strong>WXSS 样式</strong></p><p>WXSS具有CSS大部分的特性，小程序在WXSS也做了一些扩充和修改。</p><ol><li><p>新增了尺寸单位</p><p>在写CSS样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS在底层支持新的尺寸单位rpx，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</p></li><li><p>提供了全局的样式和局部样式</p><p>和前边app.json，page.json的概念相同，你可以写一个app.wxss作为全局样式，会作用于当前小程序的所有页面，局部页面样式page.wxss仅对当前页面生效。</p></li><li><p>此外WXSS仅支持部分CSS选择器</p></li></ol><p><strong>JS 逻辑交互</strong></p><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写JS脚本文件来处理用户的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序开发者工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（二）</title>
      <link href="/post/6004.html"/>
      <url>/post/6004.html</url>
      
        <content type="html"><![CDATA[<p>本文将接前文，继续讲述python程序对微信云开发数据库的操作。</p><h2 id="间接操作"><a href="#间接操作" class="headerlink" title="间接操作"></a>间接操作</h2><p>间接操作指的是python通过云函数对云开发数据库进行操作。所有的操作都是在获取access_token的前提下进行的，不懂的同学可以参考：链接: <a href="https://blog.csdn.net/qq_44001007/article/details/103944492">link</a>.<br>同时由于请求python请求云函数的代码基本类似，只有在data里面进行参数的变换即可，给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xxxx</span>(<span class="params">self</span>):</span><br><span class="line">    //在函数括号内需要添加参数</span><br><span class="line">    ACCESS_TOKEN = xxx   //获取的access_token</span><br><span class="line">    ENV = xxx                      //用户的数据库环境ID</span><br><span class="line">    FUNCTION_NAME = xxx   //所要执行的云函数名</span><br><span class="line">    url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=&#x27;</span> + ACCESS_TOKEN + <span class="string">&#x27;&amp;env=&#x27;</span> + ENV + <span class="string">&#x27;&amp;name=&#x27;</span> + FUNCTION_NAME</span><br><span class="line">    data = &#123;</span><br><span class="line">    //所要传输的参数</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url, data=json.dumps(data))</span><br><span class="line">    result = response.json()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>云函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.<span class="title function_">init</span>()</span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> db.<span class="title function_">createCollection</span>(event.<span class="property">id</span>)</span><br><span class="line">  <span class="comment">//event.id是python传输的数据，为该集合的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createCollection</span>(<span class="params">self，<span class="built_in">id</span></span>):</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="built_in">id</span>,</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h3><p>云函数：</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ndnSIM实现一发多收</title>
      <link href="/post/52359.html"/>
      <url>/post/52359.html</url>
      
        <content type="html"><![CDATA[<p>直接进入正题，想要实现一发多收，就是要在路由进行广播时转发的兴趣包与接收到数据包的数目相等，即For_num&#x3D;&#x3D;Rec_num；但正常情况下，路由在第一次接收到数据包时就会把pit条目删除，所以接下来的目的是在接收到数据包对删除pit的命令进行修改。</p><h2 id="pit条目修改"><a href="#pit条目修改" class="headerlink" title="pit条目修改"></a>pit条目修改</h2><p>先进入到ndnSIM源目录下</p><p><img src="https://s2.loli.net/2022/03/13/c1q9ETghuMdUK3w.png"></p><p>然后进入pit-entry.cpp&#x2F;.hpp所在目录，对这两个文件进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd NFD/daemon/table/</span><br></pre></td></tr></table></figure><p>先对hpp进行修改，添加For_NUM和Rec_NUM两个变量</p><p><img src="https://s2.loli.net/2022/03/13/ZDa2F4NlGQ5Ocwo.png"></p><p>然后添加获取参数的函数与对变量操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_RecNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Rec_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> </span></span><br><span class="line"><span class="function"><span class="title">get_ForNUM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> For_NUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_inter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> For_NUM++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">afterRec_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Rec_NUM++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下进行参数的初始化定义，在cpp中实现</p><p><img src="https://s2.loli.net/2022/03/13/AESXW1HhkKRD3xe.png"></p><h2 id="转发策略修改"><a href="#转发策略修改" class="headerlink" title="转发策略修改"></a>转发策略修改</h2><h3 id="after-Recevie-Interest"><a href="#after-Recevie-Interest" class="headerlink" title="after Recevie Interest"></a>after Recevie Interest</h3><p>进入forwarder.cpp所在文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable constant_">NFD</span>/daemon/fw</span><br></pre></td></tr></table></figure><p>修改onOutgoingInterest（）函数</p><p><img src="https://s2.loli.net/2022/03/13/yH9XEQ1fVdRsglu.png"></p><h3 id="after-Recevie-data"><a href="#after-Recevie-data" class="headerlink" title="after Recevie data"></a>after Recevie data</h3><p>在同一个目录下打开strategy.cpp文件，对sendData（）函数进行修改</p><p><img src="https://s2.loli.net/2022/03/13/YxvCfIayOSl2L18.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行一个具有多个生产者的路由拓扑，查看路由接收的数据包数量，即可确认是否实现一发多收。</p><p><img src="https://s2.loli.net/2022/03/13/nkbEUVugKwcrqdZ.png"></p><p>有上图可以得出接收的是发送的两倍，实现一发多收。</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu安装ndnSIM</title>
      <link href="/post/57172.html"/>
      <url>/post/57172.html</url>
      
        <content type="html"><![CDATA[<p>通过对资料的查询获取相对应的版本号与ndnsim之间的关系：</p><table><thead><tr><th>操作系统</th><th>Ubuntu 18</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.7</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-ns-3.29</td></tr><tr><td>pybindgen</td><td>0.19.0</td></tr></tbody></table><p>如果想要安装其他版本，请找到上述条件所对应的版本号即可。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential libsqlite3-dev libboost-all-dev libssl-dev git python-setuptools castxml</span><br><span class="line">sudo apt install python-dev python-pygraphviz python-kiwi python-gnome2 ipython libcairo2-dev python3-gi libgirepository1.0-dev python-gi python-gi-cairo gir1.2-gtk-3.0 gir1.2-goocanvas-2.0 python-pip</span><br><span class="line">pip install pygraphviz pycairo PyGObject pygccxml</span><br><span class="line">sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config</span><br><span class="line">pip install pygraphviz</span><br></pre></td></tr></table></figure><p>可能出现报错无法安装的情况，我把后面的安装好，在安装前面的就成功了;同时这是Ubuntu18所需要的依赖环境，其他版本请参照官网。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>现在任意文件创建个ndnsim文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ndnSIM2.7</span><br></pre></td></tr></table></figure><p>然后进入该文件夹下，进行源码的下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>记住千万不要在最后一条命令按照官网的说法加上–recursive，这样就会把NFD和ndn-cxx模块直接下载最新版本，这样后面的操作就无效了。</p><h2 id="修改对应版本号"><a href="#修改对应版本号" class="headerlink" title="修改对应版本号"></a>修改对应版本号</h2><p>这里的命令依靠git实现，能到这一步肯定都安装好了，就不多说了。<br>首先进入到ndnSIM的核心源码地带</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ns-3/src/ndnSIM</span><br></pre></td></tr></table></figure><p>通过git checkout修改版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-2.7</span><br></pre></td></tr></table></figure><p>也可以通过git tag查看所有的版本号，然后修改为想要安装的版本</p><p><img src="https://img-blog.csdnimg.cn/20200725105311613.png"></p><p>然后安装NFD和ndn-cxx模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><p>接下来进入到ndnSIM2.7&#x2F;ns-3文件下进行版本的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ndnSIM-ns-3.29</span><br></pre></td></tr></table></figure><p>出现如图所示即为成功</p><p><img src="https://s2.loli.net/2022/03/12/LtPm79ICKAYwdrg.png"></p><p>接下对pybindgen的版本进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.7/pybindgen</span><br><span class="line">git checkout 0.19.0</span><br></pre></td></tr></table></figure><p>然后在此目录下安装安装该python模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2022/03/12/fnUh7aDJ2MOErR5.png"></p><h2 id="运行编译"><a href="#运行编译" class="headerlink" title="运行编译"></a>运行编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ndnSIM2.1/ns-3</span><br><span class="line">./waf configure --enable-examples</span><br><span class="line">./waf</span><br><span class="line">./waf --run ndn-simple --vis</span><br></pre></td></tr></table></figure><p>正常情况直接编译完成，出现错误的话请看下面的修改提示</p><p><img src="https://s2.loli.net/2022/03/12/B1fgyvZdDbkqxri.png"></p><p>进入到可视化模块下将‘file&#x3D;’删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  ndnSIM2.7/ns-3/src/visualizer/visualizer</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/12/q8nABHgkLvl2smt.png"></p><p>进入base.py文件，修改保存即可</p><p><img src="https://s2.loli.net/2022/03/12/ka8ywbI1o5YvpLj.png"></p><p>第二种错误可能出现在运行时加上–vis可视化模块时，如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/UDG7XjaZmOF3BuJ.png"></p><p>这种情况下，还是进入刚才的那个文件夹，修改hub.py文件</p><p><img src="https://s2.loli.net/2022/03/12/brEc9vg3pFwqhsj.png"></p><p>将from . import注释，修改为import core。再次运行就可以了</p><p><img src="https://s2.loli.net/2022/03/12/94Q7mq85lV1ekwz.png"></p><p>经过试验，添加Ubuntu16的对应版本</p><table><thead><tr><th>操作系统</th><th>Ubuntu 16</th></tr></thead><tbody><tr><td>ndnSIM</td><td>ndnSIM-2.5</td></tr><tr><td>ns-3-dev</td><td>ndnSIM-v2.5</td></tr><tr><td>pybindgen</td><td>0.18.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndnSIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python对微信云开发数据库的操作（一）</title>
      <link href="/post/34574.html"/>
      <url>/post/34574.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述python程序对微信云开发数据库的操作。</p><h1 id="直接操作"><a href="#直接操作" class="headerlink" title="直接操作"></a>直接操作</h1><p>直接操作指的是通过python程序对云开发数据库直接进行操作。<br>所有的操作前提都是在获取access_token下进行的，先通过下列代码获取access_token在进行接下来的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access_token</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           获取access_token</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        APPID = <span class="string">&#x27;**********&#x27;</span>                        //小程序ID</span><br><span class="line">        APPSECRET = <span class="string">&#x27;**************&#x27;</span>                //小程序秘钥</span><br><span class="line">        WECHAT_URL = <span class="string">&#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#x27;</span> + APPID + <span class="string">&#x27;&amp;secret=&#x27;</span> + APPSECRET</span><br><span class="line">        response = requests.get(WECHAT_URL)</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&quot;access_token&quot;</span>]     //将返回值解析获取access_token</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>此方法的创建只需要将集合的名字post给数据库即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseCollectionAdd</span>(<span class="params">access_token</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          创建数据库</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasecollectionadd?access_token&#x27;</span>+access_token</span><br><span class="line">       data=&#123;</span><br><span class="line">             <span class="string">&quot;env&quot;</span>:<span class="string">&quot;******&quot;</span>,                //用户的数据库环境ID</span><br><span class="line">             <span class="string">&quot;collection_name&quot;</span>: <span class="string">&quot;*******&quot;</span>   //数据库集合的名称</span><br><span class="line">             &#125;</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><p>将集合的名字Post即可返回该集合的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            检索数据库</span></span><br><span class="line"><span class="string">           collection_name 集合的名称</span></span><br><span class="line"><span class="string">           .limit() 括号内的数值限定返回的记录数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasequery?access_token=&#x27;</span> + access_token</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).limit(100).get()&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(url, data=json.dumps(data))</span><br><span class="line">        result = response.json()</span><br><span class="line">        <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>通过Post集合名字和Add函数对内容（datas）的传输。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseAdd</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       新建记录并对内容进行定义</span></span><br><span class="line"><span class="string">       collection_name 集合的名称</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).add(&#123;&quot;</span>+datas+<span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       datas=[&#123;</span><br><span class="line">       <span class="string">&quot;字段名称&quot;</span>：<span class="string">&quot;内容&quot;</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       这里主要是对创建记录的直接定义</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">             &#125;]</span><br><span class="line">       response = requests.post(url, data=json.dumps(data))</span><br><span class="line">       result = response.json()</span><br><span class="line">       <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><p>经测试这种创建记录的方式对datas的定义要求较为严格，一但定义不够严格会出现创建失败，所以建议通过间接的方式对数据库进行插入记录。</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>通过Post集合名称将该集合直接从数据库移除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseQuery</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         collection_name 集合的名称</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databasedelete?access_token=&#x27;</span> + access_token</span><br><span class="line">      data = &#123;</span><br><span class="line">          <span class="string">&quot;env&quot;</span>: <span class="string">&quot;*******&quot;</span>,          //用户的数据库环境ID</span><br><span class="line">          <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;)..where(&#123;done:false&#125;).remove()&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      response = requests.post(url, data=json.dumps(data))</span><br><span class="line">      result = response.json()</span><br><span class="line">      <span class="built_in">print</span>(result)     //将返回值打印</span><br></pre></td></tr></table></figure><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>更新记录是对已有的记录内容进行修改，所以说想要对记录内容修改不可用.add()进行，通过.update()进行内容修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">databaseUpdate</span>(<span class="params">access_token,collection_name</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       .where() 该集合所在记录的检索</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       url = <span class="string">&#x27;https://api.weixin.qq.com/tcb/databaseadd?access_token&#x27;</span> + access_token</span><br><span class="line">       data = &#123;</span><br><span class="line">           <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="string">&quot;query&quot;</span>: <span class="string">&quot;db.collection(\&quot;&quot;</span>+collection_name+<span class="string">&quot;\&quot;).where(&#123;age:14&#125;).update(&#123;data:&#123;age: _.inc(1)&#125;&#125;)&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">      &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">      这个例子是将集合里age=<span class="number">14</span>所有记录自增<span class="number">1</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       response = requests.post(url, data=json.dumps(data))</span></span><br><span class="line"><span class="string">       result = response.json()</span></span><br><span class="line"><span class="string">       print(result)     //将返回值打印</span></span><br></pre></td></tr></table></figure><p>更新是对记录的操作，所以很需要.where()的帮助，请大家牢记该函数的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是通过对微信小程序一段时间的学习后总结出来的，本作者是个新人，如有错误可指出，我将及时改正。<br>第二部分是通过调用云函数来对数据库进行操作，这种方法的BUG似乎比直接操作少。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nRF52840作为通信模块与Arduino的联动</title>
      <link href="/post/10336.html"/>
      <url>/post/10336.html</url>
      
        <content type="html"><![CDATA[<h3 id="蓝牙控制Arduino板上13号引脚灯的开关"><a href="#蓝牙控制Arduino板上13号引脚灯的开关" class="headerlink" title="蓝牙控制Arduino板上13号引脚灯的开关"></a>蓝牙控制Arduino板上13号引脚灯的开关</h3><h4 id="开发环境及工具"><a href="#开发环境及工具" class="headerlink" title="开发环境及工具"></a>开发环境及工具</h4><table><thead><tr><th></th><th>名称</th></tr></thead><tbody><tr><td>开发工具</td><td>Segger Embedded Studio</td></tr><tr><td>SDK版本</td><td>nRF5_SDK_15.3.0_59ac345</td></tr><tr><td>开发板</td><td>IK-nRF52840DK+Arduino Uno+IO扩展板</td></tr><tr><td>J-link</td><td>ARM-V9仿真器</td></tr><tr><td>手机App</td><td>nRF UART v2.0</td></tr></tbody></table><h4 id="nRF52840的代码烧录"><a href="#nRF52840的代码烧录" class="headerlink" title="nRF52840的代码烧录"></a>nRF52840的代码烧录</h4><p>打开SKD中示例的ble_app_uart，路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\nRF5_SDK_15.3.0_59ac345\examples\ble_peripheral\ble_app_uart\pca10056\s140\ses</span><br></pre></td></tr></table></figure><p>在main函数中将循环实例修改：</p><img src="https://s2.loli.net/2022/03/12/SyufYqkPidp9lae.png" style="zoom: 80%;" /><p>红圈里的修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> cr;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_get</span>(&amp;cr) != NRF_SUCCESS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">app_uart_put</span>(cr) != NRF_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cr == <span class="string">&#x27;q&#x27;</span> || cr == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; \r\nExit!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后Build，Debug：</p><img src="https://s2.loli.net/2022/03/12/mXoL1pqk4ysEP9Q.png" style="zoom:67%;" /><img src="https://s2.loli.net/2022/03/12/gMkvVwdZ93WDc5Q.png" style="zoom:67%;" /><h4 id="Arduino的测试代码"><a href="#Arduino的测试代码" class="headerlink" title="Arduino的测试代码"></a>Arduino的测试代码</h4><p>将测试代码刷入Arduino就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line"> <span class="built_in">pinMode</span>(<span class="number">13</span>,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Serial.<span class="built_in">available</span>())&#123;</span><br><span class="line">    ss=Serial.<span class="built_in">read</span>();</span><br><span class="line">  Serial.<span class="built_in">println</span>(ss);</span><br><span class="line">    <span class="keyword">if</span>(ss==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">digitalWrite</span>(<span class="number">13</span>,HIGH); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">digitalWrite</span>(<span class="number">13</span>,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固件连接"><a href="#固件连接" class="headerlink" title="固件连接"></a>固件连接</h4><p>将nRF52840的P06号脚接到IO扩展板上的RX接口，然后将VCC和GND与IO扩展板相应位置连接，如下图：</p><img src="https://s2.loli.net/2022/03/12/5ARiQ2kcNTVZPmF.png" style="zoom:50%;" /><p>然后Arduino板通上电。</p><h4 id="手机蓝牙端测试"><a href="#手机蓝牙端测试" class="headerlink" title="手机蓝牙端测试"></a>手机蓝牙端测试</h4><p>1.打开App搜索设备</p><img src="https://s2.loli.net/2022/03/12/YHX76db9yNPOaAB.png" style="zoom: 33%;" /><p>连接_UART设备<br>2.发送测试数据字符1</p><img src="https://s2.loli.net/2022/03/12/bSqRlZeEKkUvrnu.png" style="zoom:33%;" /><p>然后板上13灯亮起</p><img src="https://s2.loli.net/2022/03/12/WrNcS3XsHnOwyCx.png" style="zoom:50%;" /><p>3.输入其他任意字符熄灭</p><img src="https://s2.loli.net/2022/03/12/zfd4oCUTIFHA1se.png" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/03/12/QrER1vYujwzAGOD.png" style="zoom:50%;" /><p>到这里就基本结束测试，当然大家可以在扩展板上加更多的传感器去实现更加强大的功能!!!!!</p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nordic nRF52840 入门学习</title>
      <link href="/post/4057281378.html"/>
      <url>/post/4057281378.html</url>
      
        <content type="html"><![CDATA[<h3 id="Board-Definition组"><a href="#Board-Definition组" class="headerlink" title="Board Definition组"></a>Board Definition组</h3><p>“ Board Definition”组中加入板卡定义文件“ boards.c”,该文件针对于具体板卡,主要要用来定义板卡的指示灯、按键、IO输出电压(仅nRFS2840具有此功能)以及常用的操作函数。对于Nordic nRF52840开发板(兼容 Nordic的PCA10056),设计了4个指示灯和按键,在“ boards.c”文件中,我们可以看到这些按键和指示灯的初始化函数以及一些基本功能如点亮、熄灭、翻转的操作函数。</p><p><img src="https://s2.loli.net/2022/03/12/8pnHB7jaXv2kP1Y.png"></p><h3 id="Board-Support组"><a href="#Board-Support组" class="headerlink" title="Board Support组"></a>Board Support组</h3><p>“ Board Support”组加入的是板卡支持包文件,即BSP文件,主要用于实现指示灯和按键的驱动。</p><p><img src="https://s2.loli.net/2022/03/12/WS51mxILhzJCi23.png"></p><h3 id="UTF8-x2F-UTF16-converter-组"><a href="#UTF8-x2F-UTF16-converter-组" class="headerlink" title="UTF8&#x2F;UTF16 converter 组"></a>UTF8&#x2F;UTF16 converter 组</h3><p>“UTF8&#x2F;UTF16 converter”组只需加入一个实现UTF8&#x2F;UTF16编码转换的文件。<br><img src="https://s2.loli.net/2022/03/12/4Lein2tspcY97rK.png"></p><h3 id="NRF-BLE组"><a href="#NRF-BLE组" class="headerlink" title="NRF BLE组"></a>NRF BLE组</h3><p>“ NRF BLE”组加入的是BLE相关的库文件,如广播、连接参数协、配对管理等等。<br><img src="https://s2.loli.net/2022/03/12/KgaQWBhncswMU2b.png"></p><h3 id="NRF-Drivers组"><a href="#NRF-Drivers组" class="headerlink" title="NRF Drivers组"></a>NRF Drivers组</h3><p>“ NRF Drivers”组加入的是各种外设的驱动库文件,如时钟、 GPOTE、UART等等。<br><img src="https://s2.loli.net/2022/03/12/M3wb9xsVk8r6tGI.png"></p><h3 id="NRF-Libraries"><a href="#NRF-Libraries" class="headerlink" title="NRF Libraries"></a>NRF Libraries</h3><p>“ NRF Libraries”组加入的是各种应用的库文件,如APP定时器、CRC校验、软件FIFO、<br>简易文件系统以及错误处理等等。<br><img src="https://s2.loli.net/2022/03/12/SsLUGfnVT13moBE.png"></p><h3 id="NRF-Log组"><a href="#NRF-Log组" class="headerlink" title="NRF Log组"></a>NRF Log组</h3><p>“ NRF Log”组中加入的文件如下表所示,Log程序模块为程序提供日志打印功能。<br><img src="https://s2.loli.net/2022/03/12/zhJHxUvIKMVwnY9.png"></p><h3 id="NRF-Segger-RT组"><a href="#NRF-Segger-RT组" class="headerlink" title="NRF Segger_RT组"></a>NRF Segger_RT组</h3><p>nRF_ Segger_RTT”组中加入的文件如下表所示,它们的作用是实现 JLINK- RTT Viewer<br>作为Log输出终端,打印Log。<br><img src="https://s2.loli.net/2022/03/12/E61qimBFjCzGpUP.png"></p><h3 id="NRE-Softdevice"><a href="#NRE-Softdevice" class="headerlink" title="NRE Softdevice"></a>NRE Softdevice</h3><p>“nRF_ Softdevice”组中加入的文件如下表所示,它们用于使能或禁止 Softdevice以及<br>向应用程序发布 Softdevice事件,功能如下:</p><p>(1)使能 Softdevice及其事件中断。</p><p>(2)禁止 Softdevice。</p><p>(3)从 Softdevice接收堆栈事件,并将它们转发给应用程序已注册的事件监查者。</p><p>(4)发送 Softdevice状态事件给应用程序和驱动。</p><p>(5)发送可由事件监查者接受或拒绝的SoftDevice状态请求。<br><img src="https://s2.loli.net/2022/03/12/Ils5mSyvA7k1Uwr.png"></p>]]></content>
      
      
      <categories>
          
          <category> NDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nRF52840 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turtle 3PA三轮小车基于pixhawk的改装（一）</title>
      <link href="/post/53698.html"/>
      <url>/post/53698.html</url>
      
        <content type="html"><![CDATA[<h1 id="Turtle-3PA三轮小车基于pixhawk的改装之准备"><a href="#Turtle-3PA三轮小车基于pixhawk的改装之准备" class="headerlink" title="Turtle 3PA三轮小车基于pixhawk的改装之准备"></a>Turtle 3PA三轮小车基于pixhawk的改装之准备</h1><p>今天在老师的指导下，对Arduino的小车进行改装，想要用pixhawk自动驾驶仪对小车进行控制。<br>工具准备：<br>（1）硬件<br>pixhawk控制板:</p><p><img src="https://s2.loli.net/2022/03/12/4zsFJA7OLHZD6UP.png"></p><p>Turtle 3PA三轮小车：</p><p><img src="https://s2.loli.net/2022/03/12/gxma9oRutrOfMyX.png"></p><p>详细信息：<a href="http://www.dfrobot.com.cn/goods-1069.html">http://www.dfrobot.com.cn/goods-1069.html</a></p><p>乐迪at9s：</p><p><img src="https://s2.loli.net/2022/03/12/39ucVU6LwgjZ1sm.png"></p><p>（2）软件<br>Mission planner：</p><p><img src="https://s2.loli.net/2022/03/12/hxqV1kIG29iJBYo.png"></p><p>官网：<a href="http://ardupilot.org/planner/">http://ardupilot.org/planner/</a><br>QGround：</p><p><img src="https://s2.loli.net/2022/03/12/7ASgCUQti9TrePN.png"></p><p>官网：<a href="http://qgroundcontrol.com/">http://qgroundcontrol.com/</a></p><p>两个地面站是为了刷飞控固件的方便，在对pixhawk飞控刷小车固件的时候总会出现Bad Ahrs，为了解决这个问题因此采用QGround。<br>具体的刷的方法在下个博客说明。</p>]]></content>
      
      
      <categories>
          
          <category> 科技杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pixhawk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
